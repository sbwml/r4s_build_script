From 8e99ca1fd377674fee10c155487651aa3ae36a34 Mon Sep 17 00:00:00 2001
From: sbwml <admin@cooluc.com>
Date: Mon, 8 Jul 2024 21:37:21 +0800
Subject: [PATCH] r8125: add r8125 ethernet poll mode driver

r8125 is for Realtek 2.5 Gigabit Ethernet NICs.

Signed-off-by: sbwml <admin@cooluc.com>
Signed-off-by: Howard Wang <pro_nic_dpdk@realtek.com>
---
 MAINTAINERS                            |    5 +
 doc/guides/nics/features/r8125.ini     |   35 +
 doc/guides/nics/r8125.rst              |   18 +
 drivers/net/meson.build                |    1 +
 drivers/net/r8125/base/rtl8125a.c      |  416 ++++++
 drivers/net/r8125/base/rtl8125a_mcu.c  | 1602 ++++++++++++++++++++++++
 drivers/net/r8125/base/rtl8125a_mcu.h  |   14 +
 drivers/net/r8125/base/rtl8125b.c      |  398 ++++++
 drivers/net/r8125/base/rtl8125b_mcu.c  | 1067 ++++++++++++++++
 drivers/net/r8125/base/rtl8125b_mcu.h  |   14 +
 drivers/net/r8125/base/rtl8125bp.c     |  115 ++
 drivers/net/r8125/base/rtl8125bp_mcu.c |  288 +++++
 drivers/net/r8125/base/rtl8125bp_mcu.h |   13 +
 drivers/net/r8125/base/rtl8125d.c      |  246 ++++
 drivers/net/r8125/base/rtl8125d_mcu.c  |  617 +++++++++
 drivers/net/r8125/base/rtl8125d_mcu.h  |   13 +
 drivers/net/r8125/meson.build          |   18 +
 drivers/net/r8125/r8125_base.h         |  634 ++++++++++
 drivers/net/r8125/r8125_dash.c         |  227 ++++
 drivers/net/r8125/r8125_dash.h         |   64 +
 drivers/net/r8125/r8125_ethdev.c       | 1165 +++++++++++++++++
 drivers/net/r8125/r8125_ethdev.h       |  148 +++
 drivers/net/r8125/r8125_hw.c           | 1107 ++++++++++++++++
 drivers/net/r8125/r8125_hw.h           |   97 ++
 drivers/net/r8125/r8125_logs.h         |   52 +
 drivers/net/r8125/r8125_phy.c          |  900 +++++++++++++
 drivers/net/r8125/r8125_phy.h          |  141 +++
 drivers/net/r8125/r8125_rxtx.c         | 1493 ++++++++++++++++++++++
 28 files changed, 10908 insertions(+)
 create mode 100644 doc/guides/nics/features/r8125.ini
 create mode 100644 doc/guides/nics/r8125.rst
 create mode 100644 drivers/net/r8125/base/rtl8125a.c
 create mode 100644 drivers/net/r8125/base/rtl8125a_mcu.c
 create mode 100644 drivers/net/r8125/base/rtl8125a_mcu.h
 create mode 100644 drivers/net/r8125/base/rtl8125b.c
 create mode 100644 drivers/net/r8125/base/rtl8125b_mcu.c
 create mode 100644 drivers/net/r8125/base/rtl8125b_mcu.h
 create mode 100644 drivers/net/r8125/base/rtl8125bp.c
 create mode 100644 drivers/net/r8125/base/rtl8125bp_mcu.c
 create mode 100644 drivers/net/r8125/base/rtl8125bp_mcu.h
 create mode 100644 drivers/net/r8125/base/rtl8125d.c
 create mode 100644 drivers/net/r8125/base/rtl8125d_mcu.c
 create mode 100644 drivers/net/r8125/base/rtl8125d_mcu.h
 create mode 100644 drivers/net/r8125/meson.build
 create mode 100644 drivers/net/r8125/r8125_base.h
 create mode 100644 drivers/net/r8125/r8125_dash.c
 create mode 100644 drivers/net/r8125/r8125_dash.h
 create mode 100644 drivers/net/r8125/r8125_ethdev.c
 create mode 100644 drivers/net/r8125/r8125_ethdev.h
 create mode 100644 drivers/net/r8125/r8125_hw.c
 create mode 100644 drivers/net/r8125/r8125_hw.h
 create mode 100644 drivers/net/r8125/r8125_logs.h
 create mode 100644 drivers/net/r8125/r8125_phy.c
 create mode 100644 drivers/net/r8125/r8125_phy.h
 create mode 100644 drivers/net/r8125/r8125_rxtx.c

--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -1076,6 +1076,11 @@ F: drivers/net/memif/
 F: doc/guides/nics/memif.rst
 F: doc/guides/nics/features/memif.ini
 
+Realtek r8125
+M: Realtek NIC SW <pro_nic_dpdk@realtek.com>
+F: drivers/net/r8125
+F: doc/guides/nics/r8125.rst
+F: doc/guides/nics/features/r8125.ini
 
 Crypto Drivers
 --------------
--- /dev/null
+++ b/doc/guides/nics/features/r8125.ini
@@ -0,0 +1,35 @@
+;
+; Supported features of the 'r8125' network poll mode driver.
+;
+; Refer to default.ini for the full list of available PMD features.
+;
+[Features]
+Speed capabilities   = Y
+Link speed configuration = Y
+Link status          = Y
+Link status event    = Y
+MTU update           = Y
+Scattered Rx         = Y
+TSO                  = Y
+Promiscuous mode     = Y
+Allmulticast mode    = Y
+Unicast MAC filter   = Y
+Multicast MAC filter = Y
+VLAN filter          = Y
+Flow control         = Y
+CRC offload          = Y
+VLAN offload         = Y
+L3 checksum offload  = Y
+L4 checksum offload  = Y
+Packet type parsing  = Y
+Rx descriptor status = Y
+Tx descriptor status = Y
+Basic stats          = Y
+Extended stats       = Y
+Stats per queue      = Y
+FW version           = Y
+EEPROM dump          = Y
+Registers dump       = Y
+Linux                = Y
+x86-32               = Y
+x86-64               = Y
--- /dev/null
+++ b/doc/guides/nics/r8125.rst
@@ -0,0 +1,18 @@
+..  SPDX-License-Identifier: BSD-3-Clause
+    Copyright(c) 2024 Realtek Corporation. All rights reserved
+
+R8125 Poll Mode Driver
+====================
+
+The R8125 PMD provides poll mode driver support for Realtek 2.5 Gigabit
+Ethernet NICs.
+
+Features
+--------
+
+Features of the R8125 PMD are:
+
+* MAC/VLAN filtering
+* Checksum offload
+* TCP segmentation offload
+* Jumbo frames supported
--- a/drivers/net/meson.build
+++ b/drivers/net/meson.build
@@ -53,6 +53,7 @@ drivers = [
         'pfe',
         'qede',
         'ring',
+        'r8125',
         'sfc',
         'softnic',
         'tap',
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125a.c
@@ -0,0 +1,416 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125a_mcu.h"
+
+/* For RTL8125A, CFG_METHOD_2,3 */
+
+static void
+hw_init_rxcfg_8125a(struct rtl8125_hw *hw)
+{
+	RTL_W32(hw, RxConfig, Rx_Fetch_Number_8 | (RX_DMA_BURST_256 <<
+	                RxCfgDMAShift));
+}
+
+static void
+hw_ephy_config_8125a(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		rtl8125_ephy_write(hw, 0x01, 0xA812);
+		rtl8125_ephy_write(hw, 0x09, 0x520C);
+		rtl8125_ephy_write(hw, 0x04, 0xD000);
+		rtl8125_ephy_write(hw, 0x0D, 0xF702);
+		rtl8125_ephy_write(hw, 0x0A, 0x8653);
+		rtl8125_ephy_write(hw, 0x06, 0x001E);
+		rtl8125_ephy_write(hw, 0x08, 0x3595);
+		rtl8125_ephy_write(hw, 0x20, 0x9455);
+		rtl8125_ephy_write(hw, 0x21, 0x99FF);
+		rtl8125_ephy_write(hw, 0x02, 0x6046);
+		rtl8125_ephy_write(hw, 0x29, 0xFE00);
+		rtl8125_ephy_write(hw, 0x23, 0xAB62);
+
+		rtl8125_ephy_write(hw, 0x41, 0xA80C);
+		rtl8125_ephy_write(hw, 0x49, 0x520C);
+		rtl8125_ephy_write(hw, 0x44, 0xD000);
+		rtl8125_ephy_write(hw, 0x4D, 0xF702);
+		rtl8125_ephy_write(hw, 0x4A, 0x8653);
+		rtl8125_ephy_write(hw, 0x46, 0x001E);
+		rtl8125_ephy_write(hw, 0x48, 0x3595);
+		rtl8125_ephy_write(hw, 0x60, 0x9455);
+		rtl8125_ephy_write(hw, 0x61, 0x99FF);
+		rtl8125_ephy_write(hw, 0x42, 0x6046);
+		rtl8125_ephy_write(hw, 0x69, 0xFE00);
+		rtl8125_ephy_write(hw, 0x63, 0xAB62);
+		break;
+	case CFG_METHOD_3:
+		rtl8125_ephy_write(hw, 0x04, 0xD000);
+		rtl8125_ephy_write(hw, 0x0A, 0x8653);
+		rtl8125_ephy_write(hw, 0x23, 0xAB66);
+		rtl8125_ephy_write(hw, 0x20, 0x9455);
+		rtl8125_ephy_write(hw, 0x21, 0x99FF);
+		rtl8125_ephy_write(hw, 0x29, 0xFE04);
+
+		rtl8125_ephy_write(hw, 0x44, 0xD000);
+		rtl8125_ephy_write(hw, 0x4A, 0x8653);
+		rtl8125_ephy_write(hw, 0x63, 0xAB66);
+		rtl8125_ephy_write(hw, 0x60, 0x9455);
+		rtl8125_ephy_write(hw, 0x61, 0x99FF);
+		rtl8125_ephy_write(hw, 0x69, 0xFE04);
+
+		rtl8125_clear_and_set_pcie_phy_bit(hw, 0x2A, (BIT_14 | BIT_13 | BIT_12),
+		                                   (BIT_13 | BIT_12));
+		rtl8125_clear_pcie_phy_bit(hw, 0x19, BIT_6);
+		rtl8125_set_pcie_phy_bit(hw, 0x1B, (BIT_11 | BIT_10 | BIT_9));
+		rtl8125_clear_pcie_phy_bit(hw, 0x1B, (BIT_14 | BIT_13 | BIT_12));
+		rtl8125_ephy_write(hw, 0x02, 0x6042);
+		rtl8125_ephy_write(hw, 0x06, 0x0014);
+
+		rtl8125_clear_and_set_pcie_phy_bit(hw, 0x6A, (BIT_14 | BIT_13 | BIT_12),
+		                                   (BIT_13 | BIT_12));
+		rtl8125_clear_pcie_phy_bit(hw, 0x59, BIT_6);
+		rtl8125_set_pcie_phy_bit(hw, 0x5B, (BIT_11 | BIT_10 | BIT_9));
+		rtl8125_clear_pcie_phy_bit(hw, 0x5B, (BIT_14 | BIT_13 | BIT_12));
+		rtl8125_ephy_write(hw, 0x42, 0x6042);
+		rtl8125_ephy_write(hw, 0x46, 0x0014);
+		break;
+	}
+}
+
+static void
+rtl8125_hw_phy_config_8125a_1(struct rtl8125_hw *hw)
+{
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD40, 0x03FF, 0x84);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xAD4E, BIT_4);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD16, 0x03FF, 0x0006);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD32, 0x003F, 0x0006);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC08, BIT_12);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC08, BIT_8);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAC8A,
+	                                      (BIT_15 | BIT_14 | BIT_13 | BIT_12), (BIT_14 | BIT_13 | BIT_12));
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xAD18, BIT_10);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xAD1A, 0x3FF);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xAD1C, 0x3FF);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80EA);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xC400);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80EB);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0x0700, 0x0300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80F8);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1C00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80F1);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x3000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80FE);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xA500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8102);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x5000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8105);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x3300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8100);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x7000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8104);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xF000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8106);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x6500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DC);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xED00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DF);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA438, BIT_8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80E1);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, BIT_8);
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF06, 0x003F, 0x38);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x819F);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xD0B6);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBC34, 0x5555);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF0A, (BIT_11 | BIT_10 | BIT_9),
+	                                      (BIT_11 | BIT_9));
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA5C0, BIT_10);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+}
+
+static void
+rtl8125_hw_phy_config_8125a_2(struct rtl8125_hw *hw)
+{
+	u16 adccal_offset_p0;
+	u16 adccal_offset_p1;
+	u16 adccal_offset_p2;
+	u16 adccal_offset_p3;
+	u16 rg_lpf_cap_xg_p0;
+	u16 rg_lpf_cap_xg_p1;
+	u16 rg_lpf_cap_xg_p2;
+	u16 rg_lpf_cap_xg_p3;
+	u16 rg_lpf_cap_p0;
+	u16 rg_lpf_cap_p1;
+	u16 rg_lpf_cap_p2;
+	u16 rg_lpf_cap_p3;
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xAD4E, BIT_4);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD16, 0x03FF, 0x03FF);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD32, 0x003F, 0x0006);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC08, BIT_12);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC08, BIT_8);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xACC0, (BIT_1 | BIT_0), BIT_1);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD40, (BIT_7 | BIT_6 | BIT_5),
+	                                      BIT_6);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD40, (BIT_2 | BIT_1 | BIT_0),
+	                                      BIT_2);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC14, BIT_7);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAC80, BIT_9 | BIT_8);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAC5E, (BIT_2 | BIT_1 | BIT_0),
+	                                      BIT_1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAD4C, 0x00A8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC5C, 0x01FF);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAC8A,
+	                                      (BIT_7 | BIT_6 | BIT_5 | BIT_4), (BIT_5 | BIT_4));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8157);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8159);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0700);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80A2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0153);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x809C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0153);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x81B3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0043);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00A7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00D6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00EC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00F6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00FB);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00FD);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00FF);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00BB);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0058);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0029);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0013);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0009);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0004);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8257);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x020F);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80EA);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7843);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB896, BIT_0);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB892, 0xFF00);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC091);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x6E12);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC092);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1214);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC094);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1516);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC096);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x171B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC098);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1B1C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC09A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1F1F);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC09C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x2021);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC09E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x2224);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC0A0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x2424);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC0A2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x2424);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC0A4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x2424);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC018);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0AF2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC01A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0D4A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC01C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0F26);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC01E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x118D);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC020);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x14F3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC022);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x175A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x19C0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC026);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1C26);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC089);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x6050);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC08A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x5F6E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC08C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x6E6E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC08E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x6E6E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC090);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x6E12);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xB896, BIT_0);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xD068, BIT_13);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x81A2);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA438, BIT_8);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB54C, 0xFF00, 0xDB00);
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA454, BIT_0);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA5D4, BIT_5);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAD4E, BIT_4);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA86A, BIT_0);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+	if (hw->RequirePhyMdiSwapPatch) {
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0007, 0x0001);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0000);
+		adccal_offset_p0 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xD06A);
+		adccal_offset_p0 &= 0x07FF;
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0008);
+		adccal_offset_p1 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xD06A);
+		adccal_offset_p1 &= 0x07FF;
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0010);
+		adccal_offset_p2 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xD06A);
+		adccal_offset_p2 &= 0x07FF;
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0018);
+		adccal_offset_p3 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xD06A);
+		adccal_offset_p3 &= 0x07FF;
+
+
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0000);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD06A, 0x07FF, adccal_offset_p3);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0008);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD06A, 0x07FF, adccal_offset_p2);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0010);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD06A, 0x07FF, adccal_offset_p1);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD068, 0x0018, 0x0018);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xD06A, 0x07FF, adccal_offset_p0);
+
+
+		rg_lpf_cap_xg_p0 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBD5A);
+		rg_lpf_cap_xg_p0 &= 0x001F;
+		rg_lpf_cap_xg_p1 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBD5A);
+		rg_lpf_cap_xg_p1 &= 0x1F00;
+		rg_lpf_cap_xg_p2 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBD5C);
+		rg_lpf_cap_xg_p2 &= 0x001F;
+		rg_lpf_cap_xg_p3 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBD5C);
+		rg_lpf_cap_xg_p3 &= 0x1F00;
+		rg_lpf_cap_p0 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBC18);
+		rg_lpf_cap_p0 &= 0x001F;
+		rg_lpf_cap_p1 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBC18);
+		rg_lpf_cap_p1 &= 0x1F00;
+		rg_lpf_cap_p2 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBC1A);
+		rg_lpf_cap_p2 &= 0x001F;
+		rg_lpf_cap_p3 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBC1A);
+		rg_lpf_cap_p3 &= 0x1F00;
+
+
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBD5A, 0x001F,
+		                                      rg_lpf_cap_xg_p3 >> 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBD5A, 0x1F00,
+		                                      rg_lpf_cap_xg_p2 << 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBD5C, 0x001F,
+		                                      rg_lpf_cap_xg_p1 >> 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBD5C, 0x1F00,
+		                                      rg_lpf_cap_xg_p0 << 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC18, 0x001F, rg_lpf_cap_p3 >> 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC18, 0x1F00, rg_lpf_cap_p2 << 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC1A, 0x001F, rg_lpf_cap_p1 >> 8);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC1A, 0x1F00, rg_lpf_cap_p0 << 8);
+	}
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA424, BIT_3);
+}
+
+static void
+hw_phy_config_8125a(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		rtl8125_hw_phy_config_8125a_1(hw);
+		break;
+	case CFG_METHOD_3:
+		rtl8125_hw_phy_config_8125a_2(hw);
+		break;
+	}
+}
+
+static void
+hw_mac_mcu_config_8125a(struct rtl8125_hw *hw)
+{
+	if (hw->NotWrMcuPatchCode == TRUE)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		rtl8125_set_mac_mcu_8125a_1(hw);
+		break;
+	case CFG_METHOD_3:
+		rtl8125_set_mac_mcu_8125a_2(hw);
+		break;
+	}
+}
+
+static void
+hw_phy_mcu_config_8125a(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		rtl8125_set_phy_mcu_8125a_1(hw);
+		break;
+	case CFG_METHOD_3:
+		rtl8125_set_phy_mcu_8125a_2(hw);
+		break;
+	}
+}
+
+
+const struct rtl8125_hw_ops rtl8125a_ops = {
+	.hw_init_rxcfg     = hw_init_rxcfg_8125a,
+	.hw_ephy_config    = hw_ephy_config_8125a,
+	.hw_phy_config     = hw_phy_config_8125a,
+	.hw_mac_mcu_config = hw_mac_mcu_config_8125a,
+	.hw_phy_mcu_config = hw_phy_mcu_config_8125a,
+};
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125a_mcu.c
@@ -0,0 +1,1602 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125a_mcu.h"
+
+/* For RTL8125A, CFG_METHOD_2,3 */
+
+/* ------------------------------------MAC 8125A------------------------------------- */
+
+void
+rtl8125_set_mac_mcu_8125a_1(struct rtl8125_hw *hw)
+{
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+}
+
+void
+rtl8125_set_mac_mcu_8125a_2(struct rtl8125_hw *hw)
+{
+	static const u16 mcu_patch_code_8125a_2[] = {
+		0xE010, 0xE012, 0xE022, 0xE024, 0xE029, 0xE02B, 0xE094, 0xE09D, 0xE09F,
+		0xE0AA, 0xE0B5, 0xE0C6, 0xE0CC, 0xE0D1, 0xE0D6, 0xE0D8, 0xC602, 0xBE00,
+		0x0000, 0xC60F, 0x73C4, 0x49B3, 0xF106, 0x73C2, 0xC608, 0xB406, 0xC609,
+		0xFF80, 0xC605, 0xB406, 0xC605, 0xFF80, 0x0544, 0x0568, 0xE906, 0xCDE8,
+		0xC602, 0xBE00, 0x0000, 0x48C1, 0x48C2, 0x9C46, 0xC402, 0xBC00, 0x0A12,
+		0xC602, 0xBE00, 0x0EBA, 0x1501, 0xF02A, 0x1500, 0xF15D, 0xC661, 0x75C8,
+		0x49D5, 0xF00A, 0x49D6, 0xF008, 0x49D7, 0xF006, 0x49D8, 0xF004, 0x75D2,
+		0x49D9, 0xF150, 0xC553, 0x77A0, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858,
+		0x48DA, 0x48DB, 0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8,
+		0x75D2, 0x4859, 0x9DD2, 0xC643, 0x75C0, 0x49D4, 0xF033, 0x49D0, 0xF137,
+		0xE030, 0xC63A, 0x75C8, 0x49D5, 0xF00E, 0x49D6, 0xF00C, 0x49D7, 0xF00A,
+		0x49D8, 0xF008, 0x75D2, 0x49D9, 0xF005, 0xC62E, 0x75C0, 0x49D7, 0xF125,
+		0xC528, 0x77A0, 0xC627, 0x75C8, 0x4855, 0x4856, 0x4857, 0x4858, 0x48DA,
+		0x48DB, 0x49FE, 0xF002, 0x485A, 0x49FF, 0xF002, 0x485B, 0x9DC8, 0x75D2,
+		0x4859, 0x9DD2, 0xC616, 0x75C0, 0x4857, 0x9DC0, 0xC613, 0x75C0, 0x49DA,
+		0xF003, 0x49D0, 0xF107, 0xC60B, 0xC50E, 0x48D9, 0x9DC0, 0x4859, 0x9DC0,
+		0xC608, 0xC702, 0xBF00, 0x3AE0, 0xE860, 0xB400, 0xB5D4, 0xE908, 0xE86C,
+		0x1200, 0xC409, 0x6780, 0x48F1, 0x8F80, 0xC404, 0xC602, 0xBE00, 0x10AA,
+		0xC010, 0xEA7C, 0xC602, 0xBE00, 0x0000, 0x740A, 0x4846, 0x4847, 0x9C0A,
+		0xC607, 0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13FE, 0xE054, 0x72CA,
+		0x4826, 0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0, 0xC602, 0xBE00,
+		0x07DC, 0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C, 0x74CA, 0x48C7,
+		0x9CCA, 0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00, 0x2480, 0xE092,
+		0xE0C0, 0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602, 0xBE00, 0x12F8,
+		0x1BFF, 0x46EB, 0x1BFF, 0xC102, 0xB900, 0x0D5A, 0x1BFF, 0x46EB, 0x1BFF,
+		0xC102, 0xB900, 0x0E2A, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6486,
+		0x0B15, 0x090E, 0x1139
+	};
+
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+
+	rtl8125_write_mac_mcu_ram_code(hw, mcu_patch_code_8125a_2,
+	                               ARRAY_SIZE(mcu_patch_code_8125a_2));
+
+	rtl8125_mac_ocp_write(hw, 0xFC26, 0x8000);
+
+	rtl8125_mac_ocp_write(hw, 0xFC2A, 0x0540);
+	rtl8125_mac_ocp_write(hw, 0xFC2E, 0x0A06);
+	rtl8125_mac_ocp_write(hw, 0xFC30, 0x0EB8);
+	rtl8125_mac_ocp_write(hw, 0xFC32, 0x3A5C);
+	rtl8125_mac_ocp_write(hw, 0xFC34, 0x10A8);
+	rtl8125_mac_ocp_write(hw, 0xFC40, 0x0D54);
+	rtl8125_mac_ocp_write(hw, 0xFC42, 0x0E24);
+
+	rtl8125_mac_ocp_write(hw, 0xFC48, 0x307A);
+}
+
+/* ------------------------------------PHY 8125A--------------------------------------- */
+
+static void
+rtl8125_acquire_phy_mcu_patch_key_lock(struct rtl8125_hw *hw)
+{
+	u16 patch_key;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		patch_key = 0x8600;
+		break;
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		patch_key = 0x8601;
+		break;
+	case CFG_METHOD_4:
+		patch_key = 0x3700;
+		break;
+	case CFG_METHOD_5:
+	case CFG_METHOD_7:
+		patch_key = 0x3701;
+		break;
+	default:
+		return;
+	}
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, patch_key);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xB82E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0001);
+}
+
+static void
+rtl8125_release_phy_mcu_patch_key_lock(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+	case CFG_METHOD_6:
+	case CFG_METHOD_7:
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x0000);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xB82E, BIT_0);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8024);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+		break;
+	default:
+		break;
+	}
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_1(struct rtl8125_hw *hw)
+{
+	rtl8125_acquire_phy_mcu_patch_key_lock(hw);
+
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xB820, BIT_7);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8013);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8021);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x802f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x803d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8042);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8051);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8051);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa088);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a50);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8008);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1a3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x401a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd707);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40c2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60a6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f8b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a6c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8080);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd019);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1a2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x401a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd707);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40c4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60a6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f8b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a84);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8970);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c07);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0901);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcf09);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd705);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xceff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf0a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1213);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8401);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8580);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1253);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd064);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd181);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4018);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc50f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd706);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2c59);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x804d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc60f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc605);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x10fd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA026);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA022);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x10f4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA020);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1252);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA006);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1206);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA004);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a78);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a60);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a4f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA008);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3f00);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8066);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x807c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8089);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x808e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80b2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80c2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x62db);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x655c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd73e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x614a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0505);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0509);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x653c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd73e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x614a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0502);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0506);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x050a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd73e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x614a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0505);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0506);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x050c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd73e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x614a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0509);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x050a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x050c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0508);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0304);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd73e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x614a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0321);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0502);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0321);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0321);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0508);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0321);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0346);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8208);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x609d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa50f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x001a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x001a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x607d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00ab);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60fd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa50f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaa0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x017b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a05);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x017b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60fd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa50f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaa0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x01e0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a05);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x01e0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60fd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa50f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaa0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0231);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0503);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a05);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0231);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0221);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x01ce);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA088);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0169);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA086);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00a6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA084);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x000d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA082);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0308);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA080);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x029f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA090);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x007f);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0020);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8017);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8029);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8054);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x805a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8064);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80a7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9430);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9480);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb408);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd120);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd057);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x064b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb80);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9906);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0567);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb94);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x82a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x800a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8406);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8dff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0773);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb91);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4063);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd139);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd140);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07dc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa110);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa2a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4045);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa180);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x405d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa720);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0742);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07ec);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f74);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0742);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7fb6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x82a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07dc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x064b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07c0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5fa7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0481);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x94bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x870c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa00a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa280);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8220);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x078e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb92);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4063);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd140);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd150);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd703);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6121);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x61a2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6223);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf02f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d10);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf00f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d20);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf00a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d30);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf005);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d40);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa008);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4046);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x405d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa720);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0742);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07f7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f74);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0742);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7fb5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x800a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3ad4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0537);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x064b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8301);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x800a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x82a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa70c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9402);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x890c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x064b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0642);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0686);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0788);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA108);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x047b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA106);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x065c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA104);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0769);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA102);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0565);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x06f9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA110);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00ff);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb87c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8530);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb87e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf85);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3caf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8593);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf85);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9caf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x85a5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5afb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe083);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfb0c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x020d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x021b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x10bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86d7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbe0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x83fc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1b10);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xda02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xdd02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5afb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe083);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfd0c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x020d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x021b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x10bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86dd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86e0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbe0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x83fe);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1b10);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf2f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbd02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2cac);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0286);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x65af);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x212b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x022c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86b6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf21);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cd1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x03bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8710);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x870d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8719);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8716);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x871f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x871c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8728);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8725);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8707);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbad);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x281c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1302);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2202);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2b02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae1a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd101);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1302);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2202);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2b02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd101);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3402);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3102);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3d02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3a02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4302);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4c02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4902);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2e02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4602);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf87);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4f02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ab7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf35);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7ff8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfaef);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x69bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86e3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86fb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86e6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86fe);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86e9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86ec);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfbbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x025a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7bf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86ef);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0262);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7cbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86f2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0262);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7cbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86f5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0262);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7cbf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x86f8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0262);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7cef);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x96fe);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfc04);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf8fa);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xef69);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xef02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6273);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf202);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6273);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf502);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6273);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbf86);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf802);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6273);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xef96);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfefc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0420);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb540);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x53b5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4086);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb540);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb9b5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40c8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb03a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc8b0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbac8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb13a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc8b1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xba77);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbd26);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffbd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2677);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbd28);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffbd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbd26);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc8bd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2640);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbd28);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc8bd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x28bb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa430);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x98b0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1eba);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb01e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xdcb0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e98);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb09e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbab0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9edc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb09e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x98b1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1eba);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb11e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xdcb1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e98);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb19e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbab1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9edc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb19e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x11b0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e22);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb01e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x33b0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e11);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb09e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x22b0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9e33);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb09e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x11b1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e22);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb11e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x33b1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1e11);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb19e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x22b1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9e33);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb19e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb85e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2f71);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb860);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x20d9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb862);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2109);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb864);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x34e7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb878);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x000f);
+
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB820, BIT_7);
+
+
+	rtl8125_release_phy_mcu_patch_key_lock(hw);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125a_2(struct rtl8125_hw *hw)
+{
+	rtl8125_acquire_phy_mcu_patch_key_lock(hw);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xB820, BIT_7);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x808b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x808f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8093);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8097);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x809d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80a1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80aa);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x607b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf00e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x42da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf01e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x615b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1456);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14a4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f2e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf01c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1456);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14a4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f2e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1456);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14a4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f2e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf02c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1456);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14a4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x14bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f2e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf034);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd719);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4118);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac11);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa410);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4779);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1444);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf034);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd719);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4118);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac22);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa420);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4559);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1444);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf023);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd719);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4118);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac44);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa440);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4339);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1444);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd719);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4118);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac88);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa480);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xce00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4119);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xac0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1444);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf001);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1456);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd718);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5fac);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc48f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x141b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd504);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x121a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd0b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1bb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0898);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd0b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1bb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a0e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd064);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd18a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0b7e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x401c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd501);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa804);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8804);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x053b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa301);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0648);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc520);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa201);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x252d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1646);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd708);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4006);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1646);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0308);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA026);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0307);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1645);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA022);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0647);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA020);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x053a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA006);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0b7c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA004);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0a0c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0896);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x11a1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA008);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xff00);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8015);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x801a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xad02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x02d7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00ed);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0509);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xc100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x008f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA08A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA088);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA086);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA084);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA082);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x008d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA080);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00eb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA090);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0103);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA016);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0020);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8014);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8018);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8024);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8051);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8055);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8072);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x80dc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfffd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfffd);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8301);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x800a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x82a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa70c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x9402);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x890c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8840);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa380);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x066e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb91);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4063);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd139);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd140);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa110);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa2a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4085);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa180);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8280);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x405d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa720);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0743);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07f0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5f74);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0743);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7fb6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x82a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0c0f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x066e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd158);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd04d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x03d4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x94bc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x870c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8380);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd10d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07c4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5fb4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa190);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa00a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa280);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa404);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa220);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd130);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07c4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5fb4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xbb80);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1c4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd074);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa301);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x604b);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa90c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0556);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xcb92);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4063);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd116);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd119);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd040);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd703);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x60a0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6241);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x63e2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6583);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf054);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x611e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d10);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf02f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d50);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf02a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x611e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d20);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf021);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d60);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf01c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x611e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d30);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf013);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d70);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf00e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x611e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x40da);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d40);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf005);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d80);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x405d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa720);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5ff4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa008);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd704);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4046);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0743);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07fb);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd703);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7f6f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7f4e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7f2d);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7f0c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x800a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0cf0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0d00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07e8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8010);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa740);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0743);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7fb5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd701);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3ad4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0556);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8610);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x066e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd1f5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xd049);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x1800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x01ec);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x01ea);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x06a9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA10A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x078a);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA108);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x03d2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA106);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x067f);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA104);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0665);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA102);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xA110);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00fc);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb87c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8530);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb87e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf85);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x3caf);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8545);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf85);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x45af);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8545);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xee82);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf900);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0103);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xaf03);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb7f8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe0a6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00e1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa601);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xef01);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x58f0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa080);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x37a1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8402);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae16);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa185);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x02ae);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x11a1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8702);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae0c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xa188);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x02ae);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x07a1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8902);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae02);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xae1c);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe0b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x62e1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb463);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6901);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe4b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x62e5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb463);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe0b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x62e1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb463);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6901);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xe4b4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x62e5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xb463);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xfc04);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb85e);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x03b3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb860);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb862);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb864);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xffff);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0xb878);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0001);
+
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB820, BIT_7);
+
+
+	rtl8125_release_phy_mcu_patch_key_lock(hw);
+}
+
+void
+rtl8125_set_phy_mcu_8125a_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125a_1(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
+
+void
+rtl8125_set_phy_mcu_8125a_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125a_2(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125a_mcu.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _RTL8125A_MCU_H_
+#define _RTL8125A_MCU_H_
+
+void rtl8125_set_mac_mcu_8125a_1(struct rtl8125_hw *hw);
+void rtl8125_set_mac_mcu_8125a_2(struct rtl8125_hw *hw);
+
+void rtl8125_set_phy_mcu_8125a_1(struct rtl8125_hw *hw);
+void rtl8125_set_phy_mcu_8125a_2(struct rtl8125_hw *hw);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125b.c
@@ -0,0 +1,398 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125b_mcu.h"
+
+/* For RTL8125B, CFG_METHOD_4,5 */
+
+static void
+hw_init_rxcfg_8125b(struct rtl8125_hw *hw)
+{
+	RTL_W32(hw, RxConfig, Rx_Fetch_Number_8 | RxCfg_pause_slot_en |
+	        (RX_DMA_BURST_256 << RxCfgDMAShift));
+}
+
+static void
+hw_ephy_config_8125b(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+		rtl8125_ephy_write(hw, 0x06, 0x001F);
+		rtl8125_ephy_write(hw, 0x0A, 0xB66B);
+		rtl8125_ephy_write(hw, 0x01, 0xA852);
+		rtl8125_ephy_write(hw, 0x24, 0x0008);
+		rtl8125_ephy_write(hw, 0x2F, 0x6052);
+		rtl8125_ephy_write(hw, 0x0D, 0xF716);
+		rtl8125_ephy_write(hw, 0x20, 0xD477);
+		rtl8125_ephy_write(hw, 0x21, 0x4477);
+		rtl8125_ephy_write(hw, 0x22, 0x0013);
+		rtl8125_ephy_write(hw, 0x23, 0xBB66);
+		rtl8125_ephy_write(hw, 0x0B, 0xA909);
+		rtl8125_ephy_write(hw, 0x29, 0xFF04);
+		rtl8125_ephy_write(hw, 0x1B, 0x1EA0);
+
+		rtl8125_ephy_write(hw, 0x46, 0x001F);
+		rtl8125_ephy_write(hw, 0x4A, 0xB66B);
+		rtl8125_ephy_write(hw, 0x41, 0xA84A);
+		rtl8125_ephy_write(hw, 0x64, 0x000C);
+		rtl8125_ephy_write(hw, 0x6F, 0x604A);
+		rtl8125_ephy_write(hw, 0x4D, 0xF716);
+		rtl8125_ephy_write(hw, 0x60, 0xD477);
+		rtl8125_ephy_write(hw, 0x61, 0x4477);
+		rtl8125_ephy_write(hw, 0x62, 0x0013);
+		rtl8125_ephy_write(hw, 0x63, 0xBB66);
+		rtl8125_ephy_write(hw, 0x4B, 0xA909);
+		rtl8125_ephy_write(hw, 0x69, 0xFF04);
+		rtl8125_ephy_write(hw, 0x5B, 0x1EA0);
+		break;
+	case CFG_METHOD_5:
+		rtl8125_ephy_write(hw, 0x0B, 0xA908);
+		rtl8125_ephy_write(hw, 0x1E, 0x20EB);
+		rtl8125_ephy_write(hw, 0x22, 0x0023);
+		rtl8125_ephy_write(hw, 0x02, 0x60C2);
+		rtl8125_ephy_write(hw, 0x29, 0xFF00);
+
+		rtl8125_ephy_write(hw, 0x4B, 0xA908);
+		rtl8125_ephy_write(hw, 0x5E, 0x28EB);
+		rtl8125_ephy_write(hw, 0x62, 0x0023);
+		rtl8125_ephy_write(hw, 0x42, 0x60C2);
+		rtl8125_ephy_write(hw, 0x69, 0xFF00);
+		break;
+	}
+}
+
+static void
+rtl8125_hw_phy_config_8125b_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBC08, (BIT_3 | BIT_2));
+
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FFF);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x0400);
+	}
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8560);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x19CC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8562);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x19CC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8564);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x19CC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8566);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x147D);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8568);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x147D);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x856A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x147D);
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FFE);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0907);
+	}
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xACDA, 0xFF00, 0xFF00);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xACDE, 0xF000, 0xF000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80D6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x2801);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80F2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x2801);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80F4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x6077);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB506, 0x01E7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC8C, 0x0FFC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC46, 0xB7B4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC50, 0x0FBC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC3C, 0x9240);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC4E, 0x0DB4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xACC6, 0x0707);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xACC8, 0xA0D3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAD08, 0x0007);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8013);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0700);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FB9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x2801);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FBA);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FBC);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x1900);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FBE);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xE100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FC0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0800);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FC2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xE500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FC4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0F00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FC6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xF100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FC8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0400);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FCa);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xF300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FCc);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xFD00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FCe);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xFF00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FD0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xFB00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FD2);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FD4);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xF400);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FD6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xFF00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8FD8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xF600);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x813D);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x390E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x814F);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x790E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80B0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0F31);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBF4C, BIT_1);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBCCA, (BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8141);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x320E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8153);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x720E);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA432, BIT_6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8529);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x050E);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x816C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xC4A0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8170);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xC4A0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8174);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x04A0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8178);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x04A0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x817C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0719);
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF4);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0400);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF1);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0404);
+	}
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBF4A, 0x001B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8033);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x7C13);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8037);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x7C13);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x803B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0xFC32);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x803F);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x7C13);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8043);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x7C13);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8047);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x7C13);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8145);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x370E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8157);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x770E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8169);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x0D0A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x817B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x1D0A);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8217);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x5000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x821A);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x5000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DA);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0403);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DC);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80B3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0384);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80B7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2007);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80BA);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x6C00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80B5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xF009);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80BD);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x9F00);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80C7);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xf083);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DD);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x03f0);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DF);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80CB);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x2007);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80CE);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x6C00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80C9);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8009);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80D1);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x8000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x200A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xF0AD);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x809F);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x6073);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x000B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A9);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xC000);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB896, BIT_0);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB892, 0xFF00);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC23E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC240);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0103);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC242);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0507);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC244);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x090B);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC246);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x0C0E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC248);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1012);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB88E, 0xC24A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB890, 0x1416);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xB896, BIT_0);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA86A, BIT_0);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA6F0, BIT_0);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBFA0, 0xD70D);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBFA2, 0x4100);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBFA4, 0xE868);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBFA6, 0xDC59);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB54C, 0x3C18);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xBFA4, BIT_5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x817D);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA438, BIT_12);
+}
+
+static void
+rtl8125_hw_phy_config_8125b_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAC46, 0x00F0, 0x0090);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD30, 0x0003, 0x0001);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80F5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x760E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8107);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87E, 0x360E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8551);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E,
+	                                      BIT_15 | BIT_14 | BIT_13 | BIT_12 | BIT_11 | BIT_10 | BIT_9 | BIT_8,
+	                                      BIT_11);
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xbf00, 0xE000, 0xA000);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xbf46, 0x0F00, 0x0300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8044);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x804A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8050);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8056);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x805C);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8062);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8068);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x806E);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x8074);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa436, 0x807A);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xa438, 0x2417);
+
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA4CA, BIT_6);
+
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF84, (BIT_15 | BIT_14 | BIT_13),
+	                                      (BIT_15 | BIT_13));
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8170);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438,
+	                                      (BIT_13 | BIT_10 | BIT_9 | BIT_8),
+	                                      (BIT_15 | BIT_14 | BIT_12 | BIT_11));
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA424, BIT_3);
+}
+
+static void
+hw_phy_config_8125b(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+		rtl8125_hw_phy_config_8125b_1(hw);
+		break;
+	case CFG_METHOD_5:
+		rtl8125_hw_phy_config_8125b_2(hw);
+		break;
+	}
+}
+
+static void
+hw_mac_mcu_config_8125b(struct rtl8125_hw *hw)
+{
+	if (hw->NotWrMcuPatchCode == TRUE)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+		rtl8125_set_mac_mcu_8125b_1(hw);
+		break;
+	case CFG_METHOD_5:
+		rtl8125_set_mac_mcu_8125b_2(hw);
+		break;
+	}
+}
+
+static void
+hw_phy_mcu_config_8125b(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+		rtl8125_set_phy_mcu_8125b_1(hw);
+		break;
+	case CFG_METHOD_5:
+		rtl8125_set_phy_mcu_8125b_2(hw);
+		break;
+	}
+}
+
+const struct rtl8125_hw_ops rtl8125b_ops = {
+	.hw_init_rxcfg     = hw_init_rxcfg_8125b,
+	.hw_ephy_config    = hw_ephy_config_8125b,
+	.hw_phy_config     = hw_phy_config_8125b,
+	.hw_mac_mcu_config = hw_mac_mcu_config_8125b,
+	.hw_phy_mcu_config = hw_phy_mcu_config_8125b,
+};
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125b_mcu.c
@@ -0,0 +1,1067 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125b_mcu.h"
+
+/* For RTL8125B, CFG_METHOD_4,5 */
+
+/* ------------------------------------MAC 8125B------------------------------------- */
+
+void
+rtl8125_set_mac_mcu_8125b_1(struct rtl8125_hw *hw)
+{
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+}
+
+void
+rtl8125_set_mac_mcu_8125b_2(struct rtl8125_hw *hw)
+{
+	static const u16 mcu_patch_code_8125b_2[] = {
+		0xE010, 0xE01B, 0xE026, 0xE037, 0xE03D, 0xE057, 0xE05B, 0xE060, 0xE062,
+		0xE064, 0xE066, 0xE068, 0xE06A, 0xE06C, 0xE06E, 0xE070, 0x740A, 0x4846,
+		0x4847, 0x9C0A, 0xC607, 0x74C0, 0x48C6, 0x9CC0, 0xC602, 0xBE00, 0x13F0,
+		0xE054, 0x72CA, 0x4826, 0x4827, 0x9ACA, 0xC607, 0x72C0, 0x48A6, 0x9AC0,
+		0xC602, 0xBE00, 0x081C, 0xE054, 0xC60F, 0x74C4, 0x49CC, 0xF109, 0xC60C,
+		0x74CA, 0x48C7, 0x9CCA, 0xC609, 0x74C0, 0x4846, 0x9CC0, 0xC602, 0xBE00,
+		0x2494, 0xE092, 0xE0C0, 0xE054, 0x7420, 0x48C0, 0x9C20, 0x7444, 0xC602,
+		0xBE00, 0x12DC, 0x733A, 0x21B5, 0x25BC, 0x1304, 0xF111, 0x1B12, 0x1D2A,
+		0x3168, 0x3ADA, 0x31AB, 0x1A00, 0x9AC0, 0x1300, 0xF1FB, 0x7620, 0x236E,
+		0x276F, 0x1A3C, 0x22A1, 0x41B5, 0x9EE2, 0x76E4, 0x486F, 0x9EE4, 0xC602,
+		0xBE00, 0x4A26, 0x733A, 0x49BB, 0xC602, 0xBE00, 0x47A2, 0x48C1, 0x48C2,
+		0x9C46, 0xC402, 0xBC00, 0x0A52, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+		0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+		0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00,
+		0x0000, 0xC602, 0xBE00, 0x0000
+	};
+
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+
+	rtl8125_write_mac_mcu_ram_code(hw, mcu_patch_code_8125b_2,
+	                               ARRAY_SIZE(mcu_patch_code_8125b_2));
+
+	rtl8125_mac_ocp_write(hw, 0xFC26, 0x8000);
+
+	rtl8125_mac_ocp_write(hw, 0xFC28, 0x13E6);
+	rtl8125_mac_ocp_write(hw, 0xFC2A, 0x0812);
+	rtl8125_mac_ocp_write(hw, 0xFC2C, 0x248C);
+	rtl8125_mac_ocp_write(hw, 0xFC2E, 0x12DA);
+	rtl8125_mac_ocp_write(hw, 0xFC30, 0x4A20);
+	rtl8125_mac_ocp_write(hw, 0xFC32, 0x47A0);
+
+	rtl8125_mac_ocp_write(hw, 0xFC48, 0x003F);
+}
+
+/* ------------------------------------PHY 8125B--------------------------------------- */
+
+static const u16 phy_mcu_ram_code_8125b_1[] = {
+	0xa436, 0x8024, 0xa438, 0x3700, 0xa436, 0xB82E, 0xa438, 0x0001,
+	0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x8025, 0xa438, 0x1800, 0xa438, 0x803a,
+	0xa438, 0x1800, 0xa438, 0x8044, 0xa438, 0x1800, 0xa438, 0x8083,
+	0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0x1800, 0xa438, 0x808d,
+	0xa438, 0x1800, 0xa438, 0x808d, 0xa438, 0xd712, 0xa438, 0x4077,
+	0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e, 0xa438, 0x6099,
+	0xa438, 0x7f44, 0xa438, 0x1800, 0xa438, 0x1a14, 0xa438, 0x9040,
+	0xa438, 0x9201, 0xa438, 0x1800, 0xa438, 0x1b1a, 0xa438, 0xd71e,
+	0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f, 0xa438, 0x3ce5,
+	0xa438, 0x1afb, 0xa438, 0x1800, 0xa438, 0x1b00, 0xa438, 0xd712,
+	0xa438, 0x4077, 0xa438, 0xd71e, 0xa438, 0x4159, 0xa438, 0xd71e,
+	0xa438, 0x60b9, 0xa438, 0x2421, 0xa438, 0x1c17, 0xa438, 0x1800,
+	0xa438, 0x1a14, 0xa438, 0x9040, 0xa438, 0x1800, 0xa438, 0x1c2c,
+	0xa438, 0xd71e, 0xa438, 0x2425, 0xa438, 0x1a14, 0xa438, 0xd71f,
+	0xa438, 0x3ce5, 0xa438, 0x1c0f, 0xa438, 0x1800, 0xa438, 0x1c13,
+	0xa438, 0xd702, 0xa438, 0xd501, 0xa438, 0x6072, 0xa438, 0x8401,
+	0xa438, 0xf002, 0xa438, 0xa401, 0xa438, 0x1000, 0xa438, 0x146e,
+	0xa438, 0x1800, 0xa438, 0x0b77, 0xa438, 0xd703, 0xa438, 0x665d,
+	0xa438, 0x653e, 0xa438, 0x641f, 0xa438, 0xd700, 0xa438, 0x62c4,
+	0xa438, 0x6185, 0xa438, 0x6066, 0xa438, 0x1800, 0xa438, 0x165a,
+	0xa438, 0xc101, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+	0xa438, 0xd700, 0xa438, 0x7fa6, 0xa438, 0x1800, 0xa438, 0x807d,
+	0xa438, 0xc102, 0xa438, 0xcb00, 0xa438, 0x1000, 0xa438, 0x1945,
+	0xa438, 0xd700, 0xa438, 0x2569, 0xa438, 0x8058, 0xa438, 0x1800,
+	0xa438, 0x807d, 0xa438, 0xc104, 0xa438, 0xcb00, 0xa438, 0x1000,
+	0xa438, 0x1945, 0xa438, 0xd700, 0xa438, 0x7fa4, 0xa438, 0x1800,
+	0xa438, 0x807d, 0xa438, 0xc120, 0xa438, 0xcb00, 0xa438, 0x1000,
+	0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbf, 0xa438, 0x1800,
+	0xa438, 0x807d, 0xa438, 0xc140, 0xa438, 0xcb00, 0xa438, 0x1000,
+	0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbe, 0xa438, 0x1800,
+	0xa438, 0x807d, 0xa438, 0xc180, 0xa438, 0xcb00, 0xa438, 0x1000,
+	0xa438, 0x1945, 0xa438, 0xd703, 0xa438, 0x7fbd, 0xa438, 0xc100,
+	0xa438, 0xcb00, 0xa438, 0xd708, 0xa438, 0x6018, 0xa438, 0x1800,
+	0xa438, 0x165a, 0xa438, 0x1000, 0xa438, 0x14f6, 0xa438, 0xd014,
+	0xa438, 0xd1e3, 0xa438, 0x1000, 0xa438, 0x1356, 0xa438, 0xd705,
+	0xa438, 0x5fbe, 0xa438, 0x1800, 0xa438, 0x1559, 0xa436, 0xA026,
+	0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022,
+	0xa438, 0xffff, 0xa436, 0xA020, 0xa438, 0x1557, 0xa436, 0xA006,
+	0xa438, 0x1677, 0xa436, 0xA004, 0xa438, 0x0b75, 0xa436, 0xA002,
+	0xa438, 0x1c17, 0xa436, 0xA000, 0xa438, 0x1b04, 0xa436, 0xA008,
+	0xa438, 0x1f00, 0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x817f, 0xa438, 0x1800, 0xa438, 0x82ab,
+	0xa438, 0x1800, 0xa438, 0x83f8, 0xa438, 0x1800, 0xa438, 0x8444,
+	0xa438, 0x1800, 0xa438, 0x8454, 0xa438, 0x1800, 0xa438, 0x8459,
+	0xa438, 0x1800, 0xa438, 0x8465, 0xa438, 0xcb11, 0xa438, 0xa50c,
+	0xa438, 0x8310, 0xa438, 0xd701, 0xa438, 0x4076, 0xa438, 0x0c03,
+	0xa438, 0x0903, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+	0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+	0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x1000, 0xa438, 0x0a4d,
+	0xa438, 0xcb12, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5f84, 0xa438, 0xd102, 0xa438, 0xd040, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd701,
+	0xa438, 0x60f3, 0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37,
+	0xa438, 0xd410, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb13,
+	0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+	0xa438, 0xa00a, 0xa438, 0xa910, 0xa438, 0xa780, 0xa438, 0xd14a,
+	0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+	0xa438, 0x6255, 0xa438, 0xd700, 0xa438, 0x5f74, 0xa438, 0x6326,
+	0xa438, 0xd702, 0xa438, 0x5f07, 0xa438, 0x800a, 0xa438, 0xa004,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+	0xa438, 0x0902, 0xa438, 0xffe2, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x5fab, 0xa438, 0xba08, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8b, 0xa438, 0x9a08,
+	0xa438, 0x800a, 0xa438, 0xd702, 0xa438, 0x6535, 0xa438, 0xd40d,
+	0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb14, 0xa438, 0xa004,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa00a,
+	0xa438, 0xa780, 0xa438, 0xd14a, 0xa438, 0xd048, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x6206,
+	0xa438, 0xd702, 0xa438, 0x5f47, 0xa438, 0x800a, 0xa438, 0xa004,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+	0xa438, 0x0902, 0xa438, 0x1800, 0xa438, 0x8064, 0xa438, 0x800a,
+	0xa438, 0xd40e, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+	0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x7f8c, 0xa438, 0xd701, 0xa438, 0x6073, 0xa438, 0xd701,
+	0xa438, 0x4216, 0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42,
+	0xa438, 0x8004, 0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42,
+	0xa438, 0x8001, 0xa438, 0xd120, 0xa438, 0xd040, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x8504,
+	0xa438, 0xcb21, 0xa438, 0xa301, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301, 0xa438, 0xd704,
+	0xa438, 0x40e0, 0xa438, 0xd196, 0xa438, 0xd04d, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb22,
+	0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+	0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8910, 0xa438, 0x8720,
+	0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01,
+	0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000,
+	0xa438, 0x0a7d, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb23,
+	0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+	0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+	0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+	0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+	0xa438, 0x5dee, 0xa438, 0xcb24, 0xa438, 0x8f1f, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f6e, 0xa438, 0xa111,
+	0xa438, 0xa215, 0xa438, 0xa401, 0xa438, 0x8404, 0xa438, 0xa720,
+	0xa438, 0xcb25, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640,
+	0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+	0xa438, 0x0b86, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+	0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x7f8c, 0xa438, 0xcb26, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x8205,
+	0xa438, 0x8404, 0xa438, 0xcb27, 0xa438, 0xd404, 0xa438, 0x1000,
+	0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+	0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+	0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0xa104,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8104, 0xa438, 0xa001,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0xa120,
+	0xa438, 0xaa0f, 0xa438, 0x8110, 0xa438, 0xa284, 0xa438, 0xa404,
+	0xa438, 0xa00a, 0xa438, 0xd193, 0xa438, 0xd046, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb28,
+	0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fa8, 0xa438, 0x8110, 0xa438, 0x8284, 0xa438, 0xa404,
+	0xa438, 0x800a, 0xa438, 0x8710, 0xa438, 0xb804, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804,
+	0xa438, 0xcb29, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820,
+	0xa438, 0xcb2a, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa404,
+	0xa438, 0xa00a, 0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8149,
+	0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8151,
+	0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+	0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+	0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+	0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8404,
+	0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+	0xa438, 0x0433, 0xa438, 0xcb15, 0xa438, 0xa508, 0xa438, 0xd700,
+	0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003,
+	0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d,
+	0xa438, 0x1000, 0xa438, 0x0a4d, 0xa438, 0xa301, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f9f, 0xa438, 0x8301,
+	0xa438, 0xd704, 0xa438, 0x40e0, 0xa438, 0xd115, 0xa438, 0xd04f,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+	0xa438, 0xd413, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xcb16,
+	0xa438, 0x1000, 0xa438, 0x0a6d, 0xa438, 0x0c03, 0xa438, 0x1502,
+	0xa438, 0xa640, 0xa438, 0x9503, 0xa438, 0x8720, 0xa438, 0xd17a,
+	0xa438, 0xd04c, 0xa438, 0x0c1f, 0xa438, 0x0f14, 0xa438, 0xcb17,
+	0xa438, 0x8fc0, 0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xaf40,
+	0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0x0cc0, 0xa438, 0x0f80,
+	0xa438, 0x1000, 0xa438, 0x0a25, 0xa438, 0xafc0, 0xa438, 0x1000,
+	0xa438, 0x0a25, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd701,
+	0xa438, 0x61ce, 0xa438, 0xd700, 0xa438, 0x5db4, 0xa438, 0xcb18,
+	0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+	0xa438, 0xa720, 0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xffd6, 0xa438, 0x8f1f, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x7f8e, 0xa438, 0xa131,
+	0xa438, 0xaa0f, 0xa438, 0xa2d5, 0xa438, 0xa407, 0xa438, 0xa720,
+	0xa438, 0x8310, 0xa438, 0xa308, 0xa438, 0x8308, 0xa438, 0xcb19,
+	0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8640, 0xa438, 0x9503,
+	0xa438, 0x1000, 0xa438, 0x0b43, 0xa438, 0x1000, 0xa438, 0x0b86,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xb920, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+	0xa438, 0xcb1a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5f82, 0xa438, 0x8111, 0xa438, 0x82c5, 0xa438, 0xa404,
+	0xa438, 0x8402, 0xa438, 0xb804, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x7f82, 0xa438, 0x9804, 0xa438, 0xcb1b,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f85,
+	0xa438, 0xa710, 0xa438, 0xb820, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x7f65, 0xa438, 0x9820, 0xa438, 0xcb1c,
+	0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+	0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+	0xa438, 0x0a7d, 0xa438, 0xa110, 0xa438, 0xa284, 0xa438, 0xa404,
+	0xa438, 0x8402, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fa8, 0xa438, 0xcb1d, 0xa438, 0xa180, 0xa438, 0xa402,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+	0xa438, 0xa220, 0xa438, 0xd1f5, 0xa438, 0xd049, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x8221,
+	0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xb920, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fa3,
+	0xa438, 0xa504, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+	0xa438, 0x0d00, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+	0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa00a, 0xa438, 0x8190,
+	0xa438, 0x82a4, 0xa438, 0x8402, 0xa438, 0xa404, 0xa438, 0xb808,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7fa3,
+	0xa438, 0x9808, 0xa438, 0xcb2b, 0xa438, 0xcb2c, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f84, 0xa438, 0xd14a,
+	0xa438, 0xd048, 0xa438, 0xa780, 0xa438, 0xcb2d, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5f94, 0xa438, 0x6208,
+	0xa438, 0xd702, 0xa438, 0x5f27, 0xa438, 0x800a, 0xa438, 0xa004,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004, 0xa438, 0xa001,
+	0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001, 0xa438, 0x0c03,
+	0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xffe9, 0xa438, 0xcb2e,
+	0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+	0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02, 0xa438, 0x1000,
+	0xa438, 0x0a7d, 0xa438, 0xa190, 0xa438, 0xa284, 0xa438, 0xa406,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa8,
+	0xa438, 0xa220, 0xa438, 0xd1a0, 0xa438, 0xd040, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x3444, 0xa438, 0x827d,
+	0xa438, 0xd702, 0xa438, 0x5f51, 0xa438, 0xcb2f, 0xa438, 0xa302,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd708, 0xa438, 0x5f63,
+	0xa438, 0xd411, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8302,
+	0xa438, 0xd409, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0xb920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+	0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x7f8c, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5fa3, 0xa438, 0x8190, 0xa438, 0x82a4, 0xa438, 0x8406,
+	0xa438, 0x800a, 0xa438, 0xb808, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x7fa3, 0xa438, 0x9808, 0xa438, 0x1800,
+	0xa438, 0x0433, 0xa438, 0xcb30, 0xa438, 0x8380, 0xa438, 0xcb31,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5f86,
+	0xa438, 0x9308, 0xa438, 0xb204, 0xa438, 0xb301, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd701, 0xa438, 0x5fa2, 0xa438, 0xb302,
+	0xa438, 0x9204, 0xa438, 0xcb32, 0xa438, 0xd408, 0xa438, 0x1000,
+	0xa438, 0x0a37, 0xa438, 0xd141, 0xa438, 0xd043, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd704,
+	0xa438, 0x4ccc, 0xa438, 0xd700, 0xa438, 0x4c81, 0xa438, 0xd702,
+	0xa438, 0x609e, 0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0xf003,
+	0xa438, 0xd1e5, 0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083,
+	0xa438, 0x0c1f, 0xa438, 0x0d01, 0xa438, 0xf003, 0xa438, 0x0c1f,
+	0xa438, 0x0d01, 0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0x8710,
+	0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8108,
+	0xa438, 0xa203, 0xa438, 0x8120, 0xa438, 0x8a0f, 0xa438, 0xa111,
+	0xa438, 0x8204, 0xa438, 0xa140, 0xa438, 0x1000, 0xa438, 0x0a42,
+	0xa438, 0x8140, 0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xa204,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+	0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0xd404, 0xa438, 0x1000,
+	0xa438, 0x0a37, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+	0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+	0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xa710, 0xa438, 0x8101,
+	0xa438, 0x8201, 0xa438, 0xa104, 0xa438, 0x1000, 0xa438, 0x0a42,
+	0xa438, 0x8104, 0xa438, 0xa120, 0xa438, 0xaa0f, 0xa438, 0x8110,
+	0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0xa00a, 0xa438, 0xd193,
+	0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0xa110, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5fa8, 0xa438, 0xa180, 0xa438, 0xd13d,
+	0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0xf024, 0xa438, 0xa710, 0xa438, 0xa00a,
+	0xa438, 0x8190, 0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fa7,
+	0xa438, 0x8710, 0xa438, 0xb920, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x5fac, 0xa438, 0x9920, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f8c, 0xa438, 0x800a,
+	0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0x8406, 0xa438, 0xd700,
+	0xa438, 0x4121, 0xa438, 0xd701, 0xa438, 0x60f3, 0xa438, 0xd1e5,
+	0xa438, 0xd04d, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0x8710, 0xa438, 0xa00a, 0xa438, 0x8190,
+	0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa404, 0xa438, 0xb920,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x5fac,
+	0xa438, 0x9920, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f,
+	0xa438, 0x7f8c, 0xa438, 0xcb33, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd71f, 0xa438, 0x5f85, 0xa438, 0xa710, 0xa438, 0xb820,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd71f, 0xa438, 0x7f65,
+	0xa438, 0x9820, 0xa438, 0xcb34, 0xa438, 0xa00a, 0xa438, 0xa190,
+	0xa438, 0xa284, 0xa438, 0xa404, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5fa9, 0xa438, 0xd701, 0xa438, 0x6853,
+	0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f, 0xa438, 0x0d00,
+	0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d00, 0xa438, 0x1000,
+	0xa438, 0x0a7d, 0xa438, 0x8190, 0xa438, 0x8284, 0xa438, 0xcb35,
+	0xa438, 0xd407, 0xa438, 0x1000, 0xa438, 0x0a37, 0xa438, 0x8110,
+	0xa438, 0x8204, 0xa438, 0xa280, 0xa438, 0xa00a, 0xa438, 0xd704,
+	0xa438, 0x4215, 0xa438, 0xa304, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5fb8, 0xa438, 0xd1c3, 0xa438, 0xd043,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+	0xa438, 0x8304, 0xa438, 0xd700, 0xa438, 0x4109, 0xa438, 0xf01e,
+	0xa438, 0xcb36, 0xa438, 0xd412, 0xa438, 0x1000, 0xa438, 0x0a37,
+	0xa438, 0xd700, 0xa438, 0x6309, 0xa438, 0xd702, 0xa438, 0x42c7,
+	0xa438, 0x800a, 0xa438, 0x8180, 0xa438, 0x8280, 0xa438, 0x8404,
+	0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8004,
+	0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0a42, 0xa438, 0x8001,
+	0xa438, 0x0c03, 0xa438, 0x0902, 0xa438, 0xa00a, 0xa438, 0xd14a,
+	0xa438, 0xd048, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0xd700, 0xa438, 0x6083, 0xa438, 0x0c1f,
+	0xa438, 0x0d02, 0xa438, 0xf003, 0xa438, 0x0c1f, 0xa438, 0x0d02,
+	0xa438, 0x1000, 0xa438, 0x0a7d, 0xa438, 0xcc55, 0xa438, 0xcb37,
+	0xa438, 0xa00a, 0xa438, 0xa190, 0xa438, 0xa2a4, 0xa438, 0xa404,
+	0xa438, 0xd700, 0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd13d,
+	0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700,
+	0xa438, 0x5fa9, 0xa438, 0xd702, 0xa438, 0x5f71, 0xa438, 0xcb38,
+	0xa438, 0x8224, 0xa438, 0xa288, 0xa438, 0x8180, 0xa438, 0xa110,
+	0xa438, 0xa404, 0xa438, 0x800a, 0xa438, 0xd700, 0xa438, 0x6041,
+	0xa438, 0x8402, 0xa438, 0xd415, 0xa438, 0x1000, 0xa438, 0x0a37,
+	0xa438, 0xd13d, 0xa438, 0xd04a, 0xa438, 0x1000, 0xa438, 0x0a5e,
+	0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb39, 0xa438, 0xa00a,
+	0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xd700,
+	0xa438, 0x6041, 0xa438, 0xa402, 0xa438, 0xd17a, 0xa438, 0xd047,
+	0xa438, 0x1000, 0xa438, 0x0a5e, 0xa438, 0xd700, 0xa438, 0x5fb4,
+	0xa438, 0x1800, 0xa438, 0x0560, 0xa438, 0xa111, 0xa438, 0x0000,
+	0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xd3f5,
+	0xa438, 0xd219, 0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708,
+	0xa438, 0x5fa5, 0xa438, 0xa215, 0xa438, 0xd30e, 0xa438, 0xd21a,
+	0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x63e9,
+	0xa438, 0xd708, 0xa438, 0x5f65, 0xa438, 0xd708, 0xa438, 0x7f36,
+	0xa438, 0xa004, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8004,
+	0xa438, 0xa001, 0xa438, 0x1000, 0xa438, 0x0c35, 0xa438, 0x8001,
+	0xa438, 0xd708, 0xa438, 0x4098, 0xa438, 0xd102, 0xa438, 0x9401,
+	0xa438, 0xf003, 0xa438, 0xd103, 0xa438, 0xb401, 0xa438, 0x1000,
+	0xa438, 0x0c27, 0xa438, 0xa108, 0xa438, 0x1000, 0xa438, 0x0c35,
+	0xa438, 0x8108, 0xa438, 0x8110, 0xa438, 0x8294, 0xa438, 0xa202,
+	0xa438, 0x1800, 0xa438, 0x0bdb, 0xa438, 0xd39c, 0xa438, 0xd210,
+	0xa438, 0x1000, 0xa438, 0x0c31, 0xa438, 0xd708, 0xa438, 0x5fa5,
+	0xa438, 0xd39c, 0xa438, 0xd210, 0xa438, 0x1000, 0xa438, 0x0c31,
+	0xa438, 0xd708, 0xa438, 0x5fa5, 0xa438, 0x1000, 0xa438, 0x0c31,
+	0xa438, 0xd708, 0xa438, 0x29b5, 0xa438, 0x840e, 0xa438, 0xd708,
+	0xa438, 0x5f4a, 0xa438, 0x0c1f, 0xa438, 0x1014, 0xa438, 0x1000,
+	0xa438, 0x0c31, 0xa438, 0xd709, 0xa438, 0x7fa4, 0xa438, 0x901f,
+	0xa438, 0x1800, 0xa438, 0x0c23, 0xa438, 0xcb43, 0xa438, 0xa508,
+	0xa438, 0xd701, 0xa438, 0x3699, 0xa438, 0x844a, 0xa438, 0xa504,
+	0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0xa00a,
+	0xa438, 0xd700, 0xa438, 0x2109, 0xa438, 0x05ea, 0xa438, 0xa402,
+	0xa438, 0x1800, 0xa438, 0x05ea, 0xa438, 0xcb90, 0xa438, 0x0cf0,
+	0xa438, 0x0ca0, 0xa438, 0x1800, 0xa438, 0x06db, 0xa438, 0xd1ff,
+	0xa438, 0xd052, 0xa438, 0xa508, 0xa438, 0x8718, 0xa438, 0xa00a,
+	0xa438, 0xa190, 0xa438, 0xa2a0, 0xa438, 0xa404, 0xa438, 0x0cf0,
+	0xa438, 0x0c50, 0xa438, 0x1800, 0xa438, 0x09ef, 0xa438, 0x1000,
+	0xa438, 0x0a5e, 0xa438, 0xd704, 0xa438, 0x2e70, 0xa438, 0x06da,
+	0xa438, 0xd700, 0xa438, 0x5f55, 0xa438, 0xa90c, 0xa438, 0x1800,
+	0xa438, 0x0645, 0xa436, 0xA10E, 0xa438, 0x0644, 0xa436, 0xA10C,
+	0xa438, 0x09e9, 0xa436, 0xA10A, 0xa438, 0x06da, 0xa436, 0xA108,
+	0xa438, 0x05e1, 0xa436, 0xA106, 0xa438, 0x0be4, 0xa436, 0xA104,
+	0xa438, 0x0435, 0xa436, 0xA102, 0xa438, 0x0141, 0xa436, 0xA100,
+	0xa438, 0x026d, 0xa436, 0xA110, 0xa438, 0x00ff, 0xa436, 0xb87c,
+	0xa438, 0x85fe, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x16af,
+	0xa438, 0x8699, 0xa438, 0xaf86, 0xa438, 0xe5af, 0xa438, 0x86f9,
+	0xa438, 0xaf87, 0xa438, 0x7aaf, 0xa438, 0x883a, 0xa438, 0xaf88,
+	0xa438, 0x58af, 0xa438, 0x8b6c, 0xa438, 0xd48b, 0xa438, 0x7c02,
+	0xa438, 0x8644, 0xa438, 0x2c00, 0xa438, 0x503c, 0xa438, 0xffd6,
+	0xa438, 0xac27, 0xa438, 0x18e1, 0xa438, 0x82fe, 0xa438, 0xad28,
+	0xa438, 0x0cd4, 0xa438, 0x8b84, 0xa438, 0x0286, 0xa438, 0x442c,
+	0xa438, 0x003c, 0xa438, 0xac27, 0xa438, 0x06ee, 0xa438, 0x8299,
+	0xa438, 0x01ae, 0xa438, 0x04ee, 0xa438, 0x8299, 0xa438, 0x00af,
+	0xa438, 0x23dc, 0xa438, 0xf9fa, 0xa438, 0xcefa, 0xa438, 0xfbef,
+	0xa438, 0x79fb, 0xa438, 0xc4bf, 0xa438, 0x8b76, 0xa438, 0x026c,
+	0xa438, 0x6dac, 0xa438, 0x2804, 0xa438, 0xd203, 0xa438, 0xae02,
+	0xa438, 0xd201, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+	0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x648a,
+	0xa438, 0x0002, 0xa438, 0xbdd8, 0xa438, 0x19d9, 0xa438, 0xef94,
+	0xa438, 0x026c, 0xa438, 0x6d78, 0xa438, 0x03ef, 0xa438, 0x7402,
+	0xa438, 0x72cd, 0xa438, 0xac50, 0xa438, 0x02ef, 0xa438, 0x643a,
+	0xa438, 0x019f, 0xa438, 0xe4ef, 0xa438, 0x4678, 0xa438, 0x03ac,
+	0xa438, 0x2002, 0xa438, 0xae02, 0xa438, 0xd0ff, 0xa438, 0xffef,
+	0xa438, 0x97ff, 0xa438, 0xfec6, 0xa438, 0xfefd, 0xa438, 0x041f,
+	0xa438, 0x771f, 0xa438, 0x221c, 0xa438, 0x450d, 0xa438, 0x481f,
+	0xa438, 0x00ac, 0xa438, 0x7f04, 0xa438, 0x1a94, 0xa438, 0xae08,
+	0xa438, 0x1a94, 0xa438, 0xac7f, 0xa438, 0x03d7, 0xa438, 0x0100,
+	0xa438, 0xef46, 0xa438, 0x0d48, 0xa438, 0x1f00, 0xa438, 0x1c45,
+	0xa438, 0xef69, 0xa438, 0xef57, 0xa438, 0xef74, 0xa438, 0x0272,
+	0xa438, 0xe8a7, 0xa438, 0xffff, 0xa438, 0x0d1a, 0xa438, 0x941b,
+	0xa438, 0x979e, 0xa438, 0x072d, 0xa438, 0x0100, 0xa438, 0x1a64,
+	0xa438, 0xef76, 0xa438, 0xef97, 0xa438, 0x0d98, 0xa438, 0xd400,
+	0xa438, 0xff1d, 0xa438, 0x941a, 0xa438, 0x89cf, 0xa438, 0x1a75,
+	0xa438, 0xaf74, 0xa438, 0xf9bf, 0xa438, 0x8b79, 0xa438, 0x026c,
+	0xa438, 0x6da1, 0xa438, 0x0005, 0xa438, 0xe180, 0xa438, 0xa0ae,
+	0xa438, 0x03e1, 0xa438, 0x80a1, 0xa438, 0xaf26, 0xa438, 0x9aac,
+	0xa438, 0x284d, 0xa438, 0xe08f, 0xa438, 0xffef, 0xa438, 0x10c0,
+	0xa438, 0xe08f, 0xa438, 0xfe10, 0xa438, 0x1b08, 0xa438, 0xa000,
+	0xa438, 0x04c8, 0xa438, 0xaf40, 0xa438, 0x67c8, 0xa438, 0xbf8b,
+	0xa438, 0x8c02, 0xa438, 0x6c4e, 0xa438, 0xc4bf, 0xa438, 0x8b8f,
+	0xa438, 0x026c, 0xa438, 0x6def, 0xa438, 0x74e0, 0xa438, 0x830c,
+	0xa438, 0xad20, 0xa438, 0x0302, 0xa438, 0x74ac, 0xa438, 0xccef,
+	0xa438, 0x971b, 0xa438, 0x76ad, 0xa438, 0x5f02, 0xa438, 0xae13,
+	0xa438, 0xef69, 0xa438, 0xef30, 0xa438, 0x1b32, 0xa438, 0xc4ef,
+	0xa438, 0x46e4, 0xa438, 0x8ffb, 0xa438, 0xe58f, 0xa438, 0xfce7,
+	0xa438, 0x8ffd, 0xa438, 0xcc10, 0xa438, 0x11ae, 0xa438, 0xb8d1,
+	0xa438, 0x00a1, 0xa438, 0x1f03, 0xa438, 0xaf40, 0xa438, 0x4fbf,
+	0xa438, 0x8b8c, 0xa438, 0x026c, 0xa438, 0x4ec4, 0xa438, 0xbf8b,
+	0xa438, 0x8f02, 0xa438, 0x6c6d, 0xa438, 0xef74, 0xa438, 0xe083,
+	0xa438, 0x0cad, 0xa438, 0x2003, 0xa438, 0x0274, 0xa438, 0xaccc,
+	0xa438, 0xef97, 0xa438, 0x1b76, 0xa438, 0xad5f, 0xa438, 0x02ae,
+	0xa438, 0x04ef, 0xa438, 0x69ef, 0xa438, 0x3111, 0xa438, 0xaed1,
+	0xa438, 0x0287, 0xa438, 0x80af, 0xa438, 0x2293, 0xa438, 0xf8f9,
+	0xa438, 0xfafb, 0xa438, 0xef59, 0xa438, 0xe080, 0xa438, 0x13ad,
+	0xa438, 0x252f, 0xa438, 0xbf88, 0xa438, 0x2802, 0xa438, 0x6c6d,
+	0xa438, 0xef64, 0xa438, 0x1f44, 0xa438, 0xe18f, 0xa438, 0xb91b,
+	0xa438, 0x64ad, 0xa438, 0x4f1d, 0xa438, 0xd688, 0xa438, 0x2bd7,
+	0xa438, 0x882e, 0xa438, 0x0274, 0xa438, 0x73ad, 0xa438, 0x5008,
+	0xa438, 0xbf88, 0xa438, 0x3102, 0xa438, 0x737c, 0xa438, 0xae03,
+	0xa438, 0x0287, 0xa438, 0xd0bf, 0xa438, 0x882b, 0xa438, 0x0273,
+	0xa438, 0x73e0, 0xa438, 0x824c, 0xa438, 0xf621, 0xa438, 0xe482,
+	0xa438, 0x4cbf, 0xa438, 0x8834, 0xa438, 0x0273, 0xa438, 0x7cef,
+	0xa438, 0x95ff, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+	0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xbf88, 0xa438, 0x1f02,
+	0xa438, 0x737c, 0xa438, 0x1f22, 0xa438, 0xac32, 0xa438, 0x31ef,
+	0xa438, 0x12bf, 0xa438, 0x8822, 0xa438, 0x026c, 0xa438, 0x4ed6,
+	0xa438, 0x8fba, 0xa438, 0x1f33, 0xa438, 0xac3c, 0xa438, 0x1eef,
+	0xa438, 0x13bf, 0xa438, 0x8837, 0xa438, 0x026c, 0xa438, 0x4eef,
+	0xa438, 0x96d8, 0xa438, 0x19d9, 0xa438, 0xbf88, 0xa438, 0x2502,
+	0xa438, 0x6c4e, 0xa438, 0xbf88, 0xa438, 0x2502, 0xa438, 0x6c4e,
+	0xa438, 0x1616, 0xa438, 0x13ae, 0xa438, 0xdf12, 0xa438, 0xaecc,
+	0xa438, 0xbf88, 0xa438, 0x1f02, 0xa438, 0x7373, 0xa438, 0xef97,
+	0xa438, 0xfffe, 0xa438, 0xfdfc, 0xa438, 0x0466, 0xa438, 0xac88,
+	0xa438, 0x54ac, 0xa438, 0x88f0, 0xa438, 0xac8a, 0xa438, 0x92ac,
+	0xa438, 0xbadd, 0xa438, 0xac6c, 0xa438, 0xeeac, 0xa438, 0x6cff,
+	0xa438, 0xad02, 0xa438, 0x99ac, 0xa438, 0x0030, 0xa438, 0xac88,
+	0xa438, 0xd4c3, 0xa438, 0x5000, 0xa438, 0x0000, 0xa438, 0x0000,
+	0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x0000,
+	0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0x00b4, 0xa438, 0xecee,
+	0xa438, 0x8298, 0xa438, 0x00af, 0xa438, 0x1412, 0xa438, 0xf8bf,
+	0xa438, 0x8b5d, 0xa438, 0x026c, 0xa438, 0x6d58, 0xa438, 0x03e1,
+	0xa438, 0x8fb8, 0xa438, 0x2901, 0xa438, 0xe58f, 0xa438, 0xb8a0,
+	0xa438, 0x0049, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x02e5,
+	0xa438, 0x8303, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+	0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+	0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+	0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+	0xa438, 0xf728, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+	0xa438, 0xf628, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+	0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6002,
+	0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+	0xa438, 0xaf89, 0xa438, 0x96a0, 0xa438, 0x0149, 0xa438, 0xef47,
+	0xa438, 0xe483, 0xa438, 0x04e5, 0xa438, 0x8305, 0xa438, 0xbfc2,
+	0xa438, 0x5f1a, 0xa438, 0x95f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+	0xa438, 0x00d8, 0xa438, 0xf605, 0xa438, 0x1f11, 0xa438, 0xef60,
+	0xa438, 0xbf8b, 0xa438, 0x3002, 0xa438, 0x6c4e, 0xa438, 0xbf8b,
+	0xa438, 0x3302, 0xa438, 0x6c6d, 0xa438, 0xf729, 0xa438, 0xbf8b,
+	0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0xf629, 0xa438, 0xbf8b,
+	0xa438, 0x3302, 0xa438, 0x6c4e, 0xa438, 0x0c64, 0xa438, 0xef46,
+	0xa438, 0xbf8b, 0xa438, 0x6302, 0xa438, 0x6c4e, 0xa438, 0x0289,
+	0xa438, 0x9902, 0xa438, 0x3920, 0xa438, 0xaf89, 0xa438, 0x96a0,
+	0xa438, 0x0249, 0xa438, 0xef47, 0xa438, 0xe483, 0xa438, 0x06e5,
+	0xa438, 0x8307, 0xa438, 0xbfc2, 0xa438, 0x5f1a, 0xa438, 0x95f7,
+	0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00d8, 0xa438, 0xf605,
+	0xa438, 0x1f11, 0xa438, 0xef60, 0xa438, 0xbf8b, 0xa438, 0x3002,
+	0xa438, 0x6c4e, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c6d,
+	0xa438, 0xf72a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+	0xa438, 0xf62a, 0xa438, 0xbf8b, 0xa438, 0x3302, 0xa438, 0x6c4e,
+	0xa438, 0x0c64, 0xa438, 0xef46, 0xa438, 0xbf8b, 0xa438, 0x6602,
+	0xa438, 0x6c4e, 0xa438, 0x0289, 0xa438, 0x9902, 0xa438, 0x3920,
+	0xa438, 0xaf89, 0xa438, 0x96ef, 0xa438, 0x47e4, 0xa438, 0x8308,
+	0xa438, 0xe583, 0xa438, 0x09bf, 0xa438, 0xc25f, 0xa438, 0x1a95,
+	0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xd8f6,
+	0xa438, 0x051f, 0xa438, 0x11ef, 0xa438, 0x60bf, 0xa438, 0x8b30,
+	0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b33, 0xa438, 0x026c,
+	0xa438, 0x6df7, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+	0xa438, 0x4ef6, 0xa438, 0x2bbf, 0xa438, 0x8b33, 0xa438, 0x026c,
+	0xa438, 0x4e0c, 0xa438, 0x64ef, 0xa438, 0x46bf, 0xa438, 0x8b69,
+	0xa438, 0x026c, 0xa438, 0x4e02, 0xa438, 0x8999, 0xa438, 0x0239,
+	0xa438, 0x20af, 0xa438, 0x8996, 0xa438, 0xaf39, 0xa438, 0x1ef8,
+	0xa438, 0xf9fa, 0xa438, 0xe08f, 0xa438, 0xb838, 0xa438, 0x02ad,
+	0xa438, 0x2702, 0xa438, 0xae03, 0xa438, 0xaf8b, 0xa438, 0x201f,
+	0xa438, 0x66ef, 0xa438, 0x65bf, 0xa438, 0xc21f, 0xa438, 0x1a96,
+	0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdaf6,
+	0xa438, 0x05bf, 0xa438, 0xc22f, 0xa438, 0x1a96, 0xa438, 0xf705,
+	0xa438, 0xeeff, 0xa438, 0xd200, 0xa438, 0xdbf6, 0xa438, 0x05ef,
+	0xa438, 0x021f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b3c,
+	0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021b, 0xa438, 0x031f,
+	0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b36, 0xa438, 0x026c,
+	0xa438, 0x4eef, 0xa438, 0x021a, 0xa438, 0x031f, 0xa438, 0x110d,
+	0xa438, 0x42bf, 0xa438, 0x8b39, 0xa438, 0x026c, 0xa438, 0x4ebf,
+	0xa438, 0xc23f, 0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff,
+	0xa438, 0xd200, 0xa438, 0xdaf6, 0xa438, 0x05bf, 0xa438, 0xc24f,
+	0xa438, 0x1a96, 0xa438, 0xf705, 0xa438, 0xeeff, 0xa438, 0xd200,
+	0xa438, 0xdbf6, 0xa438, 0x05ef, 0xa438, 0x021f, 0xa438, 0x110d,
+	0xa438, 0x42bf, 0xa438, 0x8b45, 0xa438, 0x026c, 0xa438, 0x4eef,
+	0xa438, 0x021b, 0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf,
+	0xa438, 0x8b3f, 0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x021a,
+	0xa438, 0x031f, 0xa438, 0x110d, 0xa438, 0x42bf, 0xa438, 0x8b42,
+	0xa438, 0x026c, 0xa438, 0x4eef, 0xa438, 0x56d0, 0xa438, 0x201f,
+	0xa438, 0x11bf, 0xa438, 0x8b4e, 0xa438, 0x026c, 0xa438, 0x4ebf,
+	0xa438, 0x8b48, 0xa438, 0x026c, 0xa438, 0x4ebf, 0xa438, 0x8b4b,
+	0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8578, 0xa438, 0xef03,
+	0xa438, 0x480a, 0xa438, 0x2805, 0xa438, 0xef20, 0xa438, 0x1b01,
+	0xa438, 0xad27, 0xa438, 0x3f1f, 0xa438, 0x44e0, 0xa438, 0x8560,
+	0xa438, 0xe185, 0xa438, 0x61bf, 0xa438, 0x8b51, 0xa438, 0x026c,
+	0xa438, 0x4ee0, 0xa438, 0x8566, 0xa438, 0xe185, 0xa438, 0x67bf,
+	0xa438, 0x8b54, 0xa438, 0x026c, 0xa438, 0x4ee0, 0xa438, 0x856c,
+	0xa438, 0xe185, 0xa438, 0x6dbf, 0xa438, 0x8b57, 0xa438, 0x026c,
+	0xa438, 0x4ee0, 0xa438, 0x8572, 0xa438, 0xe185, 0xa438, 0x73bf,
+	0xa438, 0x8b5a, 0xa438, 0x026c, 0xa438, 0x4ee1, 0xa438, 0x8fb8,
+	0xa438, 0x5900, 0xa438, 0xf728, 0xa438, 0xe58f, 0xa438, 0xb8af,
+	0xa438, 0x8b2c, 0xa438, 0xe185, 0xa438, 0x791b, 0xa438, 0x21ad,
+	0xa438, 0x373e, 0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x62e1,
+	0xa438, 0x8563, 0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e,
+	0xa438, 0xe085, 0xa438, 0x68e1, 0xa438, 0x8569, 0xa438, 0xbf8b,
+	0xa438, 0x5402, 0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x6ee1,
+	0xa438, 0x856f, 0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e,
+	0xa438, 0xe085, 0xa438, 0x74e1, 0xa438, 0x8575, 0xa438, 0xbf8b,
+	0xa438, 0x5a02, 0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859,
+	0xa438, 0x00f7, 0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae4a,
+	0xa438, 0x1f44, 0xa438, 0xe085, 0xa438, 0x64e1, 0xa438, 0x8565,
+	0xa438, 0xbf8b, 0xa438, 0x5102, 0xa438, 0x6c4e, 0xa438, 0xe085,
+	0xa438, 0x6ae1, 0xa438, 0x856b, 0xa438, 0xbf8b, 0xa438, 0x5402,
+	0xa438, 0x6c4e, 0xa438, 0xe085, 0xa438, 0x70e1, 0xa438, 0x8571,
+	0xa438, 0xbf8b, 0xa438, 0x5702, 0xa438, 0x6c4e, 0xa438, 0xe085,
+	0xa438, 0x76e1, 0xa438, 0x8577, 0xa438, 0xbf8b, 0xa438, 0x5a02,
+	0xa438, 0x6c4e, 0xa438, 0xe18f, 0xa438, 0xb859, 0xa438, 0x00f7,
+	0xa438, 0x28e5, 0xa438, 0x8fb8, 0xa438, 0xae0c, 0xa438, 0xe18f,
+	0xa438, 0xb839, 0xa438, 0x04ac, 0xa438, 0x2f04, 0xa438, 0xee8f,
+	0xa438, 0xb800, 0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf0ac,
+	0xa438, 0x8efc, 0xa438, 0xac8c, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+	0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xf6f0, 0xa438, 0xad00,
+	0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacfc, 0xa438, 0xf0ac,
+	0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xf0f0,
+	0xa438, 0xacb0, 0xa438, 0xf0ac, 0xa438, 0xaef0, 0xa438, 0xacac,
+	0xa438, 0xf0ac, 0xa438, 0xaaf0, 0xa438, 0xacee, 0xa438, 0xf0b0,
+	0xa438, 0x24f0, 0xa438, 0xb0a4, 0xa438, 0xf0b1, 0xa438, 0x24f0,
+	0xa438, 0xb1a4, 0xa438, 0xee8f, 0xa438, 0xb800, 0xa438, 0xd400,
+	0xa438, 0x00af, 0xa438, 0x3976, 0xa438, 0x66ac, 0xa438, 0xeabb,
+	0xa438, 0xa430, 0xa438, 0x6e50, 0xa438, 0x6e53, 0xa438, 0x6e56,
+	0xa438, 0x6e59, 0xa438, 0x6e5c, 0xa438, 0x6e5f, 0xa438, 0x6e62,
+	0xa438, 0x6e65, 0xa438, 0xd9ac, 0xa438, 0x70f0, 0xa438, 0xac6a,
+	0xa436, 0xb85e, 0xa438, 0x23b7, 0xa436, 0xb860, 0xa438, 0x74db,
+	0xa436, 0xb862, 0xa438, 0x268c, 0xa436, 0xb864, 0xa438, 0x3FE5,
+	0xa436, 0xb886, 0xa438, 0x2250, 0xa436, 0xb888, 0xa438, 0x140e,
+	0xa436, 0xb88a, 0xa438, 0x3696, 0xa436, 0xb88c, 0xa438, 0x3973,
+	0xa436, 0xb838, 0xa438, 0x00ff, 0xb820, 0x0010, 0xa436, 0x8464,
+	0xa438, 0xaf84, 0xa438, 0x7caf, 0xa438, 0x8485, 0xa438, 0xaf85,
+	0xa438, 0x13af, 0xa438, 0x851e, 0xa438, 0xaf85, 0xa438, 0xb9af,
+	0xa438, 0x8684, 0xa438, 0xaf87, 0xa438, 0x01af, 0xa438, 0x8701,
+	0xa438, 0xac38, 0xa438, 0x03af, 0xa438, 0x38bb, 0xa438, 0xaf38,
+	0xa438, 0xc302, 0xa438, 0x4618, 0xa438, 0xbf85, 0xa438, 0x0a02,
+	0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x1002, 0xa438, 0x54c0,
+	0xa438, 0xd400, 0xa438, 0x0fbf, 0xa438, 0x8507, 0xa438, 0x024f,
+	0xa438, 0x48bf, 0xa438, 0x8504, 0xa438, 0x024f, 0xa438, 0x6759,
+	0xa438, 0xf0a1, 0xa438, 0x3008, 0xa438, 0xbf85, 0xa438, 0x0d02,
+	0xa438, 0x54c0, 0xa438, 0xae06, 0xa438, 0xbf85, 0xa438, 0x0d02,
+	0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0x0402, 0xa438, 0x4f67,
+	0xa438, 0xa183, 0xa438, 0x02ae, 0xa438, 0x15a1, 0xa438, 0x8502,
+	0xa438, 0xae10, 0xa438, 0x59f0, 0xa438, 0xa180, 0xa438, 0x16bf,
+	0xa438, 0x8501, 0xa438, 0x024f, 0xa438, 0x67a1, 0xa438, 0x381b,
+	0xa438, 0xae0b, 0xa438, 0xe18f, 0xa438, 0xffbf, 0xa438, 0x84fe,
+	0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x17bf, 0xa438, 0x84fe,
+	0xa438, 0x0254, 0xa438, 0xb7bf, 0xa438, 0x84fb, 0xa438, 0x0254,
+	0xa438, 0xb7ae, 0xa438, 0x09a1, 0xa438, 0x5006, 0xa438, 0xbf84,
+	0xa438, 0xfb02, 0xa438, 0x54c0, 0xa438, 0xaf04, 0xa438, 0x4700,
+	0xa438, 0xad34, 0xa438, 0xfdad, 0xa438, 0x0670, 0xa438, 0xae14,
+	0xa438, 0xf0a6, 0xa438, 0x00b8, 0xa438, 0xbd32, 0xa438, 0x30bd,
+	0xa438, 0x30aa, 0xa438, 0xbd2c, 0xa438, 0xccbd, 0xa438, 0x2ca1,
+	0xa438, 0x0705, 0xa438, 0xec80, 0xa438, 0xaf40, 0xa438, 0xf7af,
+	0xa438, 0x40f5, 0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402,
+	0xa438, 0x4f48, 0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0,
+	0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+	0xa438, 0x024d, 0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f,
+	0xa438, 0x67bf, 0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0,
+	0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf,
+	0xa438, 0x85b3, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9,
+	0xa438, 0xddbf, 0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf,
+	0xa438, 0x8ffa, 0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa,
+	0xa438, 0x024f, 0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85,
+	0xa438, 0xad02, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd,
+	0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+	0xa438, 0xfcdd, 0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67,
+	0xa438, 0xbf8f, 0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602,
+	0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85,
+	0xa438, 0xa702, 0xa438, 0x54b7, 0xa438, 0xbf85, 0xa438, 0xa102,
+	0xa438, 0x54b7, 0xa438, 0xaf3c, 0xa438, 0x2066, 0xa438, 0xb800,
+	0xa438, 0xb8bd, 0xa438, 0x30ee, 0xa438, 0xbd2c, 0xa438, 0xb8bd,
+	0xa438, 0x7040, 0xa438, 0xbd86, 0xa438, 0xc8bd, 0xa438, 0x8640,
+	0xa438, 0xbd88, 0xa438, 0xc8bd, 0xa438, 0x8802, 0xa438, 0x1929,
+	0xa438, 0xa202, 0xa438, 0x02ae, 0xa438, 0x03a2, 0xa438, 0x032e,
+	0xa438, 0xd10f, 0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48,
+	0xa438, 0xe18f, 0xa438, 0xf7bf, 0xa438, 0x85ad, 0xa438, 0x024f,
+	0xa438, 0x48e1, 0xa438, 0x8ff8, 0xa438, 0xbf85, 0xa438, 0xb002,
+	0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x85b3,
+	0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ffa, 0xa438, 0xbf85,
+	0xa438, 0xb602, 0xa438, 0x4f48, 0xa438, 0xae2c, 0xa438, 0xd100,
+	0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0xe18f,
+	0xa438, 0xfbbf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x48e1,
+	0xa438, 0x8ffc, 0xa438, 0xbf85, 0xa438, 0xb002, 0xa438, 0x4f48,
+	0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x85b3, 0xa438, 0x024f,
+	0xa438, 0x48e1, 0xa438, 0x8ffe, 0xa438, 0xbf85, 0xa438, 0xb602,
+	0xa438, 0x4f48, 0xa438, 0xbf86, 0xa438, 0x7e02, 0xa438, 0x4f67,
+	0xa438, 0xa100, 0xa438, 0x02ae, 0xa438, 0x25a1, 0xa438, 0x041d,
+	0xa438, 0xe18f, 0xa438, 0xf1bf, 0xa438, 0x8675, 0xa438, 0x024f,
+	0xa438, 0x48e1, 0xa438, 0x8ff2, 0xa438, 0xbf86, 0xa438, 0x7802,
+	0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf3bf, 0xa438, 0x867b,
+	0xa438, 0x024f, 0xa438, 0x48ae, 0xa438, 0x29a1, 0xa438, 0x070b,
+	0xa438, 0xae24, 0xa438, 0xbf86, 0xa438, 0x8102, 0xa438, 0x4f67,
+	0xa438, 0xad28, 0xa438, 0x1be1, 0xa438, 0x8ff4, 0xa438, 0xbf86,
+	0xa438, 0x7502, 0xa438, 0x4f48, 0xa438, 0xe18f, 0xa438, 0xf5bf,
+	0xa438, 0x8678, 0xa438, 0x024f, 0xa438, 0x48e1, 0xa438, 0x8ff6,
+	0xa438, 0xbf86, 0xa438, 0x7b02, 0xa438, 0x4f48, 0xa438, 0xaf09,
+	0xa438, 0x8420, 0xa438, 0xbc32, 0xa438, 0x20bc, 0xa438, 0x3e76,
+	0xa438, 0xbc08, 0xa438, 0xfda6, 0xa438, 0x1a00, 0xa438, 0xb64e,
+	0xa438, 0xd101, 0xa438, 0xbf85, 0xa438, 0xa402, 0xa438, 0x4f48,
+	0xa438, 0xbf85, 0xa438, 0xa702, 0xa438, 0x54c0, 0xa438, 0xd10f,
+	0xa438, 0xbf85, 0xa438, 0xaa02, 0xa438, 0x4f48, 0xa438, 0x024d,
+	0xa438, 0x6abf, 0xa438, 0x85ad, 0xa438, 0x024f, 0xa438, 0x67bf,
+	0xa438, 0x8ff7, 0xa438, 0xddbf, 0xa438, 0x85b0, 0xa438, 0x024f,
+	0xa438, 0x67bf, 0xa438, 0x8ff8, 0xa438, 0xddbf, 0xa438, 0x85b3,
+	0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ff9, 0xa438, 0xddbf,
+	0xa438, 0x85b6, 0xa438, 0x024f, 0xa438, 0x67bf, 0xa438, 0x8ffa,
+	0xa438, 0xddd1, 0xa438, 0x00bf, 0xa438, 0x85aa, 0xa438, 0x024f,
+	0xa438, 0x4802, 0xa438, 0x4d6a, 0xa438, 0xbf85, 0xa438, 0xad02,
+	0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfbdd, 0xa438, 0xbf85,
+	0xa438, 0xb002, 0xa438, 0x4f67, 0xa438, 0xbf8f, 0xa438, 0xfcdd,
+	0xa438, 0xbf85, 0xa438, 0xb302, 0xa438, 0x4f67, 0xa438, 0xbf8f,
+	0xa438, 0xfddd, 0xa438, 0xbf85, 0xa438, 0xb602, 0xa438, 0x4f67,
+	0xa438, 0xbf8f, 0xa438, 0xfedd, 0xa438, 0xbf85, 0xa438, 0xa702,
+	0xa438, 0x54b7, 0xa438, 0xaf00, 0xa438, 0x8800, 0xa436, 0xb818,
+	0xa438, 0x38b8, 0xa436, 0xb81a, 0xa438, 0x0444, 0xa436, 0xb81c,
+	0xa438, 0x40ee, 0xa436, 0xb81e, 0xa438, 0x3C1A, 0xa436, 0xb850,
+	0xa438, 0x0981, 0xa436, 0xb852, 0xa438, 0x0085, 0xa436, 0xb878,
+	0xa438, 0xffff, 0xa436, 0xb884, 0xa438, 0xffff, 0xa436, 0xb832,
+	0xa438, 0x003f, 0xa436, 0x0000, 0xa438, 0x0000, 0xa436, 0xB82E,
+	0xa438, 0x0000, 0xa436, 0x8024, 0xa438, 0x0000, 0xb820, 0x0000,
+	0xa436, 0x801E, 0xa438, 0x0021, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125b_2[] = {
+	0xa436, 0x8024, 0xa438, 0x3701, 0xa436, 0xB82E, 0xa438, 0x0001,
+	0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x801a, 0xa438, 0x1800, 0xa438, 0x803f,
+	0xa438, 0x1800, 0xa438, 0x8045, 0xa438, 0x1800, 0xa438, 0x8067,
+	0xa438, 0x1800, 0xa438, 0x806d, 0xa438, 0x1800, 0xa438, 0x8071,
+	0xa438, 0x1800, 0xa438, 0x80b1, 0xa438, 0xd093, 0xa438, 0xd1c4,
+	0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd704, 0xa438, 0x5fbc,
+	0xa438, 0xd504, 0xa438, 0xc9f1, 0xa438, 0x1800, 0xa438, 0x0fc9,
+	0xa438, 0xbb50, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd504,
+	0xa438, 0x8c0f, 0xa438, 0xd500, 0xa438, 0x1000, 0xa438, 0x1519,
+	0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fae,
+	0xa438, 0x9b50, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd75e,
+	0xa438, 0x7fae, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd707,
+	0xa438, 0x40a7, 0xa438, 0xd719, 0xa438, 0x4071, 0xa438, 0x1800,
+	0xa438, 0x1557, 0xa438, 0xd719, 0xa438, 0x2f70, 0xa438, 0x803b,
+	0xa438, 0x2f73, 0xa438, 0x156a, 0xa438, 0x5e70, 0xa438, 0x1800,
+	0xa438, 0x155d, 0xa438, 0xd505, 0xa438, 0xa202, 0xa438, 0xd500,
+	0xa438, 0xffed, 0xa438, 0xd709, 0xa438, 0x4054, 0xa438, 0xa788,
+	0xa438, 0xd70b, 0xa438, 0x1800, 0xa438, 0x172a, 0xa438, 0xc0c1,
+	0xa438, 0xc0c0, 0xa438, 0xd05a, 0xa438, 0xd1ba, 0xa438, 0xd701,
+	0xa438, 0x2529, 0xa438, 0x022a, 0xa438, 0xd0a7, 0xa438, 0xd1b9,
+	0xa438, 0xa208, 0xa438, 0x1000, 0xa438, 0x080e, 0xa438, 0xd701,
+	0xa438, 0x408b, 0xa438, 0x1000, 0xa438, 0x0a65, 0xa438, 0xf003,
+	0xa438, 0x1000, 0xa438, 0x0a6b, 0xa438, 0xd701, 0xa438, 0x1000,
+	0xa438, 0x0920, 0xa438, 0x1000, 0xa438, 0x0915, 0xa438, 0x1000,
+	0xa438, 0x0909, 0xa438, 0x228f, 0xa438, 0x804e, 0xa438, 0x9801,
+	0xa438, 0xd71e, 0xa438, 0x5d61, 0xa438, 0xd701, 0xa438, 0x1800,
+	0xa438, 0x022a, 0xa438, 0x2005, 0xa438, 0x091a, 0xa438, 0x3bd9,
+	0xa438, 0x0919, 0xa438, 0x1800, 0xa438, 0x0916, 0xa438, 0xd090,
+	0xa438, 0xd1c9, 0xa438, 0x1800, 0xa438, 0x1064, 0xa438, 0xd096,
+	0xa438, 0xd1a9, 0xa438, 0xd503, 0xa438, 0xa104, 0xa438, 0x0c07,
+	0xa438, 0x0902, 0xa438, 0xd500, 0xa438, 0xbc10, 0xa438, 0xd501,
+	0xa438, 0xce01, 0xa438, 0xa201, 0xa438, 0x8201, 0xa438, 0xce00,
+	0xa438, 0xd500, 0xa438, 0xc484, 0xa438, 0xd503, 0xa438, 0xcc02,
+	0xa438, 0xcd0d, 0xa438, 0xaf01, 0xa438, 0xd500, 0xa438, 0xd703,
+	0xa438, 0x4371, 0xa438, 0xbd08, 0xa438, 0x1000, 0xa438, 0x135c,
+	0xa438, 0xd75e, 0xa438, 0x5fb3, 0xa438, 0xd503, 0xa438, 0xd0f5,
+	0xa438, 0xd1c6, 0xa438, 0x0cf0, 0xa438, 0x0e50, 0xa438, 0xd704,
+	0xa438, 0x401c, 0xa438, 0xd0f5, 0xa438, 0xd1c6, 0xa438, 0x0cf0,
+	0xa438, 0x0ea0, 0xa438, 0x401c, 0xa438, 0xd07b, 0xa438, 0xd1c5,
+	0xa438, 0x8ef0, 0xa438, 0x401c, 0xa438, 0x9d08, 0xa438, 0x1000,
+	0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x7fb3, 0xa438, 0x1000,
+	0xa438, 0x135c, 0xa438, 0xd75e, 0xa438, 0x5fad, 0xa438, 0x1000,
+	0xa438, 0x14c5, 0xa438, 0xd703, 0xa438, 0x3181, 0xa438, 0x80af,
+	0xa438, 0x60ad, 0xa438, 0x1000, 0xa438, 0x135c, 0xa438, 0xd703,
+	0xa438, 0x5fba, 0xa438, 0x1800, 0xa438, 0x0cc7, 0xa438, 0xa802,
+	0xa438, 0xa301, 0xa438, 0xa801, 0xa438, 0xc004, 0xa438, 0xd710,
+	0xa438, 0x4000, 0xa438, 0x1800, 0xa438, 0x1e79, 0xa436, 0xA026,
+	0xa438, 0x1e78, 0xa436, 0xA024, 0xa438, 0x0c93, 0xa436, 0xA022,
+	0xa438, 0x1062, 0xa436, 0xA020, 0xa438, 0x0915, 0xa436, 0xA006,
+	0xa438, 0x020a, 0xa436, 0xA004, 0xa438, 0x1726, 0xa436, 0xA002,
+	0xa438, 0x1542, 0xa436, 0xA000, 0xa438, 0x0fc7, 0xa436, 0xA008,
+	0xa438, 0xff00, 0xa436, 0xA016, 0xa438, 0x0010, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x801d, 0xa438, 0x1800, 0xa438, 0x802c,
+	0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+	0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0x1800, 0xa438, 0x802c,
+	0xa438, 0x1800, 0xa438, 0x802c, 0xa438, 0xd700, 0xa438, 0x6090,
+	0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007, 0xa438, 0x60b1,
+	0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956, 0xa438, 0xf002,
+	0xa438, 0xc94e, 0xa438, 0x1800, 0xa438, 0x00cd, 0xa438, 0xd700,
+	0xa438, 0x6090, 0xa438, 0x60d1, 0xa438, 0xc95c, 0xa438, 0xf007,
+	0xa438, 0x60b1, 0xa438, 0xc95a, 0xa438, 0xf004, 0xa438, 0xc956,
+	0xa438, 0xf002, 0xa438, 0xc94e, 0xa438, 0x1000, 0xa438, 0x022a,
+	0xa438, 0x1800, 0xa438, 0x0132, 0xa436, 0xA08E, 0xa438, 0xffff,
+	0xa436, 0xA08C, 0xa438, 0xffff, 0xa436, 0xA08A, 0xa438, 0xffff,
+	0xa436, 0xA088, 0xa438, 0xffff, 0xa436, 0xA086, 0xa438, 0xffff,
+	0xa436, 0xA084, 0xa438, 0xffff, 0xa436, 0xA082, 0xa438, 0x012f,
+	0xa436, 0xA080, 0xa438, 0x00cc, 0xa436, 0xA090, 0xa438, 0x0103,
+	0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+	0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+	0xa438, 0x8020, 0xa438, 0x1800, 0xa438, 0x802a, 0xa438, 0x1800,
+	0xa438, 0x8035, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+	0xa438, 0x803c, 0xa438, 0x1800, 0xa438, 0x803c, 0xa438, 0x1800,
+	0xa438, 0x803c, 0xa438, 0xd107, 0xa438, 0xd042, 0xa438, 0xa404,
+	0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+	0xa438, 0x8280, 0xa438, 0xd700, 0xa438, 0x6065, 0xa438, 0xd125,
+	0xa438, 0xf002, 0xa438, 0xd12b, 0xa438, 0xd040, 0xa438, 0x1800,
+	0xa438, 0x077f, 0xa438, 0x0cf0, 0xa438, 0x0c50, 0xa438, 0xd104,
+	0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0aa8, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0x1800, 0xa438, 0x0a2e, 0xa438, 0xcb9b,
+	0xa438, 0xd110, 0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0b7b,
+	0xa438, 0x1000, 0xa438, 0x09df, 0xa438, 0xd700, 0xa438, 0x5fb4,
+	0xa438, 0x1800, 0xa438, 0x081b, 0xa438, 0x1000, 0xa438, 0x09df,
+	0xa438, 0xd704, 0xa438, 0x7fb8, 0xa438, 0xa718, 0xa438, 0x1800,
+	0xa438, 0x074e, 0xa436, 0xA10E, 0xa438, 0xffff, 0xa436, 0xA10C,
+	0xa438, 0xffff, 0xa436, 0xA10A, 0xa438, 0xffff, 0xa436, 0xA108,
+	0xa438, 0xffff, 0xa436, 0xA106, 0xa438, 0x074d, 0xa436, 0xA104,
+	0xa438, 0x0818, 0xa436, 0xA102, 0xa438, 0x0a2c, 0xa436, 0xA100,
+	0xa438, 0x077e, 0xa436, 0xA110, 0xa438, 0x000f, 0xa436, 0xb87c,
+	0xa438, 0x8625, 0xa436, 0xb87e, 0xa438, 0xaf86, 0xa438, 0x3daf,
+	0xa438, 0x8689, 0xa438, 0xaf88, 0xa438, 0x69af, 0xa438, 0x8887,
+	0xa438, 0xaf88, 0xa438, 0x9caf, 0xa438, 0x88be, 0xa438, 0xaf88,
+	0xa438, 0xbeaf, 0xa438, 0x88be, 0xa438, 0xbf86, 0xa438, 0x49d7,
+	0xa438, 0x0040, 0xa438, 0x0277, 0xa438, 0x7daf, 0xa438, 0x2727,
+	0xa438, 0x0000, 0xa438, 0x7205, 0xa438, 0x0000, 0xa438, 0x7208,
+	0xa438, 0x0000, 0xa438, 0x71f3, 0xa438, 0x0000, 0xa438, 0x71f6,
+	0xa438, 0x0000, 0xa438, 0x7229, 0xa438, 0x0000, 0xa438, 0x722c,
+	0xa438, 0x0000, 0xa438, 0x7217, 0xa438, 0x0000, 0xa438, 0x721a,
+	0xa438, 0x0000, 0xa438, 0x721d, 0xa438, 0x0000, 0xa438, 0x7211,
+	0xa438, 0x0000, 0xa438, 0x7220, 0xa438, 0x0000, 0xa438, 0x7214,
+	0xa438, 0x0000, 0xa438, 0x722f, 0xa438, 0x0000, 0xa438, 0x7223,
+	0xa438, 0x0000, 0xa438, 0x7232, 0xa438, 0x0000, 0xa438, 0x7226,
+	0xa438, 0xf8f9, 0xa438, 0xfae0, 0xa438, 0x85b3, 0xa438, 0x3802,
+	0xa438, 0xad27, 0xa438, 0x02ae, 0xa438, 0x03af, 0xa438, 0x8830,
+	0xa438, 0x1f66, 0xa438, 0xef65, 0xa438, 0xbfc2, 0xa438, 0x1f1a,
+	0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00da,
+	0xa438, 0xf605, 0xa438, 0xbfc2, 0xa438, 0x2f1a, 0xa438, 0x96f7,
+	0xa438, 0x05ee, 0xa438, 0xffd2, 0xa438, 0x00db, 0xa438, 0xf605,
+	0xa438, 0xef02, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+	0xa438, 0x4202, 0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1b03,
+	0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4502,
+	0xa438, 0x6e7d, 0xa438, 0xef02, 0xa438, 0x1a03, 0xa438, 0x1f11,
+	0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4802, 0xa438, 0x6e7d,
+	0xa438, 0xbfc2, 0xa438, 0x3f1a, 0xa438, 0x96f7, 0xa438, 0x05ee,
+	0xa438, 0xffd2, 0xa438, 0x00da, 0xa438, 0xf605, 0xa438, 0xbfc2,
+	0xa438, 0x4f1a, 0xa438, 0x96f7, 0xa438, 0x05ee, 0xa438, 0xffd2,
+	0xa438, 0x00db, 0xa438, 0xf605, 0xa438, 0xef02, 0xa438, 0x1f11,
+	0xa438, 0x0d42, 0xa438, 0xbf88, 0xa438, 0x4b02, 0xa438, 0x6e7d,
+	0xa438, 0xef02, 0xa438, 0x1b03, 0xa438, 0x1f11, 0xa438, 0x0d42,
+	0xa438, 0xbf88, 0xa438, 0x4e02, 0xa438, 0x6e7d, 0xa438, 0xef02,
+	0xa438, 0x1a03, 0xa438, 0x1f11, 0xa438, 0x0d42, 0xa438, 0xbf88,
+	0xa438, 0x5102, 0xa438, 0x6e7d, 0xa438, 0xef56, 0xa438, 0xd020,
+	0xa438, 0x1f11, 0xa438, 0xbf88, 0xa438, 0x5402, 0xa438, 0x6e7d,
+	0xa438, 0xbf88, 0xa438, 0x5702, 0xa438, 0x6e7d, 0xa438, 0xbf88,
+	0xa438, 0x5a02, 0xa438, 0x6e7d, 0xa438, 0xe185, 0xa438, 0xa0ef,
+	0xa438, 0x0348, 0xa438, 0x0a28, 0xa438, 0x05ef, 0xa438, 0x201b,
+	0xa438, 0x01ad, 0xa438, 0x2735, 0xa438, 0x1f44, 0xa438, 0xe085,
+	0xa438, 0x88e1, 0xa438, 0x8589, 0xa438, 0xbf88, 0xa438, 0x5d02,
+	0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x8ee1, 0xa438, 0x858f,
+	0xa438, 0xbf88, 0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe085,
+	0xa438, 0x94e1, 0xa438, 0x8595, 0xa438, 0xbf88, 0xa438, 0x6302,
+	0xa438, 0x6e7d, 0xa438, 0xe085, 0xa438, 0x9ae1, 0xa438, 0x859b,
+	0xa438, 0xbf88, 0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88,
+	0xa438, 0x3cbf, 0xa438, 0x883f, 0xa438, 0x026e, 0xa438, 0x9cad,
+	0xa438, 0x2835, 0xa438, 0x1f44, 0xa438, 0xe08f, 0xa438, 0xf8e1,
+	0xa438, 0x8ff9, 0xa438, 0xbf88, 0xa438, 0x5d02, 0xa438, 0x6e7d,
+	0xa438, 0xe08f, 0xa438, 0xfae1, 0xa438, 0x8ffb, 0xa438, 0xbf88,
+	0xa438, 0x6002, 0xa438, 0x6e7d, 0xa438, 0xe08f, 0xa438, 0xfce1,
+	0xa438, 0x8ffd, 0xa438, 0xbf88, 0xa438, 0x6302, 0xa438, 0x6e7d,
+	0xa438, 0xe08f, 0xa438, 0xfee1, 0xa438, 0x8fff, 0xa438, 0xbf88,
+	0xa438, 0x6602, 0xa438, 0x6e7d, 0xa438, 0xaf88, 0xa438, 0x3ce1,
+	0xa438, 0x85a1, 0xa438, 0x1b21, 0xa438, 0xad37, 0xa438, 0x341f,
+	0xa438, 0x44e0, 0xa438, 0x858a, 0xa438, 0xe185, 0xa438, 0x8bbf,
+	0xa438, 0x885d, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8590,
+	0xa438, 0xe185, 0xa438, 0x91bf, 0xa438, 0x8860, 0xa438, 0x026e,
+	0xa438, 0x7de0, 0xa438, 0x8596, 0xa438, 0xe185, 0xa438, 0x97bf,
+	0xa438, 0x8863, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x859c,
+	0xa438, 0xe185, 0xa438, 0x9dbf, 0xa438, 0x8866, 0xa438, 0x026e,
+	0xa438, 0x7dae, 0xa438, 0x401f, 0xa438, 0x44e0, 0xa438, 0x858c,
+	0xa438, 0xe185, 0xa438, 0x8dbf, 0xa438, 0x885d, 0xa438, 0x026e,
+	0xa438, 0x7de0, 0xa438, 0x8592, 0xa438, 0xe185, 0xa438, 0x93bf,
+	0xa438, 0x8860, 0xa438, 0x026e, 0xa438, 0x7de0, 0xa438, 0x8598,
+	0xa438, 0xe185, 0xa438, 0x99bf, 0xa438, 0x8863, 0xa438, 0x026e,
+	0xa438, 0x7de0, 0xa438, 0x859e, 0xa438, 0xe185, 0xa438, 0x9fbf,
+	0xa438, 0x8866, 0xa438, 0x026e, 0xa438, 0x7dae, 0xa438, 0x0ce1,
+	0xa438, 0x85b3, 0xa438, 0x3904, 0xa438, 0xac2f, 0xa438, 0x04ee,
+	0xa438, 0x85b3, 0xa438, 0x00af, 0xa438, 0x39d9, 0xa438, 0x22ac,
+	0xa438, 0xeaf0, 0xa438, 0xacf6, 0xa438, 0xf0ac, 0xa438, 0xfaf0,
+	0xa438, 0xacf8, 0xa438, 0xf0ac, 0xa438, 0xfcf0, 0xa438, 0xad00,
+	0xa438, 0xf0ac, 0xa438, 0xfef0, 0xa438, 0xacf0, 0xa438, 0xf0ac,
+	0xa438, 0xf4f0, 0xa438, 0xacf2, 0xa438, 0xf0ac, 0xa438, 0xb0f0,
+	0xa438, 0xacae, 0xa438, 0xf0ac, 0xa438, 0xacf0, 0xa438, 0xacaa,
+	0xa438, 0xa100, 0xa438, 0x0ce1, 0xa438, 0x8ff7, 0xa438, 0xbf88,
+	0xa438, 0x8402, 0xa438, 0x6e7d, 0xa438, 0xaf26, 0xa438, 0xe9e1,
+	0xa438, 0x8ff6, 0xa438, 0xbf88, 0xa438, 0x8402, 0xa438, 0x6e7d,
+	0xa438, 0xaf26, 0xa438, 0xf520, 0xa438, 0xac86, 0xa438, 0xbf88,
+	0xa438, 0x3f02, 0xa438, 0x6e9c, 0xa438, 0xad28, 0xa438, 0x03af,
+	0xa438, 0x3324, 0xa438, 0xad38, 0xa438, 0x03af, 0xa438, 0x32e6,
+	0xa438, 0xaf32, 0xa438, 0xfbee, 0xa438, 0x826a, 0xa438, 0x0002,
+	0xa438, 0x88a6, 0xa438, 0xaf04, 0xa438, 0x78f8, 0xa438, 0xfaef,
+	0xa438, 0x69e0, 0xa438, 0x8015, 0xa438, 0xad20, 0xa438, 0x06bf,
+	0xa438, 0x88bb, 0xa438, 0x0275, 0xa438, 0xb1ef, 0xa438, 0x96fe,
+	0xa438, 0xfc04, 0xa438, 0x00b8, 0xa438, 0x7a00, 0xa436, 0xb87c,
+	0xa438, 0x8ff6, 0xa436, 0xb87e, 0xa438, 0x0705, 0xa436, 0xb87c,
+	0xa438, 0x8ff8, 0xa436, 0xb87e, 0xa438, 0x19cc, 0xa436, 0xb87c,
+	0xa438, 0x8ffa, 0xa436, 0xb87e, 0xa438, 0x28e3, 0xa436, 0xb87c,
+	0xa438, 0x8ffc, 0xa436, 0xb87e, 0xa438, 0x1047, 0xa436, 0xb87c,
+	0xa438, 0x8ffe, 0xa436, 0xb87e, 0xa438, 0x0a45, 0xa436, 0xb85e,
+	0xa438, 0x271E, 0xa436, 0xb860, 0xa438, 0x3846, 0xa436, 0xb862,
+	0xa438, 0x26E6, 0xa436, 0xb864, 0xa438, 0x32E3, 0xa436, 0xb886,
+	0xa438, 0x0474, 0xa436, 0xb888, 0xa438, 0xffff, 0xa436, 0xb88a,
+	0xa438, 0xffff, 0xa436, 0xb88c, 0xa438, 0xffff, 0xa436, 0xb838,
+	0xa438, 0x001f, 0xb820, 0x0010, 0xa436, 0x846e, 0xa438, 0xaf84,
+	0xa438, 0x86af, 0xa438, 0x8690, 0xa438, 0xaf86, 0xa438, 0xa4af,
+	0xa438, 0x8934, 0xa438, 0xaf89, 0xa438, 0x60af, 0xa438, 0x897e,
+	0xa438, 0xaf89, 0xa438, 0xa9af, 0xa438, 0x89a9, 0xa438, 0xee82,
+	0xa438, 0x5f00, 0xa438, 0x0284, 0xa438, 0x90af, 0xa438, 0x0441,
+	0xa438, 0xf8e0, 0xa438, 0x8ff3, 0xa438, 0xa000, 0xa438, 0x0502,
+	0xa438, 0x84a4, 0xa438, 0xae06, 0xa438, 0xa001, 0xa438, 0x0302,
+	0xa438, 0x84c8, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59,
+	0xa438, 0xe080, 0xa438, 0x15ad, 0xa438, 0x2702, 0xa438, 0xae03,
+	0xa438, 0xaf84, 0xa438, 0xc3bf, 0xa438, 0x53ca, 0xa438, 0x0252,
+	0xa438, 0xc8ad, 0xa438, 0x2807, 0xa438, 0x0285, 0xa438, 0x2cee,
+	0xa438, 0x8ff3, 0xa438, 0x01ef, 0xa438, 0x95fd, 0xa438, 0xfc04,
+	0xa438, 0xf8f9, 0xa438, 0xfaef, 0xa438, 0x69bf, 0xa438, 0x53ca,
+	0xa438, 0x0252, 0xa438, 0xc8ac, 0xa438, 0x2822, 0xa438, 0xd480,
+	0xa438, 0x00bf, 0xa438, 0x8684, 0xa438, 0x0252, 0xa438, 0xa9bf,
+	0xa438, 0x8687, 0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868a,
+	0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868d, 0xa438, 0x0252,
+	0xa438, 0xa9ee, 0xa438, 0x8ff3, 0xa438, 0x00af, 0xa438, 0x8526,
+	0xa438, 0xe08f, 0xa438, 0xf4e1, 0xa438, 0x8ff5, 0xa438, 0xe28f,
+	0xa438, 0xf6e3, 0xa438, 0x8ff7, 0xa438, 0x1b45, 0xa438, 0xac27,
+	0xa438, 0x0eee, 0xa438, 0x8ff4, 0xa438, 0x00ee, 0xa438, 0x8ff5,
+	0xa438, 0x0002, 0xa438, 0x852c, 0xa438, 0xaf85, 0xa438, 0x26e0,
+	0xa438, 0x8ff4, 0xa438, 0xe18f, 0xa438, 0xf52c, 0xa438, 0x0001,
+	0xa438, 0xe48f, 0xa438, 0xf4e5, 0xa438, 0x8ff5, 0xa438, 0xef96,
+	0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef59,
+	0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa18b,
+	0xa438, 0x02ae, 0xa438, 0x03af, 0xa438, 0x85da, 0xa438, 0xbf57,
+	0xa438, 0x7202, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xf8e5,
+	0xa438, 0x8ff9, 0xa438, 0xbf57, 0xa438, 0x7502, 0xa438, 0x52c8,
+	0xa438, 0xe48f, 0xa438, 0xfae5, 0xa438, 0x8ffb, 0xa438, 0xbf57,
+	0xa438, 0x7802, 0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfce5,
+	0xa438, 0x8ffd, 0xa438, 0xbf57, 0xa438, 0x7b02, 0xa438, 0x52c8,
+	0xa438, 0xe48f, 0xa438, 0xfee5, 0xa438, 0x8fff, 0xa438, 0xbf57,
+	0xa438, 0x6c02, 0xa438, 0x52c8, 0xa438, 0xa102, 0xa438, 0x13ee,
+	0xa438, 0x8ffc, 0xa438, 0x80ee, 0xa438, 0x8ffd, 0xa438, 0x00ee,
+	0xa438, 0x8ffe, 0xa438, 0x80ee, 0xa438, 0x8fff, 0xa438, 0x00af,
+	0xa438, 0x8599, 0xa438, 0xa101, 0xa438, 0x0cbf, 0xa438, 0x534c,
+	0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x0303, 0xa438, 0xaf85,
+	0xa438, 0x77bf, 0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1,
+	0xa438, 0x8b02, 0xa438, 0xae03, 0xa438, 0xaf86, 0xa438, 0x64e0,
+	0xa438, 0x8ff8, 0xa438, 0xe18f, 0xa438, 0xf9bf, 0xa438, 0x8684,
+	0xa438, 0x0252, 0xa438, 0xa9e0, 0xa438, 0x8ffa, 0xa438, 0xe18f,
+	0xa438, 0xfbbf, 0xa438, 0x8687, 0xa438, 0x0252, 0xa438, 0xa9e0,
+	0xa438, 0x8ffc, 0xa438, 0xe18f, 0xa438, 0xfdbf, 0xa438, 0x868a,
+	0xa438, 0x0252, 0xa438, 0xa9e0, 0xa438, 0x8ffe, 0xa438, 0xe18f,
+	0xa438, 0xffbf, 0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9af,
+	0xa438, 0x867f, 0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8,
+	0xa438, 0xa144, 0xa438, 0x3cbf, 0xa438, 0x547b, 0xa438, 0x0252,
+	0xa438, 0xc8e4, 0xa438, 0x8ff8, 0xa438, 0xe58f, 0xa438, 0xf9bf,
+	0xa438, 0x547e, 0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffa,
+	0xa438, 0xe58f, 0xa438, 0xfbbf, 0xa438, 0x5481, 0xa438, 0x0252,
+	0xa438, 0xc8e4, 0xa438, 0x8ffc, 0xa438, 0xe58f, 0xa438, 0xfdbf,
+	0xa438, 0x5484, 0xa438, 0x0252, 0xa438, 0xc8e4, 0xa438, 0x8ffe,
+	0xa438, 0xe58f, 0xa438, 0xffbf, 0xa438, 0x5322, 0xa438, 0x0252,
+	0xa438, 0xc8a1, 0xa438, 0x4448, 0xa438, 0xaf85, 0xa438, 0xa7bf,
+	0xa438, 0x5322, 0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x313c,
+	0xa438, 0xbf54, 0xa438, 0x7b02, 0xa438, 0x52c8, 0xa438, 0xe48f,
+	0xa438, 0xf8e5, 0xa438, 0x8ff9, 0xa438, 0xbf54, 0xa438, 0x7e02,
+	0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfae5, 0xa438, 0x8ffb,
+	0xa438, 0xbf54, 0xa438, 0x8102, 0xa438, 0x52c8, 0xa438, 0xe48f,
+	0xa438, 0xfce5, 0xa438, 0x8ffd, 0xa438, 0xbf54, 0xa438, 0x8402,
+	0xa438, 0x52c8, 0xa438, 0xe48f, 0xa438, 0xfee5, 0xa438, 0x8fff,
+	0xa438, 0xbf53, 0xa438, 0x2202, 0xa438, 0x52c8, 0xa438, 0xa131,
+	0xa438, 0x03af, 0xa438, 0x85a7, 0xa438, 0xd480, 0xa438, 0x00bf,
+	0xa438, 0x8684, 0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x8687,
+	0xa438, 0x0252, 0xa438, 0xa9bf, 0xa438, 0x868a, 0xa438, 0x0252,
+	0xa438, 0xa9bf, 0xa438, 0x868d, 0xa438, 0x0252, 0xa438, 0xa9ef,
+	0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf0d1, 0xa438, 0x2af0,
+	0xa438, 0xd12c, 0xa438, 0xf0d1, 0xa438, 0x44f0, 0xa438, 0xd146,
+	0xa438, 0xbf86, 0xa438, 0xa102, 0xa438, 0x52c8, 0xa438, 0xbf86,
+	0xa438, 0xa102, 0xa438, 0x52c8, 0xa438, 0xd101, 0xa438, 0xaf06,
+	0xa438, 0xa570, 0xa438, 0xce42, 0xa438, 0xee83, 0xa438, 0xc800,
+	0xa438, 0x0286, 0xa438, 0xba02, 0xa438, 0x8728, 0xa438, 0x0287,
+	0xa438, 0xbe02, 0xa438, 0x87f9, 0xa438, 0x0288, 0xa438, 0xc3af,
+	0xa438, 0x4771, 0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef69,
+	0xa438, 0xfae0, 0xa438, 0x8015, 0xa438, 0xad25, 0xa438, 0x45d2,
+	0xa438, 0x0002, 0xa438, 0x8714, 0xa438, 0xac4f, 0xa438, 0x02ae,
+	0xa438, 0x0bef, 0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x0400,
+	0xa438, 0xab26, 0xa438, 0xae30, 0xa438, 0xe08f, 0xa438, 0xe9e1,
+	0xa438, 0x8fea, 0xa438, 0x1b46, 0xa438, 0xab26, 0xa438, 0xef32,
+	0xa438, 0x0c31, 0xa438, 0xbf8f, 0xa438, 0xe91a, 0xa438, 0x93d8,
+	0xa438, 0x19d9, 0xa438, 0x1b46, 0xa438, 0xab0a, 0xa438, 0x19d8,
+	0xa438, 0x19d9, 0xa438, 0x1b46, 0xa438, 0xaa02, 0xa438, 0xae0c,
+	0xa438, 0xbf57, 0xa438, 0x1202, 0xa438, 0x58b1, 0xa438, 0xbf57,
+	0xa438, 0x1202, 0xa438, 0x58a8, 0xa438, 0xfeef, 0xa438, 0x96ff,
+	0xa438, 0xfefd, 0xa438, 0xfc04, 0xa438, 0xf8fb, 0xa438, 0xef79,
+	0xa438, 0xa200, 0xa438, 0x08bf, 0xa438, 0x892e, 0xa438, 0x0252,
+	0xa438, 0xc8ef, 0xa438, 0x64ef, 0xa438, 0x97ff, 0xa438, 0xfc04,
+	0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef69, 0xa438, 0xfae0,
+	0xa438, 0x8015, 0xa438, 0xad25, 0xa438, 0x50d2, 0xa438, 0x0002,
+	0xa438, 0x878d, 0xa438, 0xac4f, 0xa438, 0x02ae, 0xa438, 0x0bef,
+	0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x1000, 0xa438, 0xab31,
+	0xa438, 0xae29, 0xa438, 0xe08f, 0xa438, 0xede1, 0xa438, 0x8fee,
+	0xa438, 0x1b46, 0xa438, 0xab1f, 0xa438, 0xa200, 0xa438, 0x04ef,
+	0xa438, 0x32ae, 0xa438, 0x02d3, 0xa438, 0x010c, 0xa438, 0x31bf,
+	0xa438, 0x8fed, 0xa438, 0x1a93, 0xa438, 0xd819, 0xa438, 0xd91b,
+	0xa438, 0x46ab, 0xa438, 0x0e19, 0xa438, 0xd819, 0xa438, 0xd91b,
+	0xa438, 0x46aa, 0xa438, 0x0612, 0xa438, 0xa205, 0xa438, 0xc0ae,
+	0xa438, 0x0cbf, 0xa438, 0x5712, 0xa438, 0x0258, 0xa438, 0xb1bf,
+	0xa438, 0x5712, 0xa438, 0x0258, 0xa438, 0xa8fe, 0xa438, 0xef96,
+	0xa438, 0xfffe, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xfbef,
+	0xa438, 0x79a2, 0xa438, 0x0005, 0xa438, 0xbf89, 0xa438, 0x1fae,
+	0xa438, 0x1ba2, 0xa438, 0x0105, 0xa438, 0xbf89, 0xa438, 0x22ae,
+	0xa438, 0x13a2, 0xa438, 0x0205, 0xa438, 0xbf89, 0xa438, 0x25ae,
+	0xa438, 0x0ba2, 0xa438, 0x0305, 0xa438, 0xbf89, 0xa438, 0x28ae,
+	0xa438, 0x03bf, 0xa438, 0x892b, 0xa438, 0x0252, 0xa438, 0xc8ef,
+	0xa438, 0x64ef, 0xa438, 0x97ff, 0xa438, 0xfc04, 0xa438, 0xf8f9,
+	0xa438, 0xfaef, 0xa438, 0x69fa, 0xa438, 0xe080, 0xa438, 0x15ad,
+	0xa438, 0x2628, 0xa438, 0xe081, 0xa438, 0xabe1, 0xa438, 0x81ac,
+	0xa438, 0xef64, 0xa438, 0xbf57, 0xa438, 0x1802, 0xa438, 0x52c8,
+	0xa438, 0x1b46, 0xa438, 0xaa0a, 0xa438, 0xbf57, 0xa438, 0x1b02,
+	0xa438, 0x52c8, 0xa438, 0x1b46, 0xa438, 0xab0c, 0xa438, 0xbf57,
+	0xa438, 0x1502, 0xa438, 0x58b1, 0xa438, 0xbf57, 0xa438, 0x1502,
+	0xa438, 0x58a8, 0xa438, 0xfeef, 0xa438, 0x96fe, 0xa438, 0xfdfc,
+	0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x59f9, 0xa438, 0xe080,
+	0xa438, 0x15ad, 0xa438, 0x2622, 0xa438, 0xbf53, 0xa438, 0x2202,
+	0xa438, 0x52c8, 0xa438, 0x3972, 0xa438, 0x9e10, 0xa438, 0xe083,
+	0xa438, 0xc9ac, 0xa438, 0x2605, 0xa438, 0x0288, 0xa438, 0x2cae,
+	0xa438, 0x0d02, 0xa438, 0x8870, 0xa438, 0xae08, 0xa438, 0xe283,
+	0xa438, 0xc9f6, 0xa438, 0x36e6, 0xa438, 0x83c9, 0xa438, 0xfdef,
+	0xa438, 0x95fd, 0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xfafb,
+	0xa438, 0xef79, 0xa438, 0xfbbf, 0xa438, 0x5718, 0xa438, 0x0252,
+	0xa438, 0xc8ef, 0xa438, 0x64e2, 0xa438, 0x8fe5, 0xa438, 0xe38f,
+	0xa438, 0xe61b, 0xa438, 0x659e, 0xa438, 0x10e4, 0xa438, 0x8fe5,
+	0xa438, 0xe58f, 0xa438, 0xe6e2, 0xa438, 0x83c9, 0xa438, 0xf636,
+	0xa438, 0xe683, 0xa438, 0xc9ae, 0xa438, 0x13e2, 0xa438, 0x83c9,
+	0xa438, 0xf736, 0xa438, 0xe683, 0xa438, 0xc902, 0xa438, 0x5820,
+	0xa438, 0xef57, 0xa438, 0xe68f, 0xa438, 0xe7e7, 0xa438, 0x8fe8,
+	0xa438, 0xffef, 0xa438, 0x97ff, 0xa438, 0xfefd, 0xa438, 0xfc04,
+	0xa438, 0xf8f9, 0xa438, 0xfafb, 0xa438, 0xef79, 0xa438, 0xfbe2,
+	0xa438, 0x8fe7, 0xa438, 0xe38f, 0xa438, 0xe8ef, 0xa438, 0x65e2,
+	0xa438, 0x81b8, 0xa438, 0xe381, 0xa438, 0xb9ef, 0xa438, 0x7502,
+	0xa438, 0x583b, 0xa438, 0xac50, 0xa438, 0x1abf, 0xa438, 0x5718,
+	0xa438, 0x0252, 0xa438, 0xc8ef, 0xa438, 0x64e2, 0xa438, 0x8fe5,
+	0xa438, 0xe38f, 0xa438, 0xe61b, 0xa438, 0x659e, 0xa438, 0x1ce4,
+	0xa438, 0x8fe5, 0xa438, 0xe58f, 0xa438, 0xe6ae, 0xa438, 0x0cbf,
+	0xa438, 0x5715, 0xa438, 0x0258, 0xa438, 0xb1bf, 0xa438, 0x5715,
+	0xa438, 0x0258, 0xa438, 0xa8e2, 0xa438, 0x83c9, 0xa438, 0xf636,
+	0xa438, 0xe683, 0xa438, 0xc9ff, 0xa438, 0xef97, 0xa438, 0xfffe,
+	0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xf9fa, 0xa438, 0xef69,
+	0xa438, 0xe080, 0xa438, 0x15ad, 0xa438, 0x264b, 0xa438, 0xbf53,
+	0xa438, 0xca02, 0xa438, 0x52c8, 0xa438, 0xad28, 0xa438, 0x42bf,
+	0xa438, 0x8931, 0xa438, 0x0252, 0xa438, 0xc8ef, 0xa438, 0x54bf,
+	0xa438, 0x576c, 0xa438, 0x0252, 0xa438, 0xc8a1, 0xa438, 0x001b,
+	0xa438, 0xbf53, 0xa438, 0x4c02, 0xa438, 0x52c8, 0xa438, 0xac29,
+	0xa438, 0x0dac, 0xa438, 0x2805, 0xa438, 0xa302, 0xa438, 0x16ae,
+	0xa438, 0x20a3, 0xa438, 0x0311, 0xa438, 0xae1b, 0xa438, 0xa304,
+	0xa438, 0x0cae, 0xa438, 0x16a3, 0xa438, 0x0802, 0xa438, 0xae11,
+	0xa438, 0xa309, 0xa438, 0x02ae, 0xa438, 0x0cbf, 0xa438, 0x5715,
+	0xa438, 0x0258, 0xa438, 0xb1bf, 0xa438, 0x5715, 0xa438, 0x0258,
+	0xa438, 0xa8ef, 0xa438, 0x96fe, 0xa438, 0xfdfc, 0xa438, 0x04f0,
+	0xa438, 0xa300, 0xa438, 0xf0a3, 0xa438, 0x02f0, 0xa438, 0xa304,
+	0xa438, 0xf0a3, 0xa438, 0x06f0, 0xa438, 0xa308, 0xa438, 0xf0a2,
+	0xa438, 0x8074, 0xa438, 0xa600, 0xa438, 0xac4f, 0xa438, 0x02ae,
+	0xa438, 0x0bef, 0xa438, 0x46f6, 0xa438, 0x273c, 0xa438, 0x1000,
+	0xa438, 0xab1b, 0xa438, 0xae16, 0xa438, 0xe081, 0xa438, 0xabe1,
+	0xa438, 0x81ac, 0xa438, 0x1b46, 0xa438, 0xab0c, 0xa438, 0xac32,
+	0xa438, 0x04ef, 0xa438, 0x32ae, 0xa438, 0x02d3, 0xa438, 0x04af,
+	0xa438, 0x486c, 0xa438, 0xaf48, 0xa438, 0x82af, 0xa438, 0x4888,
+	0xa438, 0xe081, 0xa438, 0x9be1, 0xa438, 0x819c, 0xa438, 0xe28f,
+	0xa438, 0xe3ad, 0xa438, 0x3009, 0xa438, 0x1f55, 0xa438, 0xe38f,
+	0xa438, 0xe20c, 0xa438, 0x581a, 0xa438, 0x45e4, 0xa438, 0x83a6,
+	0xa438, 0xe583, 0xa438, 0xa7af, 0xa438, 0x2a75, 0xa438, 0xe08f,
+	0xa438, 0xe3ad, 0xa438, 0x201c, 0xa438, 0x1f44, 0xa438, 0xe18f,
+	0xa438, 0xe10c, 0xa438, 0x44ef, 0xa438, 0x64e0, 0xa438, 0x8232,
+	0xa438, 0xe182, 0xa438, 0x331b, 0xa438, 0x649f, 0xa438, 0x091f,
+	0xa438, 0x44e1, 0xa438, 0x8fe2, 0xa438, 0x0c48, 0xa438, 0x1b54,
+	0xa438, 0xe683, 0xa438, 0xa6e7, 0xa438, 0x83a7, 0xa438, 0xaf2b,
+	0xa438, 0xd900, 0xa436, 0xb818, 0xa438, 0x043d, 0xa436, 0xb81a,
+	0xa438, 0x06a3, 0xa436, 0xb81c, 0xa438, 0x476d, 0xa436, 0xb81e,
+	0xa438, 0x4852, 0xa436, 0xb850, 0xa438, 0x2A69, 0xa436, 0xb852,
+	0xa438, 0x2BD3, 0xa436, 0xb878, 0xa438, 0xffff, 0xa436, 0xb884,
+	0xa438, 0xffff, 0xa436, 0xb832, 0xa438, 0x003f, 0xb844, 0xffff,
+	0xa436, 0x8fe9, 0xa438, 0x0000, 0xa436, 0x8feb, 0xa438, 0x02fe,
+	0xa436, 0x8fed, 0xa438, 0x0019, 0xa436, 0x8fef, 0xa438, 0x0bdb,
+	0xa436, 0x8ff1, 0xa438, 0x0ca4, 0xa436, 0x0000, 0xa438, 0x0000,
+	0xa436, 0xB82E, 0xa438, 0x0000, 0xa436, 0x8024, 0xa438, 0x0000,
+	0xa436, 0x801E, 0xa438, 0x0024, 0xb820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static void
+rtl8125_real_set_phy_mcu_8125b_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125b_1,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125b_1));
+}
+
+void
+rtl8125_set_phy_mcu_8125b_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125b_1(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125b_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125b_2,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125b_2));
+}
+
+void
+rtl8125_set_phy_mcu_8125b_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125b_2(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125b_mcu.h
@@ -0,0 +1,14 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _RTL8125B_MCU_H_
+#define _RTL8125B_MCU_H_
+
+void rtl8125_set_mac_mcu_8125b_1(struct rtl8125_hw *hw);
+void rtl8125_set_mac_mcu_8125b_2(struct rtl8125_hw *hw);
+
+void rtl8125_set_phy_mcu_8125b_1(struct rtl8125_hw *hw);
+void rtl8125_set_phy_mcu_8125b_2(struct rtl8125_hw *hw);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125bp.c
@@ -0,0 +1,115 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125bp_mcu.h"
+
+/* For RTL8125BP, CFG_METHOD_8,9 */
+
+static void
+hw_init_rxcfg_8125bp(struct rtl8125_hw *hw)
+{
+	RTL_W32(hw, RxConfig, Rx_Fetch_Number_8 | Rx_Close_Multiple |
+	        RxCfg_pause_slot_en | (RX_DMA_BURST_256 << RxCfgDMAShift));
+}
+
+static void
+hw_ephy_config_8125bp(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		/* Nothing to do */
+		break;
+	}
+}
+
+static void
+rtl8125_hw_phy_config_8125bp_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA80C, BIT_14,
+	                                      (BIT_15 | BIT_11 | BIT_10));
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8010);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, BIT_11);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8088);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x9000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x808F);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x9000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8174);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, BIT_13, (BIT_12 | BIT_11));
+}
+
+static void
+rtl8125_hw_phy_config_8125bp_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8010);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, BIT_11);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8088);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x9000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x808F);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x9000);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8174);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, BIT_13, (BIT_12 | BIT_11));
+}
+
+static void
+hw_phy_config_8125bp(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_8:
+		rtl8125_hw_phy_config_8125bp_1(hw);
+		break;
+	case CFG_METHOD_9:
+		rtl8125_hw_phy_config_8125bp_2(hw);
+		break;
+	}
+}
+
+static void
+hw_mac_mcu_config_8125bp(struct rtl8125_hw *hw)
+{
+	if (hw->NotWrMcuPatchCode == TRUE)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_8:
+		rtl8125_set_mac_mcu_8125bp_1(hw);
+		break;
+	case CFG_METHOD_9:
+		rtl8125_set_mac_mcu_8125bp_2(hw);
+		break;
+	}
+}
+
+static void
+hw_phy_mcu_config_8125bp(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_8:
+		rtl8125_set_phy_mcu_8125bp_1(hw);
+		break;
+	case CFG_METHOD_9:
+		/* Nothing to do */
+		break;
+	}
+}
+
+const struct rtl8125_hw_ops rtl8125bp_ops = {
+	.hw_init_rxcfg     = hw_init_rxcfg_8125bp,
+	.hw_ephy_config    = hw_ephy_config_8125bp,
+	.hw_phy_config     = hw_phy_config_8125bp,
+	.hw_mac_mcu_config = hw_mac_mcu_config_8125bp,
+	.hw_phy_mcu_config = hw_phy_mcu_config_8125bp,
+};
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125bp_mcu.c
@@ -0,0 +1,288 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125bp_mcu.h"
+
+/* For RTL8125BP, CFG_METHOD_8,9 */
+
+/* ------------------------------------MAC 8125BP------------------------------------- */
+
+void
+rtl8125_set_mac_mcu_8125bp_1(struct rtl8125_hw *hw)
+{
+	static const u16 mcu_patch_code_8125bp_1[] = {
+		0xE003, 0xE007, 0xE01A, 0x1BC8, 0x46EB, 0xC302, 0xBB00, 0x0F14, 0xC211,
+		0x400A, 0xF00A, 0xC20F, 0x400A, 0xF007, 0x73A4, 0xC20C, 0x400A, 0xF102,
+		0x48B0, 0x9B20, 0x1B00, 0x9BA0, 0xC602, 0xBE00, 0x4364, 0xE6E0, 0xE6E2,
+		0xC01C, 0xB406, 0x1000, 0xF016, 0xC61F, 0x400E, 0xF012, 0x218E, 0x25BE,
+		0x1300, 0xF007, 0x7340, 0xC618, 0x400E, 0xF102, 0x48B0, 0x8320, 0xB400,
+		0x2402, 0x1000, 0xF003, 0x7342, 0x8322, 0xB000, 0xE007, 0x7322, 0x9B42,
+		0x7320, 0x9B40, 0x0300, 0x0300, 0xB006, 0xC302, 0xBB00, 0x413E, 0xE6E0,
+		0xC01C, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x1171, 0x0B17, 0x0816, 0x1108
+	};
+
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+
+	rtl8125_write_mac_mcu_ram_code(hw, mcu_patch_code_8125bp_1,
+	                               ARRAY_SIZE(mcu_patch_code_8125bp_1));
+
+	rtl8125_mac_ocp_write(hw, 0xFC26, 0x8000);
+
+	rtl8125_mac_ocp_write(hw, 0xFC28, 0x0f10);
+	rtl8125_mac_ocp_write(hw, 0xFC2A, 0x435c);
+	rtl8125_mac_ocp_write(hw, 0xFC2C, 0x4112);
+
+	rtl8125_mac_ocp_write(hw, 0xFC48, 0x0007);
+}
+
+void
+rtl8125_set_mac_mcu_8125bp_2(struct rtl8125_hw *hw)
+{
+	static const u16 mcu_patch_code_8125bp_2[] = {
+		0xE010, 0xE033, 0xE046, 0xE04A, 0xE04C, 0xE04E, 0xE050, 0xE052, 0xE054,
+		0xE056, 0xE058, 0xE05A, 0xE05C, 0xE05E, 0xE060, 0xE062, 0xB406, 0x1000,
+		0xF016, 0xC61F, 0x400E, 0xF012, 0x218E, 0x25BE, 0x1300, 0xF007, 0x7340,
+		0xC618, 0x400E, 0xF102, 0x48B0, 0x8320, 0xB400, 0x2402, 0x1000, 0xF003,
+		0x7342, 0x8322, 0xB000, 0xE007, 0x7322, 0x9B42, 0x7320, 0x9B40, 0x0300,
+		0x0300, 0xB006, 0xC302, 0xBB00, 0x4168, 0xE6E0, 0xC01C, 0xC211, 0x400A,
+		0xF00A, 0xC20F, 0x400A, 0xF007, 0x73A4, 0xC20C, 0x400A, 0xF102, 0x48B0,
+		0x9B20, 0x1B00, 0x9BA0, 0xC602, 0xBE00, 0x4392, 0xE6E0, 0xE6E2, 0xC01C,
+		0x4166, 0x9CF6, 0xC002, 0xB800, 0x143C, 0xC602, 0xBE00, 0x0000, 0xC602,
+		0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC102,
+		0xB900, 0x0000, 0xC002, 0xB800, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+		0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602,
+		0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0xC602, 0xBE00, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x1171,
+		0x0B18, 0x030D, 0x0A2A
+	};
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+	rtl8125_write_mac_mcu_ram_code(hw, mcu_patch_code_8125bp_2,
+	                               ARRAY_SIZE(mcu_patch_code_8125bp_2));
+	rtl8125_mac_ocp_write(hw, 0xFC26, 0x8000);
+	rtl8125_mac_ocp_write(hw, 0xFC28, 0x413C);
+	rtl8125_mac_ocp_write(hw, 0xFC2A, 0x438A);
+	rtl8125_mac_ocp_write(hw, 0xFC2C, 0x143A);
+	rtl8125_mac_ocp_write(hw, 0xFC48, 0x0007);
+}
+
+/* ------------------------------------PHY 8125BP--------------------------------------- */
+
+static const u16 phy_mcu_ram_code_8125bp_1_1[] = {
+	0xa436, 0x8024, 0xa438, 0x3600, 0xa436, 0xB82E, 0xa438, 0x0001,
+	0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x8014, 0xa438, 0x1800, 0xa438, 0x8018,
+	0xa438, 0x1800, 0xa438, 0x801c, 0xa438, 0x1800, 0xa438, 0x8020,
+	0xa438, 0x1800, 0xa438, 0x8024, 0xa438, 0x1800, 0xa438, 0x8028,
+	0xa438, 0x1800, 0xa438, 0x8028, 0xa438, 0xdb20, 0xa438, 0xd501,
+	0xa438, 0x1800, 0xa438, 0x034c, 0xa438, 0xdb10, 0xa438, 0xd501,
+	0xa438, 0x1800, 0xa438, 0x032c, 0xa438, 0x8620, 0xa438, 0xa480,
+	0xa438, 0x1800, 0xa438, 0x1cfe, 0xa438, 0xbf40, 0xa438, 0xd703,
+	0xa438, 0x1800, 0xa438, 0x0ce9, 0xa438, 0x9c10, 0xa438, 0x9f40,
+	0xa438, 0x1800, 0xa438, 0x137a, 0xa438, 0x9f20, 0xa438, 0x9f40,
+	0xa438, 0x1800, 0xa438, 0x16c4, 0xa436, 0xA026, 0xa438, 0xffff,
+	0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022, 0xa438, 0x16c3,
+	0xa436, 0xA020, 0xa438, 0x1379, 0xa436, 0xA006, 0xa438, 0x0ce8,
+	0xa436, 0xA004, 0xa438, 0x1cfd, 0xa436, 0xA002, 0xa438, 0x032b,
+	0xa436, 0xA000, 0xa438, 0x034b, 0xa436, 0xA008, 0xa438, 0x3f00,
+	0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000,
+	0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800,
+	0xa438, 0x8018, 0xa438, 0x1800, 0xa438, 0x8021, 0xa438, 0x1800,
+	0xa438, 0x802b, 0xa438, 0x1800, 0xa438, 0x8055, 0xa438, 0x1800,
+	0xa438, 0x805a, 0xa438, 0x1800, 0xa438, 0x805e, 0xa438, 0x1800,
+	0xa438, 0x8062, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xcb11,
+	0xa438, 0xd1b9, 0xa438, 0xd05b, 0xa438, 0x0000, 0xa438, 0x1800,
+	0xa438, 0x0284, 0xa438, 0x0000, 0xa438, 0x0000, 0xa438, 0xd700,
+	0xa438, 0x5fb4, 0xa438, 0x5f95, 0xa438, 0x0000, 0xa438, 0x0000,
+	0xa438, 0x1800, 0xa438, 0x02b7, 0xa438, 0x0000, 0xa438, 0x0000,
+	0xa438, 0xcb21, 0xa438, 0x1000, 0xa438, 0x0b34, 0xa438, 0xd71f,
+	0xa438, 0x5f5e, 0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x0322,
+	0xa438, 0xd700, 0xa438, 0xd113, 0xa438, 0xd040, 0xa438, 0x1000,
+	0xa438, 0x0a57, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xd700,
+	0xa438, 0x6065, 0xa438, 0xd122, 0xa438, 0xf002, 0xa438, 0xd122,
+	0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0b53, 0xa438, 0xa008,
+	0xa438, 0xd704, 0xa438, 0x4052, 0xa438, 0xa002, 0xa438, 0xd704,
+	0xa438, 0x4054, 0xa438, 0xa740, 0xa438, 0x1000, 0xa438, 0x0a57,
+	0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0xcb9b, 0xa438, 0xd110,
+	0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x0c01, 0xa438, 0x1000,
+	0xa438, 0x0a57, 0xa438, 0xd700, 0xa438, 0x5fb4, 0xa438, 0x801a,
+	0xa438, 0x1000, 0xa438, 0x0a57, 0xa438, 0xd704, 0xa438, 0x7fb9,
+	0xa438, 0x1800, 0xa438, 0x088d, 0xa438, 0xcb62, 0xa438, 0xd700,
+	0xa438, 0x8880, 0xa438, 0x1800, 0xa438, 0x06cb, 0xa438, 0xbe02,
+	0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa438, 0xbe04,
+	0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa438, 0xbe08,
+	0xa438, 0x0000, 0xa438, 0x1800, 0xa438, 0x002c, 0xa436, 0xA10E,
+	0xa438, 0x802a, 0xa436, 0xA10C, 0xa438, 0x8026, 0xa436, 0xA10A,
+	0xa438, 0x8022, 0xa436, 0xA108, 0xa438, 0x06ca, 0xa436, 0xA106,
+	0xa438, 0x086f, 0xa436, 0xA104, 0xa438, 0x0321, 0xa436, 0xA102,
+	0xa438, 0x02b5, 0xa436, 0xA100, 0xa438, 0x0283, 0xa436, 0xA110,
+	0xa438, 0x001f, 0xb820, 0x0010, 0xb82e, 0x0000, 0xa436, 0x8024,
+	0xa438, 0x0000, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static const u16 phy_mcu_ram_code_8125bp_1_2[] = {
+	0xb892, 0x0000, 0xb88e, 0xC201, 0xb890, 0x2C01, 0xb890, 0xCD02,
+	0xb890, 0x0602, 0xb890, 0x5502, 0xb890, 0xB903, 0xb890, 0x3303,
+	0xb890, 0xC204, 0xb890, 0x6605, 0xb890, 0x1F05, 0xb890, 0xEE06,
+	0xb890, 0xD207, 0xb890, 0xCC08, 0xb890, 0xDA09, 0xb890, 0xFF0B,
+	0xb890, 0x380C, 0xb890, 0x87F3, 0xb88e, 0xC27F, 0xb890, 0x2B66,
+	0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666,
+	0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x6666, 0xb890, 0x66C2,
+	0xb88e, 0xC26F, 0xb890, 0x751D, 0xb890, 0x1D1F, 0xb890, 0x2022,
+	0xb890, 0x2325, 0xb890, 0x2627, 0xb890, 0x2829, 0xb890, 0x2929,
+	0xb890, 0x2A2A, 0xb890, 0x2B66, 0xB820, 0x0000, 0xFFFF, 0xFFFF
+};
+
+static void
+rtl8125_real_set_phy_mcu_8125bp_1_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125bp_1_1,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125bp_1_1));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125bp_1_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125bp_1_2,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125bp_1_2));
+}
+
+void
+rtl8125_set_phy_mcu_8125bp_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125bp_1_1(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125bp_1_2(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125bp_mcu.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _RTL8125BP_MCU_H_
+#define _RTL8125BP_MCU_H_
+
+void rtl8125_set_mac_mcu_8125bp_1(struct rtl8125_hw *hw);
+void rtl8125_set_mac_mcu_8125bp_2(struct rtl8125_hw *hw);
+
+void rtl8125_set_phy_mcu_8125bp_1(struct rtl8125_hw *hw);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125d.c
@@ -0,0 +1,246 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125d_mcu.h"
+
+/* For RTL8125D, CFG_METHOD_10,11 */
+
+static void
+hw_init_rxcfg_8125d(struct rtl8125_hw *hw)
+{
+	RTL_W32(hw, RxConfig, Rx_Fetch_Number_8 | Rx_Close_Multiple |
+	        RxCfg_pause_slot_en | (RX_DMA_BURST_256 << RxCfgDMAShift));
+}
+
+static void
+hw_ephy_config_8125d(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		/* Nothing to do */
+		break;
+	}
+}
+
+static void
+rtl8125_hw_phy_config_8125d_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBF96, BIT_15);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF94, 0x0007, 0x0005);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF8E, 0x3C00, 0x2800);
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBCD8, 0xC000, 0x4000);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBCD8, (BIT_15 | BIT_14));
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBCD8, 0xC000, 0x4000);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC80, 0x001F, 0x0004);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBC82, (BIT_15 | BIT_14 | BIT_13));
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBC82, (BIT_12 | BIT_11 | BIT_10));
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC80, 0x001F, 0x0005);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC82, 0x00E0, 0x0040);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xBC82, (BIT_4 | BIT_3 | BIT_2));
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xBCD8, (BIT_15 | BIT_14));
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBCD8, 0xC000, 0x8000);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xBCD8, (BIT_15 | BIT_14));
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x832C);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0500);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB106, 0x0700, 0x0100);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB206, 0x0700, 0x0200);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB306, 0x0700, 0x0300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x80CB);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0300);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBCF4, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBCF6, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBC12, 0x0000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x844d);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0200);
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8feb);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0100);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xB87C, 0x8fe9);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xB87E, 0xFF00, 0x0600);
+	}
+
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xAD40, (BIT_5 | BIT_4));
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD66, 0x000F, 0x0007);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD68, 0xF000, 0x8000);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD68, 0x0F00, 0x0500);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD68, 0x000F, 0x0002);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xAD6A, 0xF000, 0x7000);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xAC50, 0x01E8);
+
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x81FA);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x5400);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA864, 0x00F0, 0x00C0);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA42C, 0x00FF, 0x0002);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80E1);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x0F00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80DE);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xF000, 0x0700);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA846, BIT_7);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80BA);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8A04);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80BD);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xCA00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80B7);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xB300);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80CE);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8A04);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80D1);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xCA00);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80CB);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0xBB00);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A6);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x4909);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x80A8);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x05B8);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8200);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x5800);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF1);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7078);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF3);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x5D78);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF5);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x7862);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FF7);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1400);
+
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x814C);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x8455);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x814E);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x84A6);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8163);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x0600);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x816A);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x0500);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8171);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1f00);
+	}
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBC3A, 0x000F, 0x0006);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8064);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8067);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x806A);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x806D);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8070);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8073);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8076);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8079);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x807C);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x807F);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA438, (BIT_10 | BIT_9 | BIT_8));
+
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBFA0, 0xFF70, 0x5500);
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xBFA2, 0x9D00);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8165);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0x0700, 0x0200);
+
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8019);
+		rtl8125_set_eth_phy_ocp_bit(hw, 0xA438, BIT_8);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8FE3);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0005);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0000);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x00ED);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0502);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0x0B00);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, 0xD401);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x2900);
+	}
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x8018);
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1700);
+
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw)) {
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x815B);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xA438, 0xFF00, 0x1700);
+	}
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA430, BIT_12 | BIT_0);
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_7);
+}
+
+static void
+rtl8125_hw_phy_config_8125d_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xA442, BIT_11);
+}
+
+static void
+hw_phy_config_8125d(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_10:
+		rtl8125_hw_phy_config_8125d_1(hw);
+		break;
+	case CFG_METHOD_11:
+		rtl8125_hw_phy_config_8125d_2(hw);
+		break;
+	}
+}
+
+static void
+hw_mac_mcu_config_8125d(struct rtl8125_hw *hw)
+{
+	if (hw->NotWrMcuPatchCode == TRUE)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_10:
+		rtl8125_set_mac_mcu_8125d_1(hw);
+		break;
+	case CFG_METHOD_11:
+		rtl8125_set_mac_mcu_8125d_2(hw);
+		break;
+	}
+}
+
+static void
+hw_phy_mcu_config_8125d(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_10:
+		rtl8125_set_phy_mcu_8125d_1(hw);
+		break;
+	case CFG_METHOD_11:
+		/* Nothing to do */
+		break;
+	}
+}
+
+const struct rtl8125_hw_ops rtl8125d_ops = {
+	.hw_init_rxcfg     = hw_init_rxcfg_8125d,
+	.hw_ephy_config    = hw_ephy_config_8125d,
+	.hw_phy_config     = hw_phy_config_8125d,
+	.hw_mac_mcu_config = hw_mac_mcu_config_8125d,
+	.hw_phy_mcu_config = hw_phy_mcu_config_8125d,
+};
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125d_mcu.c
@@ -0,0 +1,617 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include "../r8125_ethdev.h"
+#include "../r8125_hw.h"
+#include "../r8125_phy.h"
+#include "rtl8125d_mcu.h"
+
+/* For RTL8125D, CFG_METHOD_10,11 */
+
+/* ------------------------------------MAC 8125D------------------------------------- */
+
+void
+rtl8125_set_mac_mcu_8125d_1(struct rtl8125_hw *hw)
+{
+	static const u16 mcu_patch_code_8125d_1[] = {
+		0xE002, 0xE006, 0x4166, 0x9CF6, 0xC002, 0xB800, 0x14A4, 0xC102, 0xB900,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
+		0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x6938,
+		0x0A18, 0x0217, 0x0D2A
+	};
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+	rtl8125_write_mac_mcu_ram_code(hw, mcu_patch_code_8125d_1,
+	                               ARRAY_SIZE(mcu_patch_code_8125d_1));
+	rtl8125_mac_ocp_write(hw, 0xFC26, 0x8000);
+	rtl8125_mac_ocp_write(hw, 0xFC28, 0x14A2);
+	rtl8125_mac_ocp_write(hw, 0xFC48, 0x0001);
+}
+
+void
+rtl8125_set_mac_mcu_8125d_2(struct rtl8125_hw *hw)
+{
+	rtl8125_hw_disable_mac_mcu_bps(hw);
+}
+
+/* ------------------------------------PHY 8125D--------------------------------------- */
+
+static const u16  phy_mcu_ram_code_8125d_1_1[] = {
+	0xa436, 0x8023, 0xa438, 0x3800, 0xa436, 0xB82E, 0xa438, 0x0001,
+	0xb820, 0x0090, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+	0xa438, 0x0000, 0xa436, 0xA014, 0xa438, 0x1800, 0xa438, 0x8010,
+	0xa438, 0x1800, 0xa438, 0x8018, 0xa438, 0x1800, 0xa438, 0x8021,
+	0xa438, 0x1800, 0xa438, 0x8029, 0xa438, 0x1800, 0xa438, 0x8031,
+	0xa438, 0x1800, 0xa438, 0x8035, 0xa438, 0x1800, 0xa438, 0x8035,
+	0xa438, 0x1800, 0xa438, 0x8035, 0xa438, 0xd711, 0xa438, 0x6081,
+	0xa438, 0x8904, 0xa438, 0x1800, 0xa438, 0x2021, 0xa438, 0xa904,
+	0xa438, 0x1800, 0xa438, 0x2021, 0xa438, 0xd75f, 0xa438, 0x4083,
+	0xa438, 0xd503, 0xa438, 0xa908, 0xa438, 0x87f0, 0xa438, 0x1000,
+	0xa438, 0x17e0, 0xa438, 0x1800, 0xa438, 0x13c3, 0xa438, 0xd707,
+	0xa438, 0x2005, 0xa438, 0x8027, 0xa438, 0xd75e, 0xa438, 0x1800,
+	0xa438, 0x1434, 0xa438, 0x1800, 0xa438, 0x14a5, 0xa438, 0xc504,
+	0xa438, 0xce20, 0xa438, 0xcf01, 0xa438, 0xd70a, 0xa438, 0x4005,
+	0xa438, 0xcf02, 0xa438, 0x1800, 0xa438, 0x1c50, 0xa438, 0xa980,
+	0xa438, 0xd500, 0xa438, 0x1800, 0xa438, 0x14f3, 0xa436, 0xA026,
+	0xa438, 0xffff, 0xa436, 0xA024, 0xa438, 0xffff, 0xa436, 0xA022,
+	0xa438, 0xffff, 0xa436, 0xA020, 0xa438, 0x14f2, 0xa436, 0xA006,
+	0xa438, 0x1c4f, 0xa436, 0xA004, 0xa438, 0x1433, 0xa436, 0xA002,
+	0xa438, 0x13c1, 0xa436, 0xA000, 0xa438, 0x2020, 0xa436, 0xA008,
+	0xa438, 0x1f00, 0xa436, 0xA016, 0xa438, 0x0000, 0xa436, 0xA012,
+	0xa438, 0x07f8, 0xa436, 0xA014, 0xa438, 0xd04d, 0xa438, 0x8904,
+	0xa438, 0x813C, 0xa438, 0xA13D, 0xa438, 0x0000, 0xa438, 0x0000,
+	0xa438, 0x0000, 0xa438, 0x0000, 0xa436, 0xA152, 0xa438, 0x1384,
+	0xa436, 0xA154, 0xa438, 0x1fa8, 0xa436, 0xA156, 0xa438, 0x218B,
+	0xa436, 0xA158, 0xa438, 0x21B8, 0xa436, 0xA15A, 0xa438, 0x3fff,
+	0xa436, 0xA15C, 0xa438, 0x3fff, 0xa436, 0xA15E, 0xa438, 0x3fff,
+	0xa436, 0xA160, 0xa438, 0x3fff, 0xa436, 0xA150, 0xa438, 0x000f,
+	0xa436, 0xA016, 0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x1ff8,
+	0xa436, 0xA014, 0xa438, 0x001c, 0xa438, 0xce15, 0xa438, 0xd105,
+	0xa438, 0xa410, 0xa438, 0x8320, 0xa438, 0xFFD7, 0xa438, 0x0000,
+	0xa438, 0x0000, 0xa436, 0xA164, 0xa438, 0x0260, 0xa436, 0xA166,
+	0xa438, 0x0add, 0xa436, 0xA168, 0xa438, 0x05CC, 0xa436, 0xA16A,
+	0xa438, 0x05C5, 0xa436, 0xA16C, 0xa438, 0x0429, 0xa436, 0xA16E,
+	0xa438, 0x07B6, 0xa436, 0xA170, 0xa438, 0x0259, 0xa436, 0xA172,
+	0xa438, 0x3fff, 0xa436, 0xA162, 0xa438, 0x003f, 0xa436, 0xA016,
+	0xa438, 0x0020, 0xa436, 0xA012, 0xa438, 0x0000, 0xa436, 0xA014,
+	0xa438, 0x1800, 0xa438, 0x8010, 0xa438, 0x1800, 0xa438, 0x8023,
+	0xa438, 0x1800, 0xa438, 0x80e6, 0xa438, 0x1800, 0xa438, 0x80f0,
+	0xa438, 0x1800, 0xa438, 0x80f8, 0xa438, 0x1800, 0xa438, 0x816c,
+	0xa438, 0x1800, 0xa438, 0x817d, 0xa438, 0x1800, 0xa438, 0x818b,
+	0xa438, 0xa801, 0xa438, 0x9308, 0xa438, 0xb201, 0xa438, 0xb301,
+	0xa438, 0xd701, 0xa438, 0x4000, 0xa438, 0xd2ff, 0xa438, 0xb302,
+	0xa438, 0xd200, 0xa438, 0xb201, 0xa438, 0xb309, 0xa438, 0xd701,
+	0xa438, 0x4000, 0xa438, 0xd2ff, 0xa438, 0xb302, 0xa438, 0xd200,
+	0xa438, 0xa800, 0xa438, 0x1800, 0xa438, 0x0031, 0xa438, 0xd700,
+	0xa438, 0x4543, 0xa438, 0xd71f, 0xa438, 0x40fe, 0xa438, 0xd1b7,
+	0xa438, 0xd049, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700,
+	0xa438, 0x5fbb, 0xa438, 0xa220, 0xa438, 0x8501, 0xa438, 0x0c03,
+	0xa438, 0x1502, 0xa438, 0x0c70, 0xa438, 0x0b00, 0xa438, 0x0c07,
+	0xa438, 0x0604, 0xa438, 0x9503, 0xa438, 0xa510, 0xa438, 0xce49,
+	0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0x8520, 0xa438, 0xa520,
+	0xa438, 0xa501, 0xa438, 0xd105, 0xa438, 0xd047, 0xa438, 0x1000,
+	0xa438, 0x109e, 0xa438, 0xd707, 0xa438, 0x6087, 0xa438, 0xd700,
+	0xa438, 0x5f7b, 0xa438, 0xffe9, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0x8501, 0xa438, 0xd707, 0xa438, 0x5e08, 0xa438, 0x8530,
+	0xa438, 0xba20, 0xa438, 0xf00c, 0xa438, 0xd700, 0xa438, 0x4098,
+	0xa438, 0xd1ef, 0xa438, 0xd047, 0xa438, 0xf003, 0xa438, 0xd1db,
+	0xa438, 0xd040, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700,
+	0xa438, 0x5fbb, 0xa438, 0x8980, 0xa438, 0xd704, 0xa438, 0x40a3,
+	0xa438, 0xd702, 0xa438, 0x4060, 0xa438, 0x8410, 0xa438, 0xf002,
+	0xa438, 0xa410, 0xa438, 0xce02, 0xa438, 0x1000, 0xa438, 0x10be,
+	0xa438, 0xcd81, 0xa438, 0xd412, 0xa438, 0x1000, 0xa438, 0x1069,
+	0xa438, 0xcd82, 0xa438, 0xd40e, 0xa438, 0x1000, 0xa438, 0x1069,
+	0xa438, 0xcd83, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd71f,
+	0xa438, 0x5fb4, 0xa438, 0xa00a, 0xa438, 0xa340, 0xa438, 0x0c06,
+	0xa438, 0x0102, 0xa438, 0xa240, 0xa438, 0xa290, 0xa438, 0xa324,
+	0xa438, 0xab02, 0xa438, 0xd13e, 0xa438, 0xd05a, 0xa438, 0xd13e,
+	0xa438, 0xd06b, 0xa438, 0xcd84, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0xd706, 0xa438, 0x6079, 0xa438, 0xd700, 0xa438, 0x5f5c,
+	0xa438, 0xcd8a, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd706,
+	0xa438, 0x6079, 0xa438, 0xd700, 0xa438, 0x5f5d, 0xa438, 0xcd8b,
+	0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xcd8c, 0xa438, 0xd700,
+	0xa438, 0x6050, 0xa438, 0xab04, 0xa438, 0xd700, 0xa438, 0x4083,
+	0xa438, 0xd160, 0xa438, 0xd04b, 0xa438, 0xf003, 0xa438, 0xd193,
+	0xa438, 0xd047, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700,
+	0xa438, 0x5fbb, 0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x8410,
+	0xa438, 0xd71f, 0xa438, 0x5f94, 0xa438, 0xb920, 0xa438, 0x1000,
+	0xa438, 0x109e, 0xa438, 0xd71f, 0xa438, 0x7fb4, 0xa438, 0x9920,
+	0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd71f, 0xa438, 0x6105,
+	0xa438, 0x6054, 0xa438, 0xfffb, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0xd706, 0xa438, 0x5fb9, 0xa438, 0xfff0, 0xa438, 0xa410,
+	0xa438, 0xb820, 0xa438, 0xcd85, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0xd71f, 0xa438, 0x7fa5, 0xa438, 0x9820, 0xa438, 0xbb20,
+	0xa438, 0xd105, 0xa438, 0xd042, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0xd706, 0xa438, 0x5fbb, 0xa438, 0x5f85, 0xa438, 0xd700,
+	0xa438, 0x5f5b, 0xa438, 0xd700, 0xa438, 0x6090, 0xa438, 0xd700,
+	0xa438, 0x4043, 0xa438, 0xaa20, 0xa438, 0xcd86, 0xa438, 0xd700,
+	0xa438, 0x6083, 0xa438, 0xd1c7, 0xa438, 0xd045, 0xa438, 0xf003,
+	0xa438, 0xd17a, 0xa438, 0xd04b, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0xd700, 0xa438, 0x5fbb, 0xa438, 0x0c18, 0xa438, 0x0108,
+	0xa438, 0x0c3f, 0xa438, 0x0609, 0xa438, 0x0cfb, 0xa438, 0x0729,
+	0xa438, 0xa308, 0xa438, 0x8320, 0xa438, 0xd105, 0xa438, 0xd042,
+	0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd700, 0xa438, 0x5fbb,
+	0xa438, 0x1800, 0xa438, 0x08f7, 0xa438, 0x1000, 0xa438, 0x109e,
+	0xa438, 0x1000, 0xa438, 0x10a3, 0xa438, 0xd700, 0xa438, 0x607b,
+	0xa438, 0xd700, 0xa438, 0x5f2b, 0xa438, 0x1800, 0xa438, 0x0a81,
+	0xa438, 0xd700, 0xa438, 0x40bd, 0xa438, 0xd707, 0xa438, 0x4065,
+	0xa438, 0x1800, 0xa438, 0x1121, 0xa438, 0x1800, 0xa438, 0x1124,
+	0xa438, 0xd705, 0xa438, 0x627d, 0xa438, 0xd704, 0xa438, 0x6192,
+	0xa438, 0xa00a, 0xa438, 0xd704, 0xa438, 0x41c7, 0xa438, 0xd700,
+	0xa438, 0x3691, 0xa438, 0x810c, 0xa438, 0x0c03, 0xa438, 0x1502,
+	0xa438, 0xa570, 0xa438, 0x9503, 0xa438, 0xf006, 0xa438, 0x800a,
+	0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503,
+	0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x1108,
+	0xa438, 0xcd64, 0xa438, 0xd704, 0xa438, 0x3398, 0xa438, 0x8166,
+	0xa438, 0xd71f, 0xa438, 0x620e, 0xa438, 0xd704, 0xa438, 0x6096,
+	0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf004, 0xa438, 0xd705,
+	0xa438, 0x605d, 0xa438, 0xf008, 0xa438, 0xd706, 0xa438, 0x609d,
+	0xa438, 0xd705, 0xa438, 0x405f, 0xa438, 0xf003, 0xa438, 0xd700,
+	0xa438, 0x5a9b, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0xc7aa,
+	0xa438, 0x9503, 0xa438, 0xd71f, 0xa438, 0x674e, 0xa438, 0xd704,
+	0xa438, 0x6096, 0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf005,
+	0xa438, 0xd705, 0xa438, 0x607d, 0xa438, 0x1800, 0xa438, 0x0cc7,
+	0xa438, 0xd706, 0xa438, 0x60bd, 0xa438, 0xd705, 0xa438, 0x407f,
+	0xa438, 0x1800, 0xa438, 0x0e42, 0xa438, 0xce04, 0xa438, 0x1000,
+	0xa438, 0x10be, 0xa438, 0xd702, 0xa438, 0x40a4, 0xa438, 0x0c03,
+	0xa438, 0x1502, 0xa438, 0x8e20, 0xa438, 0x9503, 0xa438, 0xd702,
+	0xa438, 0x40a5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8e40,
+	0xa438, 0x9503, 0xa438, 0x1000, 0xa438, 0x11a4, 0xa438, 0x1000,
+	0xa438, 0x109e, 0xa438, 0x1000, 0xa438, 0x1108, 0xa438, 0xcd61,
+	0xa438, 0xd704, 0xa438, 0x3398, 0xa438, 0x8166, 0xa438, 0xd704,
+	0xa438, 0x6096, 0xa438, 0xd705, 0xa438, 0x6051, 0xa438, 0xf005,
+	0xa438, 0xd705, 0xa438, 0x607d, 0xa438, 0x1800, 0xa438, 0x0cc7,
+	0xa438, 0xd71f, 0xa438, 0x60ee, 0xa438, 0xd706, 0xa438, 0x7bdd,
+	0xa438, 0xd705, 0xa438, 0x5b9f, 0xa438, 0x1800, 0xa438, 0x0e42,
+	0xa438, 0x1800, 0xa438, 0x0b5f, 0xa438, 0x0c03, 0xa438, 0x1502,
+	0xa438, 0xae40, 0xa438, 0x9503, 0xa438, 0x1800, 0xa438, 0x0c47,
+	0xa438, 0x607c, 0xa438, 0x1800, 0xa438, 0x027a, 0xa438, 0x0c03,
+	0xa438, 0x1502, 0xa438, 0xae01, 0xa438, 0x9503, 0xa438, 0x1000,
+	0xa438, 0x109e, 0xa438, 0xd702, 0xa438, 0x5fa3, 0xa438, 0x0c03,
+	0xa438, 0x1502, 0xa438, 0x8e01, 0xa438, 0x9503, 0xa438, 0x1800,
+	0xa438, 0x027d, 0xa438, 0x1000, 0xa438, 0x10be, 0xa438, 0xd702,
+	0xa438, 0x40a5, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8e40,
+	0xa438, 0x9503, 0xa438, 0xd73e, 0xa438, 0x6065, 0xa438, 0x1800,
+	0xa438, 0x0cea, 0xa438, 0x1800, 0xa438, 0x0cf4, 0xa438, 0xa290,
+	0xa438, 0xa304, 0xa438, 0xab02, 0xa438, 0xd700, 0xa438, 0x6050,
+	0xa438, 0xab04, 0xa438, 0x0c38, 0xa438, 0x0608, 0xa438, 0xaa0b,
+	0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8d01, 0xa438, 0x0c03,
+	0xa438, 0x1502, 0xa438, 0xae40, 0xa438, 0x9503, 0xa438, 0xd702,
+	0xa438, 0x40a4, 0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8e20,
+	0xa438, 0x9503, 0xa438, 0xd700, 0xa438, 0x6078, 0xa438, 0xd700,
+	0xa438, 0x609a, 0xa438, 0xd109, 0xa438, 0xd074, 0xa438, 0xf003,
+	0xa438, 0xd109, 0xa438, 0xd075, 0xa438, 0xd704, 0xa438, 0x6192,
+	0xa438, 0xa00a, 0xa438, 0xd704, 0xa438, 0x41c7, 0xa438, 0xd700,
+	0xa438, 0x3691, 0xa438, 0x81bc, 0xa438, 0x0c03, 0xa438, 0x1502,
+	0xa438, 0xa570, 0xa438, 0x9503, 0xa438, 0xf006, 0xa438, 0x800a,
+	0xa438, 0x0c03, 0xa438, 0x1502, 0xa438, 0x8570, 0xa438, 0x9503,
+	0xa438, 0x1000, 0xa438, 0x109e, 0xa438, 0xd704, 0xa438, 0x60f3,
+	0xa438, 0xd71f, 0xa438, 0x60ee, 0xa438, 0xd700, 0xa438, 0x5cfe,
+	0xa438, 0x1800, 0xa438, 0x0deb, 0xa438, 0x1800, 0xa438, 0x0c47,
+	0xa438, 0x1800, 0xa438, 0x0df8, 0xa436, 0xA10E, 0xa438, 0x0dc5,
+	0xa436, 0xA10C, 0xa438, 0x0ce8, 0xa436, 0xA10A, 0xa438, 0x0279,
+	0xa436, 0xA108, 0xa438, 0x0b19, 0xa436, 0xA106, 0xa438, 0x111f,
+	0xa436, 0xA104, 0xa438, 0x0a7b, 0xa436, 0xA102, 0xa438, 0x0ba3,
+	0xa436, 0xA100, 0xa438, 0x0022, 0xa436, 0xA110, 0xa438, 0x00ff,
+	0xa436, 0xb87c, 0xa438, 0x859b, 0xa436, 0xb87e, 0xa438, 0xaf85,
+	0xa438, 0xb3af, 0xa438, 0x863b, 0xa438, 0xaf86, 0xa438, 0x4caf,
+	0xa438, 0x8688, 0xa438, 0xaf86, 0xa438, 0xceaf, 0xa438, 0x8744,
+	0xa438, 0xaf87, 0xa438, 0x68af, 0xa438, 0x8781, 0xa438, 0xbf5e,
+	0xa438, 0x7202, 0xa438, 0x5f7e, 0xa438, 0xac28, 0xa438, 0x68e1,
+	0xa438, 0x84e6, 0xa438, 0xad28, 0xa438, 0x09bf, 0xa438, 0x5e75,
+	0xa438, 0x025f, 0xa438, 0x7eac, 0xa438, 0x2d59, 0xa438, 0xe18f,
+	0xa438, 0xebad, 0xa438, 0x2809, 0xa438, 0xbf5e, 0xa438, 0x7502,
+	0xa438, 0x5f7e, 0xa438, 0xac2e, 0xa438, 0x50e1, 0xa438, 0x84e6,
+	0xa438, 0xac28, 0xa438, 0x08bf, 0xa438, 0x873e, 0xa438, 0x025f,
+	0xa438, 0x3cae, 0xa438, 0x06bf, 0xa438, 0x873e, 0xa438, 0x025f,
+	0xa438, 0x33bf, 0xa438, 0x8741, 0xa438, 0x025f, 0xa438, 0x33ee,
+	0xa438, 0x8fea, 0xa438, 0x02e1, 0xa438, 0x84e4, 0xa438, 0xad28,
+	0xa438, 0x14e1, 0xa438, 0x8fe8, 0xa438, 0xad28, 0xa438, 0x17e1,
+	0xa438, 0x84e5, 0xa438, 0x11e5, 0xa438, 0x84e5, 0xa438, 0xa10c,
+	0xa438, 0x04ee, 0xa438, 0x84e5, 0xa438, 0x0002, 0xa438, 0x4977,
+	0xa438, 0xee84, 0xa438, 0xdc03, 0xa438, 0xae1d, 0xa438, 0xe18f,
+	0xa438, 0xe811, 0xa438, 0xe58f, 0xa438, 0xe8ae, 0xa438, 0x14bf,
+	0xa438, 0x873e, 0xa438, 0x025f, 0xa438, 0x3cbf, 0xa438, 0x8741,
+	0xa438, 0x025f, 0xa438, 0x3cee, 0xa438, 0x8fea, 0xa438, 0x01ee,
+	0xa438, 0x84e4, 0xa438, 0x00af, 0xa438, 0x50c1, 0xa438, 0x1f00,
+	0xa438, 0xbf5a, 0xa438, 0x6102, 0xa438, 0x5f5f, 0xa438, 0xbf5a,
+	0xa438, 0x5e02, 0xa438, 0x5f3c, 0xa438, 0xaf45, 0xa438, 0x7be0,
+	0xa438, 0x8012, 0xa438, 0xad23, 0xa438, 0x141f, 0xa438, 0x001f,
+	0xa438, 0x22d1, 0xa438, 0x00bf, 0xa438, 0x3fcf, 0xa438, 0x0261,
+	0xa438, 0x3412, 0xa438, 0xa204, 0xa438, 0xf6ee, 0xa438, 0x8317,
+	0xa438, 0x00e0, 0xa438, 0x8012, 0xa438, 0xad24, 0xa438, 0x141f,
+	0xa438, 0x001f, 0xa438, 0x22d1, 0xa438, 0x00bf, 0xa438, 0x3fd7,
+	0xa438, 0x0261, 0xa438, 0x3412, 0xa438, 0xa204, 0xa438, 0xf6ee,
+	0xa438, 0x8317, 0xa438, 0x00ef, 0xa438, 0x96fe, 0xa438, 0xfdfc,
+	0xa438, 0xaf42, 0xa438, 0x9802, 0xa438, 0x56ec, 0xa438, 0xf70b,
+	0xa438, 0xac13, 0xa438, 0x0fbf, 0xa438, 0x5e75, 0xa438, 0x025f,
+	0xa438, 0x7eac, 0xa438, 0x280c, 0xa438, 0xe2ff, 0xa438, 0xcfad,
+	0xa438, 0x32ee, 0xa438, 0x0257, 0xa438, 0x05af, 0xa438, 0x00a4,
+	0xa438, 0x0286, 0xa438, 0xaaae, 0xa438, 0xeff8, 0xa438, 0xf9ef,
+	0xa438, 0x5902, 0xa438, 0x1fe1, 0xa438, 0xbf59, 0xa438, 0x4d02,
+	0xa438, 0x5f3c, 0xa438, 0xac13, 0xa438, 0x09bf, 0xa438, 0x5e75,
+	0xa438, 0x025f, 0xa438, 0x7ea1, 0xa438, 0x00f4, 0xa438, 0xbf59,
+	0xa438, 0x4d02, 0xa438, 0x5f33, 0xa438, 0xef95, 0xa438, 0xfdfc,
+	0xa438, 0x04bf, 0xa438, 0x5e72, 0xa438, 0x025f, 0xa438, 0x7eac,
+	0xa438, 0x284a, 0xa438, 0xe184, 0xa438, 0xe6ad, 0xa438, 0x2809,
+	0xa438, 0xbf5e, 0xa438, 0x7502, 0xa438, 0x5f7e, 0xa438, 0xac2d,
+	0xa438, 0x3be1, 0xa438, 0x8feb, 0xa438, 0xad28, 0xa438, 0x09bf,
+	0xa438, 0x5e75, 0xa438, 0x025f, 0xa438, 0x7eac, 0xa438, 0x2e32,
+	0xa438, 0xe184, 0xa438, 0xe6ac, 0xa438, 0x2808, 0xa438, 0xbf87,
+	0xa438, 0x3e02, 0xa438, 0x5f3c, 0xa438, 0xae06, 0xa438, 0xbf87,
+	0xa438, 0x3e02, 0xa438, 0x5f33, 0xa438, 0xbf87, 0xa438, 0x4102,
+	0xa438, 0x5f33, 0xa438, 0xee8f, 0xa438, 0xea04, 0xa438, 0xbf5e,
+	0xa438, 0x4e02, 0xa438, 0x5f7e, 0xa438, 0xad28, 0xa438, 0x1f02,
+	0xa438, 0x4b12, 0xa438, 0xae1a, 0xa438, 0xbf87, 0xa438, 0x3e02,
+	0xa438, 0x5f3c, 0xa438, 0xbf87, 0xa438, 0x4102, 0xa438, 0x5f3c,
+	0xa438, 0xee8f, 0xa438, 0xea03, 0xa438, 0xbf5e, 0xa438, 0x2a02,
+	0xa438, 0x5f33, 0xa438, 0xee84, 0xa438, 0xe701, 0xa438, 0xaf4a,
+	0xa438, 0x7444, 0xa438, 0xac0e, 0xa438, 0x55ac, 0xa438, 0x0ebf,
+	0xa438, 0x5e75, 0xa438, 0x025f, 0xa438, 0x7ead, 0xa438, 0x2d0b,
+	0xa438, 0xbf5e, 0xa438, 0x36e1, 0xa438, 0x8fe9, 0xa438, 0x025f,
+	0xa438, 0x5fae, 0xa438, 0x09bf, 0xa438, 0x5e36, 0xa438, 0xe184,
+	0xa438, 0xe102, 0xa438, 0x5f5f, 0xa438, 0xee8f, 0xa438, 0xe800,
+	0xa438, 0xaf49, 0xa438, 0xcdbf, 0xa438, 0x595c, 0xa438, 0x025f,
+	0xa438, 0x7ea1, 0xa438, 0x0203, 0xa438, 0xaf87, 0xa438, 0x79d1,
+	0xa438, 0x00af, 0xa438, 0x877c, 0xa438, 0xe181, 0xa438, 0x941f,
+	0xa438, 0x00af, 0xa438, 0x3ff7, 0xa438, 0xac4e, 0xa438, 0x06ac,
+	0xa438, 0x4003, 0xa438, 0xaf24, 0xa438, 0x97af, 0xa438, 0x2467,
+	0xa436, 0xb85e, 0xa438, 0x5082, 0xa436, 0xb860, 0xa438, 0x4575,
+	0xa436, 0xb862, 0xa438, 0x425F, 0xa436, 0xb864, 0xa438, 0x0096,
+	0xa436, 0xb886, 0xa438, 0x4A44, 0xa436, 0xb888, 0xa438, 0x49c4,
+	0xa436, 0xb88a, 0xa438, 0x3FF2, 0xa436, 0xb88c, 0xa438, 0x245C,
+	0xa436, 0xb838, 0xa438, 0x00ff, 0xb820, 0x0010, 0xa466, 0x0001,
+	0xa436, 0x836a, 0xa438, 0x0001, 0xa436, 0x843d, 0xa438, 0xaf84,
+	0xa438, 0xa6af, 0xa438, 0x8540, 0xa438, 0xaf85, 0xa438, 0xaeaf,
+	0xa438, 0x85b5, 0xa438, 0xaf87, 0xa438, 0x7daf, 0xa438, 0x8784,
+	0xa438, 0xaf87, 0xa438, 0x87af, 0xa438, 0x87e5, 0xa438, 0x0066,
+	0xa438, 0x0a03, 0xa438, 0x6607, 0xa438, 0x2666, 0xa438, 0x1c00,
+	0xa438, 0x660d, 0xa438, 0x0166, 0xa438, 0x1004, 0xa438, 0x6616,
+	0xa438, 0x0566, 0xa438, 0x1f06, 0xa438, 0x6a5d, 0xa438, 0x2766,
+	0xa438, 0x1900, 0xa438, 0x6625, 0xa438, 0x2466, 0xa438, 0x2820,
+	0xa438, 0x662b, 0xa438, 0x2466, 0xa438, 0x4600, 0xa438, 0x664c,
+	0xa438, 0x0166, 0xa438, 0x4902, 0xa438, 0x8861, 0xa438, 0x0388,
+	0xa438, 0x5e05, 0xa438, 0x886d, 0xa438, 0x0588, 0xa438, 0x7005,
+	0xa438, 0x8873, 0xa438, 0x0588, 0xa438, 0x7605, 0xa438, 0x8879,
+	0xa438, 0x0588, 0xa438, 0x7c05, 0xa438, 0x887f, 0xa438, 0x0588,
+	0xa438, 0x8205, 0xa438, 0x8885, 0xa438, 0x0588, 0xa438, 0x881e,
+	0xa438, 0x13ad, 0xa438, 0x2841, 0xa438, 0xbf64, 0xa438, 0xf102,
+	0xa438, 0x6b9d, 0xa438, 0xad28, 0xa438, 0x03af, 0xa438, 0x15fc,
+	0xa438, 0xbf65, 0xa438, 0xcb02, 0xa438, 0x6b9d, 0xa438, 0x0d11,
+	0xa438, 0xf62f, 0xa438, 0xef31, 0xa438, 0xd202, 0xa438, 0xbf88,
+	0xa438, 0x6402, 0xa438, 0x6b52, 0xa438, 0xe082, 0xa438, 0x020d,
+	0xa438, 0x01f6, 0xa438, 0x271b, 0xa438, 0x03aa, 0xa438, 0x0182,
+	0xa438, 0xe082, 0xa438, 0x010d, 0xa438, 0x01f6, 0xa438, 0x271b,
+	0xa438, 0x03aa, 0xa438, 0x0782, 0xa438, 0xbf88, 0xa438, 0x6402,
+	0xa438, 0x6b5b, 0xa438, 0xaf15, 0xa438, 0xf9bf, 0xa438, 0x65cb,
+	0xa438, 0x026b, 0xa438, 0x9d0d, 0xa438, 0x11f6, 0xa438, 0x2fef,
+	0xa438, 0x31e0, 0xa438, 0x8ff7, 0xa438, 0x0d01, 0xa438, 0xf627,
+	0xa438, 0x1b03, 0xa438, 0xaa20, 0xa438, 0xe18f, 0xa438, 0xf4d0,
+	0xa438, 0x00bf, 0xa438, 0x6587, 0xa438, 0x026b, 0xa438, 0x7ee1,
+	0xa438, 0x8ff5, 0xa438, 0xbf65, 0xa438, 0x8a02, 0xa438, 0x6b7e,
+	0xa438, 0xe18f, 0xa438, 0xf6bf, 0xa438, 0x6584, 0xa438, 0x026b,
+	0xa438, 0x7eaf, 0xa438, 0x15fc, 0xa438, 0xe18f, 0xa438, 0xf1d0,
+	0xa438, 0x00bf, 0xa438, 0x6587, 0xa438, 0x026b, 0xa438, 0x7ee1,
+	0xa438, 0x8ff2, 0xa438, 0xbf65, 0xa438, 0x8a02, 0xa438, 0x6b7e,
+	0xa438, 0xe18f, 0xa438, 0xf3bf, 0xa438, 0x6584, 0xa438, 0xaf15,
+	0xa438, 0xfcd1, 0xa438, 0x07bf, 0xa438, 0x65ce, 0xa438, 0x026b,
+	0xa438, 0x7ed1, 0xa438, 0x0cbf, 0xa438, 0x65d1, 0xa438, 0x026b,
+	0xa438, 0x7ed1, 0xa438, 0x03bf, 0xa438, 0x885e, 0xa438, 0x026b,
+	0xa438, 0x7ed1, 0xa438, 0x05bf, 0xa438, 0x8867, 0xa438, 0x026b,
+	0xa438, 0x7ed1, 0xa438, 0x07bf, 0xa438, 0x886a, 0xa438, 0x026b,
+	0xa438, 0x7ebf, 0xa438, 0x6a6c, 0xa438, 0x026b, 0xa438, 0x5b02,
+	0xa438, 0x62b5, 0xa438, 0xbf6a, 0xa438, 0x0002, 0xa438, 0x6b5b,
+	0xa438, 0xbf64, 0xa438, 0x4e02, 0xa438, 0x6b9d, 0xa438, 0xac28,
+	0xa438, 0x0bbf, 0xa438, 0x6412, 0xa438, 0x026b, 0xa438, 0x9da1,
+	0xa438, 0x0502, 0xa438, 0xaeec, 0xa438, 0xd104, 0xa438, 0xbf65,
+	0xa438, 0xce02, 0xa438, 0x6b7e, 0xa438, 0xd104, 0xa438, 0xbf65,
+	0xa438, 0xd102, 0xa438, 0x6b7e, 0xa438, 0xd102, 0xa438, 0xbf88,
+	0xa438, 0x6702, 0xa438, 0x6b7e, 0xa438, 0xd104, 0xa438, 0xbf88,
+	0xa438, 0x6a02, 0xa438, 0x6b7e, 0xa438, 0xaf62, 0xa438, 0x72f6,
+	0xa438, 0x0af6, 0xa438, 0x09af, 0xa438, 0x34e3, 0xa438, 0x0285,
+	0xa438, 0xbe02, 0xa438, 0x106c, 0xa438, 0xaf10, 0xa438, 0x6bf8,
+	0xa438, 0xfaef, 0xa438, 0x69e0, 0xa438, 0x804c, 0xa438, 0xac25,
+	0xa438, 0x17e0, 0xa438, 0x8040, 0xa438, 0xad25, 0xa438, 0x1a02,
+	0xa438, 0x85ed, 0xa438, 0xe080, 0xa438, 0x40ac, 0xa438, 0x2511,
+	0xa438, 0xbf87, 0xa438, 0x6502, 0xa438, 0x6b5b, 0xa438, 0xae09,
+	0xa438, 0x0287, 0xa438, 0x2402, 0xa438, 0x875a, 0xa438, 0x0287,
+	0xa438, 0x4fef, 0xa438, 0x96fe, 0xa438, 0xfc04, 0xa438, 0xf8e0,
+	0xa438, 0x8019, 0xa438, 0xad20, 0xa438, 0x11e0, 0xa438, 0x8fe3,
+	0xa438, 0xac20, 0xa438, 0x0502, 0xa438, 0x860a, 0xa438, 0xae03,
+	0xa438, 0x0286, 0xa438, 0x7802, 0xa438, 0x86c1, 0xa438, 0x0287,
+	0xa438, 0x4ffc, 0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x79fb,
+	0xa438, 0xbf87, 0xa438, 0x6802, 0xa438, 0x6b9d, 0xa438, 0x5c20,
+	0xa438, 0x000d, 0xa438, 0x4da1, 0xa438, 0x0151, 0xa438, 0xbf87,
+	0xa438, 0x6802, 0xa438, 0x6b9d, 0xa438, 0x5c07, 0xa438, 0xffe3,
+	0xa438, 0x8fe4, 0xa438, 0x1b31, 0xa438, 0x9f41, 0xa438, 0x0d48,
+	0xa438, 0xe38f, 0xa438, 0xe51b, 0xa438, 0x319f, 0xa438, 0x38bf,
+	0xa438, 0x876b, 0xa438, 0x026b, 0xa438, 0x9d5c, 0xa438, 0x07ff,
+	0xa438, 0xe38f, 0xa438, 0xe61b, 0xa438, 0x319f, 0xa438, 0x280d,
+	0xa438, 0x48e3, 0xa438, 0x8fe7, 0xa438, 0x1b31, 0xa438, 0x9f1f,
+	0xa438, 0xbf87, 0xa438, 0x6e02, 0xa438, 0x6b9d, 0xa438, 0x5c07,
+	0xa438, 0xffe3, 0xa438, 0x8fe8, 0xa438, 0x1b31, 0xa438, 0x9f0f,
+	0xa438, 0x0d48, 0xa438, 0xe38f, 0xa438, 0xe91b, 0xa438, 0x319f,
+	0xa438, 0x06ee, 0xa438, 0x8fe3, 0xa438, 0x01ae, 0xa438, 0x04ee,
+	0xa438, 0x8fe3, 0xa438, 0x00ff, 0xa438, 0xef97, 0xa438, 0xfdfc,
+	0xa438, 0x04f8, 0xa438, 0xf9ef, 0xa438, 0x79fb, 0xa438, 0xbf87,
+	0xa438, 0x6802, 0xa438, 0x6b9d, 0xa438, 0x5c20, 0xa438, 0x000d,
+	0xa438, 0x4da1, 0xa438, 0x0020, 0xa438, 0xbf87, 0xa438, 0x6802,
+	0xa438, 0x6b9d, 0xa438, 0x5c06, 0xa438, 0x000d, 0xa438, 0x49e3,
+	0xa438, 0x8fea, 0xa438, 0x1b31, 0xa438, 0x9f0e, 0xa438, 0xbf87,
+	0xa438, 0x7102, 0xa438, 0x6b5b, 0xa438, 0xbf87, 0xa438, 0x7702,
+	0xa438, 0x6b5b, 0xa438, 0xae0c, 0xa438, 0xbf87, 0xa438, 0x7102,
+	0xa438, 0x6b52, 0xa438, 0xbf87, 0xa438, 0x7702, 0xa438, 0x6b52,
+	0xa438, 0xee8f, 0xa438, 0xe300, 0xa438, 0xffef, 0xa438, 0x97fd,
+	0xa438, 0xfc04, 0xa438, 0xf8f9, 0xa438, 0xef79, 0xa438, 0xfbbf,
+	0xa438, 0x8768, 0xa438, 0x026b, 0xa438, 0x9d5c, 0xa438, 0x2000,
+	0xa438, 0x0d4d, 0xa438, 0xa101, 0xa438, 0x4abf, 0xa438, 0x8768,
+	0xa438, 0x026b, 0xa438, 0x9d5c, 0xa438, 0x07ff, 0xa438, 0xe38f,
+	0xa438, 0xeb1b, 0xa438, 0x319f, 0xa438, 0x3a0d, 0xa438, 0x48e3,
+	0xa438, 0x8fec, 0xa438, 0x1b31, 0xa438, 0x9f31, 0xa438, 0xbf87,
+	0xa438, 0x6b02, 0xa438, 0x6b9d, 0xa438, 0xe38f, 0xa438, 0xed1b,
+	0xa438, 0x319f, 0xa438, 0x240d, 0xa438, 0x48e3, 0xa438, 0x8fee,
+	0xa438, 0x1b31, 0xa438, 0x9f1b, 0xa438, 0xbf87, 0xa438, 0x6e02,
+	0xa438, 0x6b9d, 0xa438, 0xe38f, 0xa438, 0xef1b, 0xa438, 0x319f,
+	0xa438, 0x0ebf, 0xa438, 0x8774, 0xa438, 0x026b, 0xa438, 0x5bbf,
+	0xa438, 0x877a, 0xa438, 0x026b, 0xa438, 0x5bae, 0xa438, 0x00ff,
+	0xa438, 0xef97, 0xa438, 0xfdfc, 0xa438, 0x04f8, 0xa438, 0xef79,
+	0xa438, 0xfbe0, 0xa438, 0x8019, 0xa438, 0xad20, 0xa438, 0x1cee,
+	0xa438, 0x8fe3, 0xa438, 0x00bf, 0xa438, 0x8771, 0xa438, 0x026b,
+	0xa438, 0x52bf, 0xa438, 0x8777, 0xa438, 0x026b, 0xa438, 0x52bf,
+	0xa438, 0x8774, 0xa438, 0x026b, 0xa438, 0x52bf, 0xa438, 0x877a,
+	0xa438, 0x026b, 0xa438, 0x52ff, 0xa438, 0xef97, 0xa438, 0xfc04,
+	0xa438, 0xf8e0, 0xa438, 0x8040, 0xa438, 0xf625, 0xa438, 0xe480,
+	0xa438, 0x40fc, 0xa438, 0x04f8, 0xa438, 0xe080, 0xa438, 0x4cf6,
+	0xa438, 0x25e4, 0xa438, 0x804c, 0xa438, 0xfc04, 0xa438, 0x55a4,
+	0xa438, 0xbaf0, 0xa438, 0xa64a, 0xa438, 0xf0a6, 0xa438, 0x4cf0,
+	0xa438, 0xa64e, 0xa438, 0x66a4, 0xa438, 0xb655, 0xa438, 0xa4b6,
+	0xa438, 0x00ac, 0xa438, 0x0e11, 0xa438, 0xac0e, 0xa438, 0xee80,
+	0xa438, 0x4c3a, 0xa438, 0xaf07, 0xa438, 0xd0af, 0xa438, 0x26d0,
+	0xa438, 0xa201, 0xa438, 0x0ebf, 0xa438, 0x663d, 0xa438, 0x026b,
+	0xa438, 0x52bf, 0xa438, 0x6643, 0xa438, 0x026b, 0xa438, 0x52ae,
+	0xa438, 0x11bf, 0xa438, 0x6643, 0xa438, 0x026b, 0xa438, 0x5bd4,
+	0xa438, 0x0054, 0xa438, 0xb4fe, 0xa438, 0xbf66, 0xa438, 0x3d02,
+	0xa438, 0x6b5b, 0xa438, 0xd300, 0xa438, 0x020d, 0xa438, 0xf6a2,
+	0xa438, 0x0405, 0xa438, 0xe081, 0xa438, 0x47ae, 0xa438, 0x03e0,
+	0xa438, 0x8148, 0xa438, 0xac23, 0xa438, 0x02ae, 0xa438, 0x0268,
+	0xa438, 0xf01a, 0xa438, 0x10ad, 0xa438, 0x2f04, 0xa438, 0xd100,
+	0xa438, 0xae05, 0xa438, 0xad2c, 0xa438, 0x02d1, 0xa438, 0x0f1f,
+	0xa438, 0x00a2, 0xa438, 0x0407, 0xa438, 0x3908, 0xa438, 0xad2f,
+	0xa438, 0x02d1, 0xa438, 0x0002, 0xa438, 0x0e1c, 0xa438, 0x2b01,
+	0xa438, 0xad3a, 0xa438, 0xc9af, 0xa438, 0x0dee, 0xa438, 0xa000,
+	0xa438, 0x2702, 0xa438, 0x1beb, 0xa438, 0xe18f, 0xa438, 0xe1ac,
+	0xa438, 0x2819, 0xa438, 0xee8f, 0xa438, 0xe101, 0xa438, 0x1f44,
+	0xa438, 0xbf65, 0xa438, 0x9302, 0xa438, 0x6b9d, 0xa438, 0xe58f,
+	0xa438, 0xe21f, 0xa438, 0x44d1, 0xa438, 0x02bf, 0xa438, 0x6593,
+	0xa438, 0x026b, 0xa438, 0x7ee0, 0xa438, 0x82b1, 0xa438, 0xae49,
+	0xa438, 0xa001, 0xa438, 0x0502, 0xa438, 0x1c4d, 0xa438, 0xae41,
+	0xa438, 0xa002, 0xa438, 0x0502, 0xa438, 0x1c90, 0xa438, 0xae39,
+	0xa438, 0xa003, 0xa438, 0x0502, 0xa438, 0x1c9d, 0xa438, 0xae31,
+	0xa438, 0xa004, 0xa438, 0x0502, 0xa438, 0x1cbc, 0xa438, 0xae29,
+	0xa438, 0xa005, 0xa438, 0x1e02, 0xa438, 0x1cc9, 0xa438, 0xe080,
+	0xa438, 0xdfac, 0xa438, 0x2013, 0xa438, 0xac21, 0xa438, 0x10ac,
+	0xa438, 0x220d, 0xa438, 0xe18f, 0xa438, 0xe2bf, 0xa438, 0x6593,
+	0xa438, 0x026b, 0xa438, 0x7eee, 0xa438, 0x8fe1, 0xa438, 0x00ae,
+	0xa438, 0x08a0, 0xa438, 0x0605, 0xa438, 0x021d, 0xa438, 0x07ae,
+	0xa438, 0x00e0, 0xa438, 0x82b1, 0xa438, 0xaf1b, 0xa438, 0xe910,
+	0xa438, 0xbf4a, 0xa438, 0x99bf, 0xa438, 0x4a00, 0xa438, 0xa86a,
+	0xa438, 0xfdad, 0xa438, 0x5eca, 0xa438, 0xad5e, 0xa438, 0x88bd,
+	0xa438, 0x2c99, 0xa438, 0xbd2c, 0xa438, 0x33bd, 0xa438, 0x3222,
+	0xa438, 0xbd32, 0xa438, 0x11bd, 0xa438, 0x3200, 0xa438, 0xbd32,
+	0xa438, 0x77bd, 0xa438, 0x3266, 0xa438, 0xbd32, 0xa438, 0x55bd,
+	0xa438, 0x3244, 0xa438, 0xbd32, 0xa436, 0xb818, 0xa438, 0x15c5,
+	0xa436, 0xb81a, 0xa438, 0x6255, 0xa436, 0xb81c, 0xa438, 0x34e1,
+	0xa436, 0xb81e, 0xa438, 0x1068, 0xa436, 0xb850, 0xa438, 0x07cc,
+	0xa436, 0xb852, 0xa438, 0x26ca, 0xa436, 0xb878, 0xa438, 0x0dbf,
+	0xa436, 0xb884, 0xa438, 0x1BB1, 0xa436, 0xb832, 0xa438, 0x00ff,
+	0xa436, 0x0000, 0xa438, 0x0000, 0xB82E, 0x0000, 0xa436, 0x8023,
+	0xa438, 0x0000, 0xa436, 0x801E, 0xa438, 0x0023, 0xB820, 0x0000,
+	0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_1_2[] = {
+	0xb892, 0x0000, 0xB88E, 0xC28F, 0xB890, 0x252D, 0xB88E, 0xC290,
+	0xB890, 0xC924, 0xB88E, 0xC291, 0xB890, 0xC92E, 0xB88E, 0xC292,
+	0xB890, 0xF626, 0xB88E, 0xC293, 0xB890, 0xF630, 0xB88E, 0xC294,
+	0xB890, 0xA328, 0xB88E, 0xC295, 0xB890, 0xA332, 0xB88E, 0xC296,
+	0xB890, 0xD72B, 0xB88E, 0xC297, 0xB890, 0xD735, 0xB88E, 0xC298,
+	0xB890, 0x8A2E, 0xB88E, 0xC299, 0xB890, 0x8A38, 0xB88E, 0xC29A,
+	0xB890, 0xBE32, 0xB88E, 0xC29B, 0xB890, 0xBE3C, 0xB88E, 0xC29C,
+	0xB890, 0x7436, 0xB88E, 0xC29D, 0xB890, 0x7440, 0xB88E, 0xC29E,
+	0xB890, 0xAD3B, 0xB88E, 0xC29F, 0xB890, 0xAD45, 0xB88E, 0xC2A0,
+	0xB890, 0x6640, 0xB88E, 0xC2A1, 0xB890, 0x664A, 0xB88E, 0xC2A2,
+	0xB890, 0xA646, 0xB88E, 0xC2A3, 0xB890, 0xA650, 0xB88E, 0xC2A4,
+	0xB890, 0x624C, 0xB88E, 0xC2A5, 0xB890, 0x6256, 0xB88E, 0xC2A6,
+	0xB890, 0xA453, 0xB88E, 0xC2A7, 0xB890, 0xA45D, 0xB88E, 0xC2A8,
+	0xB890, 0x665A, 0xB88E, 0xC2A9, 0xB890, 0x6664, 0xB88E, 0xC2AA,
+	0xB890, 0xAC62, 0xB88E, 0xC2AB, 0xB890, 0xAC6C, 0xB88E, 0xC2AC,
+	0xB890, 0x746A, 0xB88E, 0xC2AD, 0xB890, 0x7474, 0xB88E, 0xC2AE,
+	0xB890, 0xBCFA, 0xB88E, 0xC2AF, 0xB890, 0xBCFD, 0xB88E, 0xC2B0,
+	0xB890, 0x79FF, 0xB88E, 0xC2B1, 0xB890, 0x7901, 0xB88E, 0xC2B2,
+	0xB890, 0xF703, 0xB88E, 0xC2B3, 0xB890, 0xF706, 0xB88E, 0xC2B4,
+	0xB890, 0x7408, 0xB88E, 0xC2B5, 0xB890, 0x740A, 0xB88E, 0xC2B6,
+	0xB890, 0xF10C, 0xB88E, 0xC2B7, 0xB890, 0xF10F, 0xB88E, 0xC2B8,
+	0xB890, 0x6F10, 0xB88E, 0xC2B9, 0xB890, 0x6F13, 0xB88E, 0xC2BA,
+	0xB890, 0xEC15, 0xB88E, 0xC2BB, 0xB890, 0xEC18, 0xB88E, 0xC2BC,
+	0xB890, 0x6A1A, 0xB88E, 0xC2BD, 0xB890, 0x6A1C, 0xB88E, 0xC2BE,
+	0xB890, 0xE71E, 0xB88E, 0xC2BF, 0xB890, 0xE721, 0xB88E, 0xC2C0,
+	0xB890, 0x6424, 0xB88E, 0xC2C1, 0xB890, 0x6425, 0xB88E, 0xC2C2,
+	0xB890, 0xE228, 0xB88E, 0xC2C3, 0xB890, 0xE22A, 0xB88E, 0xC2C4,
+	0xB890, 0x5F2B, 0xB88E, 0xC2C5, 0xB890, 0x5F2E, 0xB88E, 0xC2C6,
+	0xB890, 0xDC31, 0xB88E, 0xC2C7, 0xB890, 0xDC33, 0xB88E, 0xC2C8,
+	0xB890, 0x2035, 0xB88E, 0xC2C9, 0xB890, 0x2036, 0xB88E, 0xC2CA,
+	0xB890, 0x9F3A, 0xB88E, 0xC2CB, 0xB890, 0x9F3A, 0xB88E, 0xC2CC,
+	0xB890, 0x4430, 0xFFFF, 0xFFFF
+};
+
+static const u16  phy_mcu_ram_code_8125d_1_3[] = {
+	0xa436, 0xacca, 0xa438, 0x0104, 0xa436, 0xaccc, 0xa438, 0x8000,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x0fff,
+	0xa436, 0xacce, 0xa438, 0xfff8, 0xa436, 0xacd0, 0xa438, 0x0fff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xffff, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xfb47, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xfb4f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0x6087, 0xa436, 0xacd0, 0xa438, 0x0180,
+	0xa436, 0xacce, 0xa438, 0x600f, 0xa436, 0xacd0, 0xa438, 0x0108,
+	0xa436, 0xacce, 0xa438, 0x6807, 0xa436, 0xacd0, 0xa438, 0x0100,
+	0xa436, 0xacce, 0xa438, 0x688f, 0xa436, 0xacd0, 0xa438, 0x0188,
+	0xa436, 0xacce, 0xa438, 0x7027, 0xa436, 0xacd0, 0xa438, 0x0120,
+	0xa436, 0xacce, 0xa438, 0x702f, 0xa436, 0xacd0, 0xa438, 0x0128,
+	0xa436, 0xacce, 0xa438, 0x7847, 0xa436, 0xacd0, 0xa438, 0x0140,
+	0xa436, 0xacce, 0xa438, 0x784f, 0xa436, 0xacd0, 0xa438, 0x0148,
+	0xa436, 0xacce, 0xa438, 0x80a7, 0xa436, 0xacd0, 0xa438, 0x01a0,
+	0xa436, 0xacce, 0xa438, 0x88af, 0xa436, 0xacd0, 0xa438, 0x01a8,
+	0xa436, 0xacce, 0xa438, 0x8067, 0xa436, 0xacd0, 0xa438, 0x0161,
+	0xa436, 0xacce, 0xa438, 0x886f, 0xa436, 0xacd0, 0xa438, 0x0169,
+	0xa436, 0xacce, 0xa438, 0xfb57, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0xfb5f, 0xa436, 0xacd0, 0xa438, 0x07ff,
+	0xa436, 0xacce, 0xa438, 0x6017, 0xa436, 0xacd0, 0xa438, 0x0110,
+	0xa436, 0xacce, 0xa438, 0x601f, 0xa436, 0xacd0, 0xa438, 0x0118,
+	0xa436, 0xacce, 0xa438, 0x6837, 0xa436, 0xacd0, 0xa438, 0x0130,
+	0xa436, 0xacce, 0xa438, 0x683f, 0xa436, 0xacd0, 0xa438, 0x0138,
+	0xa436, 0xacce, 0xa438, 0x7097, 0xa436, 0xacd0, 0xa438, 0x0190,
+	0xa436, 0xacce, 0xa438, 0x705f, 0xa436, 0xacd0, 0xa438, 0x0158,
+	0xa436, 0xacce, 0xa438, 0x7857, 0xa436, 0xacd0, 0xa438, 0x0150,
+	0xa436, 0xacce, 0xa438, 0x789f, 0xa436, 0xacd0, 0xa438, 0x0198,
+	0xa436, 0xacce, 0xa438, 0x90b7, 0xa436, 0xacd0, 0xa438, 0x01b0,
+	0xa436, 0xacce, 0xa438, 0x98bf, 0xa436, 0xacd0, 0xa438, 0x01b8,
+	0xa436, 0xacce, 0xa438, 0x9077, 0xa436, 0xacd0, 0xa438, 0x1171,
+	0xa436, 0xacce, 0xa438, 0x987f, 0xa436, 0xacd0, 0xa438, 0x1179,
+	0xa436, 0xacca, 0xa438, 0x0004, 0xa436, 0xacc6, 0xa438, 0x0015,
+	0xa436, 0xacc8, 0xa438, 0xc000, 0xa436, 0xacc8, 0xa438, 0x0000,
+	0xFFFF, 0xFFFF
+};
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125d_1_1,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125d_1_1));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_2(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125d_1_2,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125d_1_2));
+}
+
+static void
+rtl8125_real_set_phy_mcu_8125d_1_3(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_ram_code(hw, phy_mcu_ram_code_8125d_1_3,
+	                             ARRAY_SIZE(phy_mcu_ram_code_8125d_1_3));
+}
+
+void
+rtl8125_set_phy_mcu_8125d_1(struct rtl8125_hw *hw)
+{
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125d_1_1(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125d_1_2(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+
+	rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_real_set_phy_mcu_8125d_1_3(hw);
+
+	rtl8125_clear_phy_mcu_patch_request(hw);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/base/rtl8125d_mcu.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _RTL8125D_MCU_H_
+#define _RTL8125D_MCU_H_
+
+void rtl8125_set_mac_mcu_8125d_1(struct rtl8125_hw *hw);
+void rtl8125_set_mac_mcu_8125d_2(struct rtl8125_hw *hw);
+
+void rtl8125_set_phy_mcu_8125d_1(struct rtl8125_hw *hw);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/meson.build
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: BSD-3-Clause
+# Copyright(c) 2024 Realtek Corporation. All rights reserved
+
+sources = files(
+		'r8125_ethdev.c',
+		'r8125_rxtx.c',
+		'r8125_hw.c',
+		'r8125_phy.c',
+		'r8125_dash.c',
+		'base/rtl8125a.c',
+		'base/rtl8125a_mcu.c',
+		'base/rtl8125b.c',
+		'base/rtl8125b_mcu.c',
+		'base/rtl8125bp.c',
+		'base/rtl8125bp_mcu.c',
+		'base/rtl8125d.c',
+		'base/rtl8125d_mcu.c',
+)
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_base.h
@@ -0,0 +1,634 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _R8125_BASE_H_
+#define _R8125_BASE_H_
+
+#include <stdint.h>
+#include <stddef.h>
+#include <inttypes.h>
+#include <string.h>
+
+#include <rte_common.h>
+#include <rte_cycles.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_byteorder.h>
+#include <rte_io.h>
+#include <rte_version.h>
+
+typedef uint8_t        u8;
+typedef int8_t         s8;
+typedef uint16_t       u16;
+typedef int16_t        s16;
+typedef uint32_t       u32;
+typedef int32_t        s32;
+typedef uint64_t       u64;
+
+enum mcfg {
+	CFG_METHOD_2 = 2,
+	CFG_METHOD_3,
+	CFG_METHOD_4,
+	CFG_METHOD_5,
+	CFG_METHOD_6,
+	CFG_METHOD_7,
+	CFG_METHOD_8,
+	CFG_METHOD_9,
+	CFG_METHOD_10,
+	CFG_METHOD_11,
+	CFG_METHOD_DEFAULT,
+	CFG_METHOD_MAX
+};
+
+enum RTL8125_chipset_name {
+	RTL8125A = 0,
+	RTL8125B,
+	RTL8168KB,
+	RTL8125BP,
+	RTL8125D,
+	UNKNOWN
+};
+
+enum bits {
+	BIT_0 = (1UL << 0),
+	BIT_1 = (1UL << 1),
+	BIT_2 = (1UL << 2),
+	BIT_3 = (1UL << 3),
+	BIT_4 = (1UL << 4),
+	BIT_5 = (1UL << 5),
+	BIT_6 = (1UL << 6),
+	BIT_7 = (1UL << 7),
+	BIT_8 = (1UL << 8),
+	BIT_9 = (1UL << 9),
+	BIT_10 = (1UL << 10),
+	BIT_11 = (1UL << 11),
+	BIT_12 = (1UL << 12),
+	BIT_13 = (1UL << 13),
+	BIT_14 = (1UL << 14),
+	BIT_15 = (1UL << 15),
+	BIT_16 = (1UL << 16),
+	BIT_17 = (1UL << 17),
+	BIT_18 = (1UL << 18),
+	BIT_19 = (1UL << 19),
+	BIT_20 = (1UL << 20),
+	BIT_21 = (1UL << 21),
+	BIT_22 = (1UL << 22),
+	BIT_23 = (1UL << 23),
+	BIT_24 = (1UL << 24),
+	BIT_25 = (1UL << 25),
+	BIT_26 = (1UL << 26),
+	BIT_27 = (1UL << 27),
+	BIT_28 = (1UL << 28),
+	BIT_29 = (1UL << 29),
+	BIT_30 = (1UL << 30),
+	BIT_31 = (1UL << 31)
+};
+
+enum effuse {
+	EFUSE_NOT_SUPPORT = 0,
+	EFUSE_SUPPORT_V1,
+	EFUSE_SUPPORT_V2,
+	EFUSE_SUPPORT_V3,
+	EFUSE_SUPPORT_V4,
+};
+
+enum RTL8125_registers {
+	MAC0            = 0x00,     /* Ethernet hardware address */
+	MAC4            = 0x04,
+	MAR0            = 0x08,     /* Multicast filter */
+	CounterAddrLow  = 0x10,
+	CounterAddrHigh = 0x14,
+	CustomLED       = 0x18,
+	TxDescStartAddrLow  = 0x20,
+	TxDescStartAddrHigh = 0x24,
+	TxHDescStartAddrLow = 0x28,
+	TxHDescStartAddrHigh = 0x2C,
+	FLASH           = 0x30,
+	INT_CFG0_8125   = 0x34,
+	ERSR            = 0x36,
+	ChipCmd         = 0x37,
+	TxPoll          = 0x38,
+	IntrMask        = 0x3C,
+	IntrStatus      = 0x3E,
+	TxConfig        = 0x40,
+	RxConfig        = 0x44,
+	TCTR            = 0x48,
+	Cfg9346         = 0x50,
+	Config0         = 0x51,
+	Config1         = 0x52,
+	Config2         = 0x53,
+	Config3         = 0x54,
+	Config4         = 0x55,
+	Config5         = 0x56,
+	TDFNR           = 0x57,
+	TimeInt0        = 0x58,
+	TimeInt1        = 0x5C,
+	PHYAR           = 0x60,
+	CSIDR           = 0x64,
+	CSIAR           = 0x68,
+	PHYstatus       = 0x6C,
+	MACDBG          = 0x6D,
+	GPIO            = 0x6E,
+	PMCH            = 0x6F,
+	ERIDR           = 0x70,
+	ERIAR           = 0x74,
+	INT_CFG1_8125   = 0x7A,
+	EPHY_RXER_NUM   = 0x7C,
+	EPHYAR          = 0x80,
+	TimeInt2        = 0x8C,
+	OCPDR           = 0xB0,
+	MACOCP          = 0xB0,
+	OCPAR           = 0xB4,
+	SecMAC0         = 0xB4,
+	SecMAC4         = 0xB8,
+	PHYOCP          = 0xB8,
+	DBG_reg         = 0xD1,
+	TwiCmdReg       = 0xD2,
+	MCUCmd_reg      = 0xD3,
+	RxMaxSize       = 0xDA,
+	EFUSEAR         = 0xDC,
+	CPlusCmd        = 0xE0,
+	IntrMitigate    = 0xE2,
+	RxDescAddrLow   = 0xE4,
+	RxDescAddrHigh  = 0xE8,
+	MTPS            = 0xEC,
+	FuncEvent       = 0xF0,
+	PPSW            = 0xF2,
+	FuncEventMask   = 0xF4,
+	TimeInt3        = 0xF4,
+	FuncPresetState = 0xF8,
+	CMAC_IBCR0      = 0xF8,
+	CMAC_IBCR2      = 0xF9,
+	CMAC_IBIMR0     = 0xFA,
+	CMAC_IBISR0     = 0xFB,
+	FuncForceEvent  = 0xFC,
+
+	/* 8125 */
+	IMR0_8125          = 0x38,
+	ISR0_8125          = 0x3C,
+	TPPOLL_8125        = 0x90,
+	IMR1_8125          = 0x800,
+	ISR1_8125          = 0x802,
+	IMR2_8125          = 0x804,
+	ISR2_8125          = 0x806,
+	IMR3_8125          = 0x808,
+	ISR3_8125          = 0x80A,
+	BACKUP_ADDR0_8125  = 0x19E0,
+	BACKUP_ADDR1_8125  = 0X19E4,
+	TCTR0_8125         = 0x0048,
+	TCTR1_8125         = 0x004C,
+	TCTR2_8125         = 0x0088,
+	TCTR3_8125         = 0x001C,
+	TIMER_INT0_8125    = 0x0058,
+	TIMER_INT1_8125    = 0x005C,
+	TIMER_INT2_8125    = 0x008C,
+	TIMER_INT3_8125    = 0x00F4,
+	INT_MITI_V2_0_RX   = 0x0A00,
+	INT_MITI_V2_0_TX   = 0x0A02,
+	INT_MITI_V2_1_RX   = 0x0A08,
+	INT_MITI_V2_1_TX   = 0x0A0A,
+	IMR_V2_CLEAR_REG_8125 = 0x0D00,
+	ISR_V2_8125           = 0x0D04,
+	IMR_V2_SET_REG_8125   = 0x0D0C,
+	TDU_STA_8125          = 0x0D08,
+	RDU_STA_8125          = 0x0D0A,
+	SW_TAIL_PTR0_8125BP   = 0x0D30,
+	SW_TAIL_PTR1_8125BP   = 0x0D38,
+	HW_CLO_PTR0_8125BP = 0x0D34,
+	HW_CLO_PTR1_8125BP = 0x0D3C,
+	DOUBLE_VLAN_CONFIG = 0x1000,
+	TX_NEW_CTRL        = 0x203E,
+	TNPDS_Q1_LOW_8125  = 0x2100,
+	PLA_TXQ0_IDLE_CREDIT = 0x2500,
+	PLA_TXQ1_IDLE_CREDIT = 0x2504,
+	SW_TAIL_PTR0_8125  = 0x2800,
+	HW_CLO_PTR0_8125   = 0x2802,
+	RDSAR_Q1_LOW_8125  = 0x4000,
+	RSS_CTRL_8125      = 0x4500,
+	Q_NUM_CTRL_8125    = 0x4800,
+	RSS_KEY_8125       = 0x4600,
+	RSS_INDIRECTION_TBL_8125_V2 = 0x4700,
+	EEE_TXIDLE_TIMER_8125 = 0x6048,
+
+	/* TCAM */
+	TCAM_NOTVALID_ADDR  = 0xA000,
+	TCAM_VALID_ADDR     = 0xA800,
+	TCAM_MAC_ADDR       = 448,
+	TCAM_VLAN_TAG       = 496,
+	/* TCAM V2 */
+	TCAM_NOTVALID_ADDR_V2 = 0xA000,
+	TCAM_VALID_ADDR_V2    = 0xB000,
+	TCAM_MAC_ADDR_V2      = 0x00,
+	TCAM_VLAN_TAG_V2      = 0x03,
+	/* ipc2 */
+	IB2SOC_SET     = 0x0010,
+	IB2SOC_DATA    = 0x0014,
+	IB2SOC_CMD     = 0x0018,
+	IB2SOC_IMR     = 0x001C,
+};
+
+enum RTL8125_register_content {
+	/* Interrupt status bits */
+	SYSErr      = 0x8000,
+	PCSTimeout  = 0x4000,
+	SWInt       = 0x0100,
+	TxDescUnavail = 0x0080,
+	RxFIFOOver  = 0x0040,
+	LinkChg     = 0x0020,
+	RxDescUnavail = 0x0010,
+	TxErr       = 0x0008,
+	TxOK        = 0x0004,
+	RxErr       = 0x0002,
+	RxOK        = 0x0001,
+
+	/* RX status desc */
+	RxRWT  = (1UL << 22),
+	RxRES  = (1UL << 21),
+	RxRUNT = (1UL << 20),
+	RxCRC  = (1UL << 19),
+
+	/* ChipCmd bits */
+	StopReq    = 0x80,
+	CmdReset   = 0x10,
+	CmdRxEnb   = 0x08,
+	CmdTxEnb   = 0x04,
+	RxBufEmpty = 0x01,
+
+	/* Cfg9346 bits */
+	Cfg9346_Lock = 0x00,
+	Cfg9346_Unlock = 0xC0,
+	Cfg9346_EEDO = (1UL << 0),
+	Cfg9346_EEDI = (1UL << 1),
+	Cfg9346_EESK = (1UL << 2),
+	Cfg9346_EECS = (1UL << 3),
+	Cfg9346_EEM0 = (1UL << 6),
+	Cfg9346_EEM1 = (1UL << 7),
+
+	/* RX mode bits */
+	AcceptErr       = 0x20,
+	AcceptRunt      = 0x10,
+	AcceptBroadcast = 0x08,
+	AcceptMulticast = 0x04,
+	AcceptMyPhys    = 0x02,
+	AcceptAllPhys   = 0x01,
+
+	/* Transmit priority polling */
+	HPQ    = 0x80,
+	NPQ    = 0x40,
+	FSWInt = 0x01,
+
+	/* RX config bits */
+	Reserved2_shift     = 13,
+	RxCfgDMAShift       = 8,
+	EnableRxDescV3      = (1 << 24),
+	EnableOuterVlan     = (1 << 23),
+	EnableInnerVlan     = (1 << 22),
+	RxCfg_128_int_en    = (1 << 15),
+	RxCfg_fet_multi_en  = (1 << 14),
+	RxCfg_half_refetch  = (1 << 13),
+	RxCfg_pause_slot_en = (1 << 11),
+	RxCfg_9356SEL       = (1 << 6),
+	EnableRxDescV4_0    = (1 << 1), /* Not in rcr */
+
+	/* TX config bits */
+	TxInterFrameGapShift = 24,
+	TxDMAShift = 8, /* DMA burst value (0-7) is shift this many bits. */
+	TxMACLoopBack = (1UL << 17),  /* MAC loopback */
+
+	/* Config1 register */
+	LEDS1       = (1UL << 7),
+	LEDS0       = (1UL << 6),
+	Speed_down  = (1UL << 4),
+	MEMMAP      = (1UL << 3),
+	IOMAP       = (1UL << 2),
+	VPD         = (1UL << 1),
+	PMEnable    = (1UL << 0), /* Power management enable */
+
+	/* Config2 register */
+	PMSTS_En    = (1UL << 5),
+
+	/* Config3 register */
+	Isolate_en  = (1UL << 12), /* Isolate enable */
+	MagicPacket = (1UL << 5),  /* Wake up when receives a magic packet */
+	LinkUp      = (1UL << 4),  /* This bit is reserved in RTL8125B. */
+
+	/* Wake up when the cable connection is re-established */
+	ECRCEN      = (1UL << 3), /* This bit is reserved in RTL8125B. */
+	Jumbo_En0   = (1UL << 2), /* This bit is reserved in RTL8125B. */
+	RDY_TO_L23  = (1UL << 1), /* This bit is reserved in RTL8125B. */
+	Beacon_en   = (1UL << 0), /* This bit is reserved in RTL8125B. */
+
+	/* Config4 register */
+	Jumbo_En1   = (1UL << 1), /* This bit is reserved in RTL8125B. */
+
+	/* Config5 register */
+	BWF         = (1UL << 6), /* Accept broadcast wakeup frame */
+	MWF         = (1UL << 5), /* Accept multicast wakeup frame */
+	UWF         = (1UL << 4), /* Accept unicast wakeup frame */
+	LanWake     = (1UL << 1), /* LanWake enable/disable */
+	PMEStatus   = (1UL << 0), /* PME status can be reset by PCI RST#. */
+
+	/* CPlusCmd */
+	EnableBist      = (1UL << 15),
+	Macdbgo_oe      = (1UL << 14),
+	Normal_mode     = (1UL << 13),
+	Force_halfdup   = (1UL << 12),
+	Force_rxflow_en = (1UL << 11),
+	Force_txflow_en = (1UL << 10),
+	Cxpl_dbg_sel    = (1UL << 9), /* This bit is reserved in RTL8125B. */
+	ASF             = (1UL << 8), /* This bit is reserved in RTL8125C. */
+	PktCntrDisable  = (1UL << 7),
+	RxVlan          = (1UL << 6),
+	RxChkSum        = (1UL << 5),
+	Macdbgo_sel = 0x001C,
+	INTT_0      = 0x0000,
+	INTT_1      = 0x0001,
+	INTT_2      = 0x0002,
+	INTT_3      = 0x0003,
+
+	/* PHY status */
+	PowerSaveStatus = 0x80,
+	_2500bpsF       = 0x400,
+	TxFlowCtrl      = 0x40,
+	RxFlowCtrl      = 0x20,
+	_1000bpsF       = 0x10,
+	_100bps         = 0x08,
+	_10bps          = 0x04,
+	LinkStatus      = 0x02,
+	FullDup         = 0x01,
+
+	/* DBG reg */
+	Fix_Nak_1 = (1UL << 4),
+	Fix_Nak_2 = (1UL << 3),
+	DBGPIN_E2 = (1UL << 0),
+
+	/* Reset counter command */
+	CounterReset = 0x1,
+	/* Dump counter command */
+	CounterDump = 0x8,
+
+	/* PHY access */
+	PHYAR_Flag      = 0x80000000,
+	PHYAR_Write     = 0x80000000,
+	PHYAR_Read      = 0x00000000,
+	PHYAR_Reg_Mask  = 0x1f,
+	PHYAR_Reg_shift = 16,
+	PHYAR_Data_Mask = 0xffff,
+
+	/* EPHY access */
+	EPHYAR_Flag        = 0x80000000,
+	EPHYAR_Write       = 0x80000000,
+	EPHYAR_Read        = 0x00000000,
+	EPHYAR_Reg_Mask    = 0x3f,
+	EPHYAR_Reg_Mask_v2 = 0x7f,
+	EPHYAR_Reg_shift   = 16,
+	EPHYAR_Data_Mask   = 0xffff,
+
+	/* CSI access */
+	CSIAR_Flag         = 0x80000000,
+	CSIAR_Write        = 0x80000000,
+	CSIAR_Read         = 0x00000000,
+	CSIAR_ByteEn       = 0x0f,
+	CSIAR_ByteEn_shift = 12,
+	CSIAR_Addr_Mask    = 0x0fff,
+
+	/* ERI access */
+	ERIAR_Flag         = 0x80000000,
+	ERIAR_Write        = 0x80000000,
+	ERIAR_Read         = 0x00000000,
+	ERIAR_Addr_Align   = 4, /* ERI access register address must be 4 byte alignment. */
+	ERIAR_ExGMAC       = 0,
+	ERIAR_MSIX         = 1,
+	ERIAR_ASF          = 2,
+	ERIAR_OOB          = 2,
+	ERIAR_Type_shift   = 16,
+	ERIAR_ByteEn       = 0x0f,
+	ERIAR_ByteEn_shift = 12,
+
+	/* OCP GPHY access */
+	OCPDR_Write           = 0x80000000,
+	OCPDR_Read            = 0x00000000,
+	OCPDR_Reg_Mask        = 0xFF,
+	OCPDR_Data_Mask       = 0xFFFF,
+	OCPDR_GPHY_Reg_shift  = 16,
+	OCPAR_Flag            = 0x80000000,
+	OCPAR_GPHY_Write      = 0x8000F060,
+	OCPAR_GPHY_Read       = 0x0000F060,
+	OCPR_Write            = 0x80000000,
+	OCPR_Read             = 0x00000000,
+	OCPR_Addr_Reg_shift   = 16,
+	OCPR_Flag             = 0x80000000,
+	OCP_STD_PHY_BASE_PAGE = 0x0A40,
+
+	/* MCU command */
+	Now_is_oob   = (1UL << 7),
+	Txfifo_empty = (1UL << 5),
+	Rxfifo_empty = (1UL << 4),
+
+	/* E-FUSE access */
+	EFUSE_WRITE       = 0x80000000,
+	EFUSE_WRITE_OK    = 0x00000000,
+	EFUSE_READ        = 0x00000000,
+	EFUSE_READ_OK     = 0x80000000,
+	EFUSE_WRITE_V3    = 0x40000000,
+	EFUSE_WRITE_OK_V3 = 0x00000000,
+	EFUSE_READ_V3     = 0x80000000,
+	EFUSE_READ_OK_V3  = 0x00000000,
+	EFUSE_Reg_Mask    = 0x03FF,
+	EFUSE_Reg_Shift   = 8,
+	EFUSE_Check_Cnt   = 300,
+	EFUSE_READ_FAIL   = 0xFF,
+	EFUSE_Data_Mask   = 0x000000FF,
+
+	/* GPIO */
+	GPIO_en = (1UL << 0),
+
+	/* New interrupt bits */
+	INT_CFG0_ENABLE_8125            = (1 << 0),
+	INT_CFG0_TIMEOUT0_BYPASS_8125   = (1 << 1),
+	INT_CFG0_MITIGATION_BYPASS_8125 = (1 << 2),
+	ISRIMR_V2_ROK_Q0     = (1 << 0),
+	ISRIMR_TOK_Q0        = (1 << 16),
+	ISRIMR_TOK_Q1        = (1 << 18),
+	ISRIMR_V2_LINKCHG    = (1 << 21),
+
+};
+
+/* Flow control settings */
+enum rtl8125_fc_mode {
+	rtl8125_fc_none = 0,
+	rtl8125_fc_rx_pause,
+	rtl8125_fc_tx_pause,
+	rtl8125_fc_full,
+	rtl8125_fc_default
+};
+
+struct rtl8125_counters {
+	u64 tx_packets;
+	u64 rx_packets;
+	u64 tx_errors;
+	u32 rx_errors;
+	u16 rx_missed;
+	u16 align_errors;
+	u32 tx_one_collision;
+	u32 tx_multi_collision;
+	u64 rx_unicast;
+	u64 rx_broadcast;
+	u32 rx_multicast;
+	u16 tx_aborted;
+	u16 tx_underun;
+};
+
+#define TRUE  1
+#define FALSE 0
+
+#define R8125_REALTEK_VENDOR_ID 0x10EC
+
+#define R8125_MAX_TX_DESC 4096
+#define R8125_MAX_RX_DESC 4096
+#define R8125_MIN_TX_DESC 64
+#define R8125_MIN_RX_DESC 64
+
+#define R8125_RING_ALIGN 256
+
+#define R8125_MAX_TX_SEG 64
+#define R8125_DESC_ALIGN 64
+
+#define R8125_RX_FREE_THRESH 32
+#define R8125_TX_FREE_THRESH 32
+
+#define VLAN_TAG_SIZE   4
+#define MAC_ADDR_LEN    RTE_ETHER_ADDR_LEN
+
+#define RX_BUF_SIZE     0x05F3  /* 0x05F3 = 1522bye + 1 */
+#define ETH_HLEN        14
+#define VLAN_HLEN       4
+#define ETH_DATA_LEN    1500
+
+/*
+ * The overhead from MTU to max frame size.
+ * Considering VLAN so a tag needs to be counted.
+ */
+#define R8125_ETH_OVERHEAD (RTE_ETHER_HDR_LEN + RTE_ETHER_CRC_LEN + VLAN_TAG_SIZE)
+
+#define SPEED_10	10
+#define SPEED_100	100
+#define SPEED_1000	1000
+#define SPEED_2500	2500
+
+#define DUPLEX_HALF	1
+#define DUPLEX_FULL	2
+
+#define AUTONEG_ENABLE	1
+#define AUTONEG_DISABLE	0
+
+#define ADVERTISE_10_HALF		0x0001
+#define ADVERTISE_10_FULL		0x0002
+#define ADVERTISE_100_HALF		0x0004
+#define ADVERTISE_100_FULL		0x0008
+#define ADVERTISE_1000_HALF		0x0010 /* Not used, just FYI */
+#define ADVERTISE_1000_FULL		0x0020
+#define ADVERTISE_2500_HALF             0x0040 /* NOT used, just FYI */
+#define ADVERTISE_2500_FULL             0x0080
+
+#define RTL8125_ALL_SPEED_DUPLEX (ADVERTISE_10_HALF | ADVERTISE_10_FULL | \
+        ADVERTISE_100_HALF | ADVERTISE_100_FULL | ADVERTISE_1000_FULL | \
+        ADVERTISE_2500_FULL)
+
+#define Reserved2_data  7
+#define RX_DMA_BURST_unlimited  7   /* Maximum PCI burst, '7' is unlimited */
+#define RX_DMA_BURST_512    5
+#define RX_DMA_BURST_256    4
+#define TX_DMA_BURST_unlimited  7
+#define TX_DMA_BURST_1024   6
+#define TX_DMA_BURST_512    5
+#define TX_DMA_BURST_256    4
+#define TX_DMA_BURST_128    3
+#define TX_DMA_BURST_64     2
+#define TX_DMA_BURST_32     1
+#define TX_DMA_BURST_16     0
+#define Reserved1_data  0x3F
+#define RxPacketMaxSize 0x3FE8  /* 16K - 1 - ETH_HLEN - VLAN - CRC... */
+#define Jumbo_Frame_1k  ETH_DATA_LEN
+#define Jumbo_Frame_2k  (2*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_3k  (3*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_4k  (4*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_5k  (5*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_6k  (6*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_7k  (7*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_8k  (8*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define Jumbo_Frame_9k  (9*1024 - ETH_HLEN - VLAN_HLEN - RTE_ETHER_CRC_LEN)
+#define InterFrameGap   0x03    /* 3 means InterFrameGap = the shortest one */
+#define RxEarly_off_V1  (0x07 << 11)
+#define RxEarly_off_V2  (1 << 11)
+#define Rx_Single_fetch_V2 (1 << 14)
+#define Rx_Close_Multiple  (1 << 21)
+#define Rx_Fetch_Number_8  (1 << 30)
+
+#define DMA_BIT_MASK(n) (((n) == 64) ? ~0ULL : ((1ULL<<(n))-1))
+
+/* Ram code version */
+#define NIC_RAMCODE_VERSION_CFG_METHOD_2  (0x0b11)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_3  (0x0b33)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_4  (0x0b17)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_5  (0x0b99)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_8  (0x0013)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_9  (0x0001)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_10 (0x0016)
+#define NIC_RAMCODE_VERSION_CFG_METHOD_11 (0x0001)
+
+#ifndef WRITE_ONCE
+#define WRITE_ONCE(var, val) (*((volatile typeof(val) *)(&(var))) = (val))
+#endif
+#ifndef READ_ONCE
+#define READ_ONCE(var) (*((volatile typeof(var) *)(&(var))))
+#endif
+
+#define RTL_PCI_REG_ADDR(hw, reg) \
+	((u8 *)(hw)->mmio_addr + (reg))
+
+#define RTL_R32(hw, reg) \
+	rtl_read32(RTL_PCI_REG_ADDR(hw, reg))
+
+#define RTL_R16(hw, reg) \
+	rtl_read16(RTL_PCI_REG_ADDR(hw, reg))
+
+#define RTL_R8(hw, reg) \
+	rte_read8(RTL_PCI_REG_ADDR(hw, reg))
+
+#define RTL_W32(hw, reg, val) \
+	rte_write32((rte_cpu_to_le_32(val)), RTL_PCI_REG_ADDR(hw, reg))
+
+#define RTL_W16(hw, reg, val) \
+	rte_write16((rte_cpu_to_le_16(val)), RTL_PCI_REG_ADDR(hw, reg))
+
+#define RTL_W8(hw, reg, val) \
+	rte_write8((val), RTL_PCI_REG_ADDR(hw, reg))
+
+#define mdelay rte_delay_ms
+#define udelay rte_delay_us
+#define msleep rte_delay_ms
+#define usleep rte_delay_us
+
+#if RTE_VERSION >= RTE_VERSION_NUM(20, 8, 0, 0)
+#define rtl8125_eth_dma_zone_free(eth_dev, name, queue_id) \
+    rte_eth_dma_zone_free(eth_dev, name, queue_id)
+#else
+#define rtl8125_eth_dma_zone_free(eth_dev, name, queue_id)
+#endif
+
+static inline u32
+rtl_read32(volatile void *addr)
+{
+	return rte_le_to_cpu_32(rte_read32(addr));
+}
+
+static inline u32
+rtl_read16(volatile void *addr)
+{
+	return rte_le_to_cpu_16(rte_read16(addr));
+}
+
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_dash.c
@@ -0,0 +1,227 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+
+#include "r8125_base.h"
+#include "r8125_dash.h"
+#include "r8125_hw.h"
+
+bool
+rtl8125_is_allow_access_dash_ocp(struct rtl8125_hw *hw)
+{
+	bool allow_access = false;
+	u16 mac_ocp_data;
+
+	if (!HW_DASH_SUPPORT_DASH(hw))
+		goto exit;
+
+	allow_access = true;
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xd460);
+		if (mac_ocp_data == 0xffff || !(mac_ocp_data & BIT_0))
+			allow_access = false;
+		break;
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xd4c0);
+		if (mac_ocp_data == 0xffff || (mac_ocp_data & BIT_3))
+			allow_access = false;
+		break;
+	default:
+		goto exit;
+	}
+exit:
+	return allow_access;
+}
+
+static u32
+rtl8125_get_dash_fw_ver(struct rtl8125_hw *hw)
+{
+	u32 ver = 0xffffffff;
+
+	if (FALSE == HW_DASH_SUPPORT_GET_FIRMWARE_VERSION(hw))
+		goto exit;
+
+	ver = rtl8125_ocp_read(hw, OCP_REG_FIRMWARE_MAJOR_VERSION, 4);
+
+exit:
+	return ver;
+}
+
+static int
+_rtl8125_check_dash(struct rtl8125_hw *hw)
+{
+	if (!hw->AllowAccessDashOcp)
+		return 0;
+
+	if (HW_DASH_SUPPORT_TYPE_2(hw) || HW_DASH_SUPPORT_TYPE_4(hw)) {
+		if (rtl8125_ocp_read(hw, 0x128, 1) & BIT_0)
+			return 1;
+	}
+
+	return 0;
+}
+
+int
+rtl8125_check_dash(struct rtl8125_hw *hw)
+{
+	if (_rtl8125_check_dash(hw)) {
+		u32 ver = rtl8125_get_dash_fw_ver(hw);
+		if (!(ver == 0 || ver == 0xffffffff))
+			return 1;
+	}
+
+	return 0;
+}
+
+static void
+rtl8125_dash2_disable_tx(struct rtl8125_hw *hw)
+{
+	u16 wait_cnt = 0;
+	u8 tmp_uchar;
+
+	if (!HW_DASH_SUPPORT_CMAC(hw))
+		return;
+
+	if (!hw->DASH)
+		return;
+
+	/* Disable oob Tx */
+	RTL_CMAC_W8(hw, CMAC_IBCR2, RTL_CMAC_R8(hw, CMAC_IBCR2) & ~BIT_0);
+
+	/* Wait oob Tx disable */
+	do {
+		tmp_uchar = RTL_CMAC_R8(hw, CMAC_IBISR0);
+		if (tmp_uchar & ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE)
+			break;
+
+		udelay(50);
+		wait_cnt++;
+	} while (wait_cnt < 2000);
+
+	/* Clear ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE */
+	RTL_CMAC_W8(hw, CMAC_IBISR0, RTL_CMAC_R8(hw, CMAC_IBISR0) |
+	            ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE);
+}
+
+static void
+rtl8125_dash2_disable_rx(struct rtl8125_hw *hw)
+{
+	if (!HW_DASH_SUPPORT_CMAC(hw))
+		return;
+
+	if (!hw->DASH)
+		return;
+
+	RTL_CMAC_W8(hw, CMAC_IBCR0, RTL_CMAC_R8(hw, CMAC_IBCR0) & ~BIT_0);
+}
+
+void
+rtl8125_dash2_disable_txrx(struct rtl8125_hw *hw)
+{
+	if (!HW_DASH_SUPPORT_CMAC(hw))
+		return;
+
+	rtl8125_dash2_disable_tx(hw);
+	rtl8125_dash2_disable_rx(hw);
+}
+
+static void
+rtl8125_notify_dash_oob_cmac(struct rtl8125_hw *hw, u32 cmd)
+{
+	u32 tmp_value;
+
+	if (!HW_DASH_SUPPORT_CMAC(hw))
+		return;
+
+	rtl8125_ocp_write(hw, 0x180, 4, cmd);
+	tmp_value = rtl8125_ocp_read(hw, 0x30, 4);
+	tmp_value |= BIT_0;
+	rtl8125_ocp_write(hw, 0x30, 4, tmp_value);
+}
+
+static void
+rtl8125_notify_dash_oob_ipc2(struct rtl8125_hw *hw, u32 cmd)
+{
+	if (FALSE == HW_DASH_SUPPORT_TYPE_4(hw))
+		return;
+
+	rtl8125_ocp_write(hw, IB2SOC_DATA, 4, cmd);
+	rtl8125_ocp_write(hw, IB2SOC_CMD, 4, 0x00);
+	rtl8125_ocp_write(hw, IB2SOC_SET, 4, 0x01);
+}
+
+static void
+rtl8125_notify_dash_oob(struct rtl8125_hw *hw, u32 cmd)
+{
+	switch (hw->HwSuppDashVer) {
+	case 2:
+	case 3:
+		rtl8125_notify_dash_oob_cmac(hw, cmd);
+		break;
+	case 4:
+		rtl8125_notify_dash_oob_ipc2(hw, cmd);
+		break;
+	default:
+		break;
+	}
+}
+
+static int
+rtl8125_wait_dash_fw_ready(struct rtl8125_hw *hw)
+{
+	int rc = -1;
+	int timeout;
+
+	if (!hw->DASH)
+		goto out;
+
+	for (timeout = 0; timeout < 10; timeout++) {
+		mdelay(10);
+		if (rtl8125_ocp_read(hw, 0x124, 1) & BIT_0) {
+			rc = 1;
+			goto out;
+		}
+	}
+
+	rc = 0;
+
+out:
+	return rc;
+}
+
+void
+rtl8125_driver_start(struct rtl8125_hw *hw)
+{
+	if (!hw->AllowAccessDashOcp)
+		return;
+
+	rtl8125_notify_dash_oob(hw, OOB_CMD_DRIVER_START);
+
+	rtl8125_wait_dash_fw_ready(hw);
+}
+
+void
+rtl8125_driver_stop(struct rtl8125_hw *hw)
+{
+	if (!hw->AllowAccessDashOcp)
+		return;
+
+	if (HW_DASH_SUPPORT_CMAC(hw))
+		rtl8125_dash2_disable_txrx(hw);
+
+	rtl8125_notify_dash_oob(hw, OOB_CMD_DRIVER_STOP);
+
+	rtl8125_wait_dash_fw_ready(hw);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_dash.h
@@ -0,0 +1,64 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _R8125_DASH_H_
+#define _R8125_DASH_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <rte_ethdev.h>
+#include <rte_ethdev_core.h>
+
+#include "r8125_base.h"
+#include "r8125_hw.h"
+
+
+#define HW_DASH_SUPPORT_DASH(_M)        ((_M)->HwSuppDashVer > 0)
+#define HW_DASH_SUPPORT_TYPE_1(_M)      ((_M)->HwSuppDashVer == 1)
+#define HW_DASH_SUPPORT_TYPE_2(_M)      ((_M)->HwSuppDashVer == 2)
+#define HW_DASH_SUPPORT_TYPE_3(_M)      ((_M)->HwSuppDashVer == 3)
+#define HW_DASH_SUPPORT_TYPE_4(_M)      ((_M)->HwSuppDashVer == 4)
+#define HW_DASH_SUPPORT_CMAC(_M)        (HW_DASH_SUPPORT_TYPE_2(_M) || HW_DASH_SUPPORT_TYPE_3(_M))
+#define HW_DASH_SUPPORT_IPC2(_M)        (HW_DASH_SUPPORT_TYPE_4(_M))
+#define HW_DASH_SUPPORT_GET_FIRMWARE_VERSION(_M) (HW_DASH_SUPPORT_TYPE_2(_M) || \
+                                                  HW_DASH_SUPPORT_TYPE_3(_M) || \
+                                                  HW_DASH_SUPPORT_TYPE_4(_M))
+
+#define OOB_CMD_DRIVER_START 0x05
+#define OOB_CMD_DRIVER_STOP  0x06
+
+#define OCP_REG_FIRMWARE_MAJOR_VERSION 0x120
+
+#define ISRIMR_DASH_TYPE2_TX_DISABLE_IDLE BIT_5
+
+/* CMAC write/read MMIO register */
+#define RTL_CMAC_REG_ADDR(hw, reg) \
+	((u8 *)(hw)->cmac_ioaddr + (reg))
+
+#define RTL_CMAC_R32(hw, reg) \
+	rtl_read32(RTL_CMAC_REG_ADDR(hw, reg))
+
+#define RTL_CMAC_R16(hw, reg) \
+	rtl_read16(RTL_CMAC_REG_ADDR(hw, reg))
+
+#define RTL_CMAC_R8(hw, reg) \
+	rte_read8(RTL_CMAC_REG_ADDR(hw, reg))
+
+#define RTL_CMAC_W32(hw, reg, val) \
+	rte_write32((rte_cpu_to_le_32(val)), RTL_CMAC_REG_ADDR(hw, reg))
+
+#define RTL_CMAC_W16(hw, reg, val) \
+	rte_write16((rte_cpu_to_le_16(val)), RTL_CMAC_REG_ADDR(hw, reg))
+
+#define RTL_CMAC_W8(hw, reg, val) \
+	rte_write8((val), RTL_CMAC_REG_ADDR(hw, reg))
+
+void rtl8125_driver_start(struct rtl8125_hw *hw);
+void rtl8125_driver_stop(struct rtl8125_hw *hw);
+int rtl8125_check_dash(struct rtl8125_hw *hw);
+bool rtl8125_is_allow_access_dash_ocp(struct rtl8125_hw *hw);
+void rtl8125_dash2_disable_txrx(struct rtl8125_hw *hw);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_ethdev.c
@@ -0,0 +1,1165 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <rte_eal.h>
+
+#include <rte_string_fns.h>
+#include <rte_common.h>
+#include <rte_interrupts.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_pci.h>
+#include <bus_pci_driver.h>
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+#include <ethdev_pci.h>
+#include <rte_memory.h>
+#include <rte_malloc.h>
+#include <dev_driver.h>
+
+#include "r8125_ethdev.h"
+#include "r8125_hw.h"
+#include "r8125_phy.h"
+#include "r8125_logs.h"
+#include "r8125_dash.h"
+
+static int rtl8125_dev_start(struct rte_eth_dev *dev);
+static int rtl8125_dev_stop(struct rte_eth_dev *dev);
+static int rtl8125_dev_reset(struct rte_eth_dev *dev);
+static int rtl8125_dev_set_link_up(struct rte_eth_dev *dev);
+static int rtl8125_dev_set_link_down(struct rte_eth_dev *dev);
+static int rtl8125_dev_close(struct rte_eth_dev *dev);
+static int rtl8125_dev_configure(struct rte_eth_dev *dev __rte_unused);
+
+static int rtl8125_fw_version_get(struct rte_eth_dev *dev, char *fw_version,
+                                  size_t fw_size);
+static int rtl8125_dev_infos_get(struct rte_eth_dev *dev,
+                                 struct rte_eth_dev_info *dev_info);
+static int rtl8125_dev_mtu_set(struct rte_eth_dev *dev, uint16_t mtu);
+
+static int rtl8125_promiscuous_enable(struct rte_eth_dev *dev);
+static int rtl8125_promiscuous_disable(struct rte_eth_dev *dev);
+static int rtl8125_allmulticast_enable(struct rte_eth_dev *dev);
+static int rtl8125_allmulticast_disable(struct rte_eth_dev *dev);
+
+static void rtl8125_dev_interrupt_handler(void *param);
+
+static int rtl8125_dev_link_update(struct rte_eth_dev *dev,
+                                   int wait __rte_unused);
+static int rtl8125_dev_stats_get(struct rte_eth_dev *dev,
+                                 struct rte_eth_stats *rte_stats);
+static int rtl8125_dev_stats_reset(struct rte_eth_dev *dev);
+
+/*
+ * The set of PCI devices this driver supports
+ */
+static const struct rte_pci_id pci_id_r8125_map[] = {
+	{ RTE_PCI_DEVICE(R8125_REALTEK_VENDOR_ID, 0x8125) },
+	{ RTE_PCI_DEVICE(R8125_REALTEK_VENDOR_ID, 0x8162) },
+	{ RTE_PCI_DEVICE(R8125_REALTEK_VENDOR_ID, 0x3000) },
+	{ .vendor_id = 0, /* sentinel */ },
+};
+
+
+static const struct rte_eth_desc_lim rx_desc_lim = {
+	.nb_max   = R8125_MAX_RX_DESC,
+	.nb_min   = R8125_MIN_RX_DESC,
+	.nb_align = R8125_DESC_ALIGN,
+};
+
+static const struct rte_eth_desc_lim tx_desc_lim = {
+	.nb_max         = R8125_MAX_TX_DESC,
+	.nb_min         = R8125_MIN_TX_DESC,
+	.nb_align       = R8125_DESC_ALIGN,
+	.nb_seg_max     = R8125_MAX_TX_SEG,
+	.nb_mtu_seg_max = R8125_MAX_TX_SEG,
+};
+
+static const struct eth_dev_ops rtl8125_eth_dev_ops = {
+	.dev_configure	      = rtl8125_dev_configure,
+	.dev_start	      = rtl8125_dev_start,
+	.dev_stop	      = rtl8125_dev_stop,
+	.dev_set_link_up      = rtl8125_dev_set_link_up,
+	.dev_set_link_down    = rtl8125_dev_set_link_down,
+	.dev_close	      = rtl8125_dev_close,
+	.dev_reset	      = rtl8125_dev_reset,
+
+	.promiscuous_enable   = rtl8125_promiscuous_enable,
+	.promiscuous_disable  = rtl8125_promiscuous_disable,
+	.allmulticast_enable  = rtl8125_allmulticast_enable,
+	.allmulticast_disable = rtl8125_allmulticast_disable,
+
+	.link_update          = rtl8125_dev_link_update,
+	.stats_get            = rtl8125_dev_stats_get,
+	.stats_reset          = rtl8125_dev_stats_reset,
+
+	.fw_version_get       = rtl8125_fw_version_get,
+	.dev_infos_get        = rtl8125_dev_infos_get,
+
+	.mtu_set              = rtl8125_dev_mtu_set,
+
+	.rx_queue_setup       = rtl8125_rx_queue_setup,
+	.rx_queue_release     = rtl8125_rx_queue_release,
+	.rxq_info_get         = rtl8125_rxq_info_get,
+
+	.tx_queue_setup       = rtl8125_tx_queue_setup,
+	.tx_queue_release     = rtl8125_tx_queue_release,
+	.tx_done_cleanup      = rtl8125_tx_done_cleanup,
+	.txq_info_get         = rtl8125_txq_info_get,
+};
+
+static int
+rtl8125_dev_configure(struct rte_eth_dev *dev __rte_unused)
+{
+	return 0;
+}
+
+static int
+rtl8125_fw_version_get(struct rte_eth_dev *dev, char *fw_version,
+                       size_t fw_size)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	int ret;
+
+	ret = snprintf(fw_version, fw_size, "0x%08x", hw->hw_ram_code_ver);
+
+	ret += 1; /* Add the size of '\0' */
+	if (fw_size < (u32)ret)
+		return ret;
+	else
+		return 0;
+}
+
+static int
+rtl8125_dev_infos_get(struct rte_eth_dev *dev __rte_unused,
+                      struct rte_eth_dev_info *dev_info)
+{
+	dev_info->min_rx_bufsize = 1024;
+	dev_info->max_rx_pktlen = Jumbo_Frame_9k;
+	dev_info->max_mac_addrs = 1;
+
+	dev_info->max_rx_queues = 1;
+	dev_info->max_tx_queues = 1;
+
+	dev_info->default_rxconf = (struct rte_eth_rxconf) {
+		.rx_free_thresh = R8125_RX_FREE_THRESH,
+	};
+
+	dev_info->default_txconf = (struct rte_eth_txconf) {
+		.tx_free_thresh = R8125_TX_FREE_THRESH,
+	};
+
+	dev_info->rx_desc_lim = rx_desc_lim;
+	dev_info->tx_desc_lim = tx_desc_lim;
+
+	dev_info->speed_capa = RTE_ETH_LINK_SPEED_10M_HD | RTE_ETH_LINK_SPEED_10M |
+	                       RTE_ETH_LINK_SPEED_100M_HD | RTE_ETH_LINK_SPEED_100M |
+	                       RTE_ETH_LINK_SPEED_1G | RTE_ETH_LINK_SPEED_2_5G;
+
+	dev_info->min_mtu = RTE_ETHER_MIN_MTU;
+	dev_info->max_mtu = dev_info->max_rx_pktlen - R8125_ETH_OVERHEAD;
+
+	dev_info->rx_offload_capa = (rtl8125_get_rx_port_offloads() |
+	                             dev_info->rx_queue_offload_capa);
+	dev_info->tx_offload_capa = rtl8125_get_tx_port_offloads();
+
+	return 0;
+}
+
+static int
+rtl8125_dev_stats_reset(struct rte_eth_dev *dev)
+{
+
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	rtl8125_clear_tally_stats(hw);
+
+	memset(&adapter->sw_stats, 0, sizeof(adapter->sw_stats));
+
+	return 0;
+}
+
+static void
+rtl8125_sw_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *rte_stats)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_sw_stats *sw_stats = &adapter->sw_stats;
+
+	rte_stats->ibytes = sw_stats->rx_bytes;
+	rte_stats->obytes = sw_stats->tx_bytes;
+}
+
+static int
+rtl8125_dev_stats_get(struct rte_eth_dev *dev, struct rte_eth_stats *rte_stats)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	if (rte_stats == NULL)
+		return -EINVAL;
+
+	rtl8125_get_tally_stats(hw, rte_stats);
+	rtl8125_sw_stats_get(dev, rte_stats);
+
+	return 0;
+}
+
+/* Return 0 means link status changed, -1 means not changed */
+static int
+rtl8125_dev_link_update(struct rte_eth_dev *dev, int wait __rte_unused)
+{
+	struct rte_eth_link link, old;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	u32 speed;
+	u16 status;
+
+	link.link_status = RTE_ETH_LINK_DOWN;
+	link.link_speed = 0;
+	link.link_duplex = RTE_ETH_LINK_FULL_DUPLEX;
+	link.link_autoneg = RTE_ETH_LINK_AUTONEG;
+
+	memset(&old, 0, sizeof(old));
+
+	/* Load old link status */
+	rte_eth_linkstatus_get(dev, &old);
+
+	/* Read current link status */
+	status = RTL_R16(hw, PHYstatus);
+
+	if (status & LinkStatus) {
+		link.link_status = RTE_ETH_LINK_UP;
+
+		if (status & FullDup) {
+			link.link_duplex = RTE_ETH_LINK_FULL_DUPLEX;
+			if (hw->mcfg == CFG_METHOD_2)
+				RTL_W32(hw, TxConfig, (RTL_R32(hw, TxConfig) |
+				                       (BIT_24 | BIT_25)) & ~BIT_19);
+
+		} else {
+			link.link_duplex = RTE_ETH_LINK_HALF_DUPLEX;
+			if (hw->mcfg == CFG_METHOD_2)
+				RTL_W32(hw, TxConfig, (RTL_R32(hw, TxConfig) | BIT_25) &
+				        ~(BIT_19 | BIT_24));
+		}
+
+		if (status & _2500bpsF)
+			speed = 2500;
+		else if (status & _1000bpsF)
+			speed = 1000;
+		else if (status & _100bps)
+			speed = 100;
+		else
+			speed = 10;
+
+		link.link_speed = speed;
+	}
+
+	if (link.link_status == old.link_status)
+		return -1;
+
+	rte_eth_linkstatus_set(dev, &link);
+
+	return 0;
+}
+
+static int
+rtl8125_dev_set_link_up(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	rtl8125_powerup_pll(hw);
+
+	return 0;
+}
+
+static int
+rtl8125_dev_set_link_down(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	/* Mcu pme intr masks */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xE00A, hw->mcu_pme_setting & ~(BIT_11 | BIT_14));
+		break;
+	}
+
+	rtl8125_powerdown_pll(hw);
+
+	return 0;
+}
+
+static int
+rtl8125_dev_mtu_set(struct rte_eth_dev *dev, uint16_t mtu)
+{
+	struct rte_eth_dev_info dev_info;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	int ret;
+	uint32_t frame_size = mtu + R8125_ETH_OVERHEAD;
+
+	ret = rtl8125_dev_infos_get(dev, &dev_info);
+	if (ret != 0)
+		return ret;
+
+	if (mtu < RTE_ETHER_MIN_MTU || frame_size > dev_info.max_rx_pktlen)
+		return -EINVAL;
+
+	hw->mtu = mtu;
+
+	RTL_W16(hw, RxMaxSize, frame_size);
+
+	return 0;
+}
+
+static int
+rtl8125_promiscuous_enable(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	int rx_mode = AcceptBroadcast | AcceptMulticast | AcceptMyPhys | AcceptAllPhys;
+
+	RTL_W32(hw, RxConfig, rx_mode | RTL_R32(hw, RxConfig));
+	RTL_W32(hw, MAR0 + 0, 0xffffffff);
+	RTL_W32(hw, MAR0 + 4, 0xffffffff);
+
+	return 0;
+}
+
+static int
+rtl8125_promiscuous_disable(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	int rx_mode = ~AcceptAllPhys;
+
+	RTL_W32(hw, RxConfig, rx_mode & RTL_R32(hw, RxConfig));
+
+	if (dev->data->all_multicast == 1) {
+		RTL_W32(hw, MAR0 + 0, 0xffffffff);
+		RTL_W32(hw, MAR0 + 4, 0xffffffff);
+	}
+
+	return 0;
+}
+
+static int
+rtl8125_allmulticast_enable(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	RTL_W32(hw, MAR0 + 0, 0xffffffff);
+	RTL_W32(hw, MAR0 + 4, 0xffffffff);
+
+	return 0;
+}
+
+static int
+rtl8125_allmulticast_disable(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+
+	if (dev->data->promiscuous == 1)
+		return 0; /* Must remain in all_multicast mode */
+
+	RTL_W32(hw, MAR0 + 0, 0);
+	RTL_W32(hw, MAR0 + 4, 0);
+
+	return 0;
+}
+
+static void
+rtl8125_disable_intr(struct rtl8125_hw *hw)
+{
+	PMD_INIT_FUNC_TRACE();
+	RTL_W32(hw, IMR0_8125, 0x0000);
+	RTL_W32(hw, ISR0_8125, RTL_R32(hw, ISR0_8125));
+}
+
+static void
+rtl8125_enable_intr(struct rtl8125_hw *hw)
+{
+	PMD_INIT_FUNC_TRACE();
+	RTL_W32(hw, IMR0_8125, LinkChg);
+}
+
+static void
+rtl8125_hw_init(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_enable_aspm_clkreq_lock(hw, 0);
+		rtl8125_enable_force_clkreq(hw, 0);
+		break;
+	}
+
+	rtl8125_disable_ups(hw);
+
+	hw->hw_ops.hw_mac_mcu_config(hw);
+
+	/* Disable ocp phy power saving */
+	rtl8125_disable_ocp_phy_power_saving(hw);
+}
+
+static void
+rtl8125_hw_ephy_config(struct rtl8125_hw *hw)
+{
+	hw->hw_ops.hw_ephy_config(hw);
+}
+
+static void
+rtl8125_disable_eee_plus(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xE080, rtl8125_mac_ocp_read(hw, 0xE080) & ~BIT_1);
+		break;
+	default:
+		/* Not support EEEPlus */
+		break;
+	}
+}
+
+static void
+rtl8125_hw_clear_timer_int(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W32(hw, TIMER_INT0_8125, 0x0000);
+		RTL_W32(hw, TIMER_INT1_8125, 0x0000);
+		RTL_W32(hw, TIMER_INT2_8125, 0x0000);
+		RTL_W32(hw, TIMER_INT3_8125, 0x0000);
+		break;
+	}
+}
+
+static void
+rtl8125_hw_clear_int_miti(struct rtl8125_hw *hw)
+{
+	int i;
+	switch (hw->HwSuppIntMitiVer) {
+	case 3:
+	case 6:
+		/* IntMITI_0-IntMITI_31 */
+		for (i = 0xA00; i < 0xB00; i += 4)
+			RTL_W32(hw, i, 0x0000);
+		break;
+	case 4:
+		/* IntMITI_0-IntMITI_15 */
+		for (i = 0xA00; i < 0xA80; i += 4)
+			RTL_W32(hw, i, 0x0000);
+
+		RTL_W8(hw, INT_CFG0_8125, RTL_R8(hw, INT_CFG0_8125) &
+		       ~(INT_CFG0_TIMEOUT0_BYPASS_8125 | INT_CFG0_MITIGATION_BYPASS_8125));
+
+		RTL_W16(hw, INT_CFG1_8125, 0x0000);
+		break;
+	}
+}
+
+static void
+rtl8125_hw_config(struct rtl8125_hw *hw)
+{
+	u32 mac_ocp_data;
+
+	/* Set RxConfig to default */
+	RTL_W32(hw, RxConfig, (RX_DMA_BURST_unlimited << RxCfgDMAShift));
+
+	rtl8125_nic_reset(hw);
+
+	rtl8125_enable_cfg9346_write(hw);
+
+	/* Disable aspm clkreq internal */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_enable_force_clkreq(hw, 0);
+		rtl8125_enable_aspm_clkreq_lock(hw, 0);
+		break;
+	}
+
+	/* Disable magic packet */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		mac_ocp_data = 0;
+		rtl8125_mac_ocp_write(hw, 0xC0B6, mac_ocp_data);
+		break;
+	}
+
+	/* Set DMA burst size and interframe gap time */
+	RTL_W32(hw, TxConfig, (TX_DMA_BURST_unlimited << TxDMAShift) |
+	        (InterFrameGap << TxInterFrameGapShift));
+
+	if (hw->EnableTxNoClose)
+		RTL_W32(hw, TxConfig, (RTL_R32(hw, TxConfig) | BIT_6));
+
+	/* TCAM */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_7:
+		RTL_W16(hw, 0x382, 0x221B);
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		/* RSS_control_0 */
+		RTL_W32(hw, RSS_CTRL_8125, 0x00);
+
+		/* VMQ_control */
+		RTL_W16(hw, Q_NUM_CTRL_8125, 0x0000);
+
+		/* Disable speed down */
+		RTL_W8(hw, Config1, RTL_R8(hw, Config1) & ~0x10);
+
+		/* CRC disable set */
+		rtl8125_mac_ocp_write(hw, 0xC140, 0xFFFF);
+		rtl8125_mac_ocp_write(hw, 0xC142, 0xFFFF);
+
+		/* New TX desc format */
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xEB58);
+		mac_ocp_data |= BIT_0;
+		rtl8125_mac_ocp_write(hw, 0xEB58, mac_ocp_data);
+
+		/*
+		 * MTPS
+		 * 15-8 maximum tx use credit number
+		 * 7-0 reserved for pcie product line
+		 */
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xE614);
+		mac_ocp_data &= ~(BIT_10 | BIT_9 | BIT_8);
+		if (hw->mcfg == CFG_METHOD_4 || hw->mcfg == CFG_METHOD_5 ||
+		    hw->mcfg == CFG_METHOD_7)
+			mac_ocp_data |= ((2 & 0x07) << 8);
+		else
+			mac_ocp_data |= ((3 & 0x07) << 8);
+		rtl8125_mac_ocp_write(hw, 0xE614, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xE63E);
+		mac_ocp_data &= ~(BIT_5 | BIT_4);
+		if (hw->mcfg == CFG_METHOD_2 || hw->mcfg == CFG_METHOD_3 ||
+		    hw->mcfg == CFG_METHOD_6)
+			mac_ocp_data |= ((0x02 & 0x03) << 4);
+		rtl8125_mac_ocp_write(hw, 0xE63E, mac_ocp_data);
+
+		/*
+		 * FTR_MCU_CTRL
+		 * 3-2 txpla packet valid start
+		 */
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xC0B4);
+		mac_ocp_data &= ~BIT_0;
+		rtl8125_mac_ocp_write(hw, 0xC0B4, mac_ocp_data);
+		mac_ocp_data |= BIT_0;
+		rtl8125_mac_ocp_write(hw, 0xC0B4, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xC0B4);
+		mac_ocp_data |= (BIT_3 | BIT_2);
+		rtl8125_mac_ocp_write(hw, 0xC0B4, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xEB6A);
+		mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4 | BIT_3 | BIT_2 | BIT_1 |
+		                  BIT_0);
+		mac_ocp_data |= (BIT_5 | BIT_4 | BIT_1 | BIT_0);
+		rtl8125_mac_ocp_write(hw, 0xEB6A, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xEB50);
+		mac_ocp_data &= ~(BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5);
+		mac_ocp_data |= (BIT_6);
+		rtl8125_mac_ocp_write(hw, 0xEB50, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xE056);
+		mac_ocp_data &= ~(BIT_7 | BIT_6 | BIT_5 | BIT_4);
+		rtl8125_mac_ocp_write(hw, 0xE056, mac_ocp_data);
+
+		/* EEE_CR */
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xE040);
+		mac_ocp_data &= ~(BIT_12);
+		rtl8125_mac_ocp_write(hw, 0xE040, mac_ocp_data);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xEA1C);
+		mac_ocp_data &= ~(BIT_1 | BIT_0);
+		mac_ocp_data |= (BIT_0);
+		rtl8125_mac_ocp_write(hw, 0xEA1C, mac_ocp_data);
+
+		switch (hw->mcfg) {
+		case CFG_METHOD_2:
+		case CFG_METHOD_3:
+		case CFG_METHOD_6:
+		case CFG_METHOD_8:
+		case CFG_METHOD_9:
+			rtl8125_oob_mutex_lock(hw);
+			break;
+		}
+
+		/* MAC_PWRDWN_CR0 */
+		rtl8125_mac_ocp_write(hw, 0xE0C0, 0x4000);
+
+		rtl8125_set_mac_ocp_bit(hw, 0xE052, (BIT_6 | BIT_5));
+		rtl8125_clear_mac_ocp_bit(hw, 0xE052, BIT_3 | BIT_7);
+
+		switch (hw->mcfg) {
+		case CFG_METHOD_2:
+		case CFG_METHOD_3:
+		case CFG_METHOD_6:
+		case CFG_METHOD_8:
+		case CFG_METHOD_9:
+			rtl8125_oob_mutex_unlock(hw);
+			break;
+		}
+
+		/*
+		 * DMY_PWR_REG_0
+		 * (1)ERI(0xD4)(OCP 0xC0AC).bit[7:12]=6'b111111, L1 Mask
+		 */
+		rtl8125_set_mac_ocp_bit(hw, 0xC0AC,
+		                        (BIT_7 | BIT_8 | BIT_9 | BIT_10 | BIT_11 | BIT_12));
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xD430);
+		mac_ocp_data &= ~(BIT_11 | BIT_10 | BIT_9 | BIT_8 | BIT_7 | BIT_6 | BIT_5 |
+		                  BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+		mac_ocp_data |= 0x45F;
+		rtl8125_mac_ocp_write(hw, 0xD430, mac_ocp_data);
+
+		if (!hw->DASH)
+			RTL_W8(hw, 0xD0, RTL_R8(hw, 0xD0) | BIT_6 | BIT_7);
+		else
+			RTL_W8(hw, 0xD0, RTL_R8(hw, 0xD0) & ~(BIT_6 | BIT_7));
+
+		if (hw->mcfg == CFG_METHOD_2 || hw->mcfg == CFG_METHOD_3 ||
+		    hw->mcfg == CFG_METHOD_6)
+			RTL_W8(hw, MCUCmd_reg, RTL_R8(hw, MCUCmd_reg) | BIT_0);
+
+		rtl8125_disable_eee_plus(hw);
+
+		mac_ocp_data = rtl8125_mac_ocp_read(hw, 0xEA1C);
+		mac_ocp_data &= ~BIT_2;
+		rtl8125_mac_ocp_write(hw, 0xEA1C, mac_ocp_data);
+
+		/* Clear TCAM entries */
+		rtl8125_set_mac_ocp_bit(hw, 0xEB54, BIT_0);
+		udelay(1);
+		rtl8125_clear_mac_ocp_bit(hw, 0xEB54, BIT_0);
+
+		RTL_W16(hw, 0x1880, RTL_R16(hw, 0x1880) & ~(BIT_4 | BIT_5));
+
+		if (hw->mcfg == CFG_METHOD_8 || hw->mcfg == CFG_METHOD_9 ||
+		    hw->mcfg == CFG_METHOD_10 || hw->mcfg == CFG_METHOD_11)
+			RTL_W8(hw, 0xd8, RTL_R8(hw, 0xd8) & ~EnableRxDescV4_0);
+	}
+
+	/* Other hw parameters */
+	rtl8125_hw_clear_timer_int(hw);
+
+	rtl8125_hw_clear_int_miti(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xE098, 0xC302);
+		break;
+	}
+
+	rtl8125_disable_cfg9346_write(hw);
+
+	udelay(10);
+}
+
+static void
+rtl8125_hw_initialize(struct rtl8125_hw *hw)
+{
+	rtl8125_init_software_variable(hw);
+
+	rtl8125_exit_oob(hw);
+
+	rtl8125_hw_init(hw);
+
+	rtl8125_nic_reset(hw);
+}
+
+static void
+rtl8125_dev_interrupt_handler(void *param)
+{
+	struct rte_eth_dev *dev = (struct rte_eth_dev *)param;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	uint32_t intr;
+
+	intr = RTL_R32(hw, ISR0_8125);
+
+	/* Clear all cause mask */
+	rtl8125_disable_intr(hw);
+
+	if (intr & LinkChg)
+		rtl8125_dev_link_update(dev, 0);
+	else
+		PMD_DRV_LOG(ERR, "r8125: interrupt unhandled.");
+
+	rtl8125_enable_intr(hw);
+}
+
+static int
+rtl8125_dev_init(struct rte_eth_dev *dev)
+{
+	struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(dev);
+	struct rte_intr_handle *intr_handle = pci_dev->intr_handle;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rte_ether_addr *perm_addr =
+	        (struct rte_ether_addr *)hw->mac_addr;
+
+	dev->dev_ops = &rtl8125_eth_dev_ops;
+	dev->tx_pkt_burst = &rtl8125_xmit_pkts;
+	dev->rx_pkt_burst = &rtl8125_recv_pkts;
+
+	/* For secondary processes, the primary process has done all the work */
+	if (rte_eal_process_type() != RTE_PROC_PRIMARY) {
+		if (dev->data->scattered_rx)
+			dev->rx_pkt_burst = &rtl8125_recv_scattered_pkts;
+		return 0;
+	}
+
+	rte_eth_copy_pci_info(dev, pci_dev);
+
+	hw->mmio_addr = (u8 *)pci_dev->mem_resource[2].addr; /* RTL8125 uses BAR2 */
+	rtl8125_get_mac_version(hw, pci_dev);
+
+	if (rtl8125_set_hw_ops(hw))
+		return -ENOTSUP;
+
+	rtl8125_disable_intr(hw);
+
+	rtl8125_hw_initialize(hw);
+
+	/* Read the permanent MAC address out of ROM */
+	rtl8125_get_mac_address(hw, perm_addr);
+
+	if (!rte_is_valid_assigned_ether_addr(perm_addr)) {
+		rte_eth_random_addr(&perm_addr->addr_bytes[0]);
+
+		PMD_INIT_LOG(NOTICE, "r8125: Assign randomly generated MAC address "
+		             "%02x:%02x:%02x:%02x:%02x:%02x",
+		             perm_addr->addr_bytes[0],
+		             perm_addr->addr_bytes[1],
+		             perm_addr->addr_bytes[2],
+		             perm_addr->addr_bytes[3],
+		             perm_addr->addr_bytes[4],
+		             perm_addr->addr_bytes[5]);
+	}
+
+	/* Allocate memory for storing MAC addresses */
+	dev->data->mac_addrs = rte_zmalloc("r8125", RTE_ETHER_ADDR_LEN, 0);
+
+	if (dev->data->mac_addrs == NULL) {
+		PMD_INIT_LOG(ERR, "MAC Malloc failed");
+		return -ENOMEM;
+	}
+
+	/* Copy the permanent MAC address */
+	rte_ether_addr_copy(perm_addr, &dev->data->mac_addrs[0]);
+
+	rtl8125_rar_set(hw, &perm_addr->addr_bytes[0]);
+
+	rte_intr_callback_register(intr_handle,
+	                           rtl8125_dev_interrupt_handler, dev);
+
+	/* Enable uio/vfio intr/eventfd mapping */
+	rte_intr_enable(intr_handle);
+
+	return 0;
+}
+
+/*
+ * Reset and stop device.
+ */
+static int
+rtl8125_dev_close(struct rte_eth_dev *dev)
+{
+	struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(dev);
+	struct rte_intr_handle *intr_handle = pci_dev->intr_handle;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	int retries = 0;
+	int ret_unreg, ret_stp;
+
+	if (rte_eal_process_type() != RTE_PROC_PRIMARY)
+		return 0;
+
+	if (HW_DASH_SUPPORT_DASH(hw))
+		rtl8125_driver_stop(hw);
+
+	ret_stp = rtl8125_dev_stop(dev);
+
+	rtl8125_free_queues(dev);
+
+	/* Reprogram the RAR[0] in case user changed it. */
+	rtl8125_rar_set(hw, hw->mac_addr);
+
+	/* Disable uio intr before callback unregister */
+	rte_intr_disable(intr_handle);
+
+	do {
+		ret_unreg = rte_intr_callback_unregister(intr_handle,
+		                rtl8125_dev_interrupt_handler,
+		                dev);
+		if (ret_unreg >= 0 || ret_unreg == -ENOENT)
+			break;
+		else if (ret_unreg != -EAGAIN)
+			PMD_DRV_LOG(ERR, "r8125: intr callback unregister failed: %d", ret_unreg);
+
+		rte_delay_ms(100);
+	} while (retries++ < (10 + 90));
+
+	return ret_stp;
+}
+
+static int
+rtl8125_dev_uninit(struct rte_eth_dev *dev)
+{
+	if (rte_eal_process_type() != RTE_PROC_PRIMARY)
+		return -EPERM;
+
+	rtl8125_dev_close(dev);
+
+	return 0;
+}
+
+static int
+rtl8125_tally_init(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	const struct rte_memzone *mz;
+
+	mz = rte_eth_dma_zone_reserve(dev, "tally_counters", 0,
+	                              sizeof(struct rtl8125_counters),
+	                              64, rte_socket_id());
+	if (mz == NULL)
+		return -ENOMEM;
+
+	hw->tally_vaddr = mz->addr;
+	hw->tally_paddr = mz->iova;
+
+	/* Fill tally addrs */
+	RTL_W32(hw, CounterAddrHigh, (u64)hw->tally_paddr >> 32);
+	RTL_W32(hw, CounterAddrLow, (u64)hw->tally_paddr & (DMA_BIT_MASK(32)));
+
+	/* Reset the hw statistics */
+	rtl8125_clear_tally_stats(hw);
+
+	return 0;
+}
+
+#if RTE_VERSION >= RTE_VERSION_NUM(20, 8, 0, 0)
+static void
+rtl8125_tally_free(struct rte_eth_dev *dev)
+#else
+static void
+rtl8125_tally_free(struct rte_eth_dev *dev __rte_unused)
+#endif
+{
+	rtl8125_eth_dma_zone_free(dev, "tally_counters", 0);
+}
+
+static int
+_rtl8125_setup_link(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	u64 adv = 0;
+	u32 *link_speeds = &dev->data->dev_conf.link_speeds;
+
+	/* Setup link speed and duplex */
+	if (*link_speeds == RTE_ETH_LINK_SPEED_AUTONEG) {
+		hw->autoneg = AUTONEG_ENABLE;
+		hw->speed = SPEED_2500;
+		hw->duplex = DUPLEX_FULL;
+		hw->advertising = RTL8125_ALL_SPEED_DUPLEX;
+	} else if (*link_speeds != 0) {
+
+		if (*link_speeds & ~(RTE_ETH_LINK_SPEED_10M_HD | RTE_ETH_LINK_SPEED_10M |
+		                     RTE_ETH_LINK_SPEED_100M_HD | RTE_ETH_LINK_SPEED_100M |
+		                     RTE_ETH_LINK_SPEED_1G | RTE_ETH_LINK_SPEED_2_5G | RTE_ETH_LINK_SPEED_FIXED))
+			goto error_invalid_config;
+
+		if (*link_speeds & RTE_ETH_LINK_SPEED_10M_HD) {
+			hw->speed = SPEED_10;
+			hw->duplex = DUPLEX_HALF;
+			adv |= ADVERTISE_10_HALF;
+		}
+		if (*link_speeds & RTE_ETH_LINK_SPEED_10M) {
+			hw->speed = SPEED_10;
+			hw->duplex = DUPLEX_FULL;
+			adv |= ADVERTISE_10_FULL;
+		}
+		if (*link_speeds & RTE_ETH_LINK_SPEED_100M_HD) {
+			hw->speed = SPEED_100;
+			hw->duplex = DUPLEX_HALF;
+			adv |= ADVERTISE_100_HALF;
+		}
+		if (*link_speeds & RTE_ETH_LINK_SPEED_100M) {
+			hw->speed = SPEED_100;
+			hw->duplex = DUPLEX_FULL;
+			adv |= ADVERTISE_100_FULL;
+		}
+		if (*link_speeds & RTE_ETH_LINK_SPEED_1G) {
+			hw->speed = SPEED_1000;
+			hw->duplex = DUPLEX_FULL;
+			adv |= ADVERTISE_1000_FULL;
+		}
+		if (*link_speeds & RTE_ETH_LINK_SPEED_2_5G) {
+			hw->speed = SPEED_2500;
+			hw->duplex = DUPLEX_FULL;
+			adv |= ADVERTISE_2500_FULL;
+		}
+
+		hw->autoneg = AUTONEG_ENABLE;
+		hw->advertising = adv;
+	}
+
+	rtl8125_set_speed(hw);
+
+	return 0;
+
+error_invalid_config:
+	PMD_INIT_LOG(ERR, "Invalid advertised speeds (%u) for port %u",
+	             dev->data->dev_conf.link_speeds, dev->data->port_id);
+	rtl8125_stop_queues(dev);
+	return -EINVAL;
+}
+
+static int
+rtl8125_setup_link(struct rte_eth_dev *dev)
+{
+#ifdef RTE_EXEC_ENV_FREEBSD
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rte_eth_link link;
+	int count;
+#endif
+
+	_rtl8125_setup_link(dev);
+
+#ifdef RTE_EXEC_ENV_FREEBSD
+	for (count = 0; count < R8125_LINK_CHECK_TIMEOUT; count ++) {
+		if (!(RTL_R16(hw, PHYstatus) & LinkStatus)) {
+			msleep(R8125_LINK_CHECK_INTERVAL);
+			continue;
+		}
+
+		rtl8125_dev_link_update(dev, 0);
+
+		rte_eth_linkstatus_get(dev, &link);
+
+		return 0;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Configure device link speed and setup link.
+ * It returns 0 on success.
+ */
+static int
+rtl8125_dev_start(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rte_pci_device *pci_dev = RTE_ETH_DEV_TO_PCI(dev);
+	struct rte_intr_handle *intr_handle = pci_dev->intr_handle;
+	int err;
+
+	/* Disable uio/vfio intr/eventfd mapping */
+	rte_intr_disable(intr_handle);
+
+	rtl8125_powerup_pll(hw);
+
+	rtl8125_hw_ephy_config(hw);
+
+	rtl8125_hw_phy_config(hw);
+
+	rtl8125_hw_config(hw);
+
+	rtl8125_tx_init(dev);
+
+	/* This can fail when allocating mbufs for descriptor rings */
+	err = rtl8125_rx_init(dev);
+	if (err) {
+		PMD_INIT_LOG(ERR, "Unable to initialize RX hardware");
+		goto error;
+	}
+
+	/* This can fail when allocating mem for tally counters */
+	err = rtl8125_tally_init(dev);
+	if (err)
+		goto error;
+
+	/* Enable uio/vfio intr/eventfd mapping */
+	rte_intr_enable(intr_handle);
+
+	/* Resume enabled intr since hw reset */
+	rtl8125_enable_intr(hw);
+
+	rtl8125_setup_link(dev);
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+
+	hw->adapter_stopped = 0;
+
+	return 0;
+
+error:
+	rtl8125_stop_queues(dev);
+	return -EIO;
+}
+
+
+/*
+ * Stop device: disable RX and TX functions to allow for reconfiguring.
+ */
+static int
+rtl8125_dev_stop(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rte_eth_link link;
+
+	if (hw->adapter_stopped)
+		return 0;
+
+	rtl8125_disable_intr(hw);
+
+	rtl8125_nic_reset(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xE00A, hw->mcu_pme_setting);
+		break;
+	}
+
+	rtl8125_powerdown_pll(hw);
+
+	rtl8125_stop_queues(dev);
+
+	rtl8125_tally_free(dev);
+
+	/* Clear the recorded link status */
+	memset(&link, 0, sizeof(link));
+	rte_eth_linkstatus_set(dev, &link);
+
+	hw->adapter_stopped = 1;
+	dev->data->dev_started = 0;
+
+	return 0;
+}
+
+static int
+rtl8125_dev_reset(struct rte_eth_dev *dev)
+{
+	int ret;
+
+	ret = rtl8125_dev_uninit(dev);
+	if (ret)
+		return ret;
+
+	ret = rtl8125_dev_init(dev);
+
+	return ret;
+}
+
+static int
+rtl8125_pci_probe(struct rte_pci_driver *pci_drv __rte_unused,
+                  struct rte_pci_device *pci_dev)
+{
+	return rte_eth_dev_pci_generic_probe(pci_dev,
+	                                     sizeof(struct rtl8125_adapter), rtl8125_dev_init);
+
+}
+
+static int
+rtl8125_pci_remove(struct rte_pci_device *pci_dev)
+{
+	return rte_eth_dev_pci_generic_remove(pci_dev, rtl8125_dev_uninit);
+}
+
+static struct rte_pci_driver rte_r8125_pmd = {
+	.id_table = pci_id_r8125_map,
+	.drv_flags = RTE_PCI_DRV_NEED_MAPPING | RTE_PCI_DRV_INTR_LSC,
+	.probe = rtl8125_pci_probe,
+	.remove = rtl8125_pci_remove,
+};
+
+RTE_PMD_REGISTER_PCI(net_r8125, rte_r8125_pmd);
+RTE_PMD_REGISTER_PCI_TABLE(net_r8125, pci_id_r8125_map);
+RTE_PMD_REGISTER_KMOD_DEP(net_r8125, "* igb_uio | uio_pci_generic | vfio-pci");
+
+#if RTE_VERSION >= RTE_VERSION_NUM(20, 8, 0, 0)
+RTE_LOG_REGISTER(r8125_logtype_init, pmd.net.r8125.init, NOTICE);
+RTE_LOG_REGISTER(r8125_logtype_driver, pmd.net.r8125.driver, NOTICE);
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_RX
+RTE_LOG_REGISTER(r8125_logtype_rx, pmd.net.r8125.rx, DEBUG);
+#endif
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX
+RTE_LOG_REGISTER(r8125_logtype_tx, pmd.net.r8125.tx, DEBUG);
+#endif
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX_FREE
+RTE_LOG_REGISTER(r8125_logtype_tx_free, pmd.net.r8125.tx_free, DEBUG);
+#endif
+
+#else /* RTE_VERSION >= RTE_VERSION_NUM(20, 8, 0, 0) */
+
+int r8125_logtype_init;
+int r8125_logtype_driver;
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_RX
+int r8125_logtype_rx;
+#endif
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX
+int r8125_logtype_tx;
+#endif
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX_FREE
+int r8125_logtype_tx_free;
+#endif
+
+RTE_INIT(r8125_init_log)
+{
+	r8125_logtype_init = rte_log_register("pmd.net.r8125.init");
+	if (r8125_logtype_init >= 0)
+		rte_log_set_level(r8125_logtype_init, RTE_LOG_NOTICE);
+	r8125_logtype_driver = rte_log_register("pmd.net.r8125.driver");
+	if (r8125_logtype_driver >= 0)
+		rte_log_set_level(r8125_logtype_driver, RTE_LOG_NOTICE);
+#ifdef RTE_LIBRTE_R8125_DEBUG_RX
+	r8125_logtype_rx = rte_log_register("pmd.net.r8125.rx");
+	if (r8125_logtype_rx >= 0)
+		rte_log_set_level(r8125_logtype_rx, RTE_LOG_DEBUG);
+#endif
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX
+	r8125_logtype_tx = rte_log_register("pmd.net.r8125.tx");
+	if (r8125_logtype_tx >= 0)
+		rte_log_set_level(r8125_logtype_tx, RTE_LOG_DEBUG);
+#endif
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX_FREE
+	r8125_logtype_tx_free = rte_log_register("pmd.net.r8125.tx_free");
+	if (r8125_logtype_tx_free >= 0)
+		rte_log_set_level(r8125_logtype_tx_free, RTE_LOG_DEBUG);
+#endif
+}
+
+#endif /* RTE_VERSION >= RTE_VERSION_NUM(20, 8, 0, 0) */
--- /dev/null
+++ b/drivers/net/r8125/r8125_ethdev.h
@@ -0,0 +1,148 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _R8125_ETHDEV_H_
+#define _R8125_ETHDEV_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <rte_ethdev.h>
+#include <rte_ethdev_core.h>
+
+#include "r8125_base.h"
+
+#define R8125_LINK_CHECK_WAIT     4000 /* 1s */
+#define R8125_LINK_CHECK_TIMEOUT  50   /* 10s */
+#define R8125_LINK_CHECK_INTERVAL 200  /* ms */
+
+struct rtl8125_hw;
+
+struct rtl8125_hw_ops {
+	void (*hw_config)(struct rtl8125_hw *hw);
+	void (*hw_init_rxcfg)(struct rtl8125_hw *hw);
+	void (*hw_ephy_config)(struct rtl8125_hw *hw);
+	void (*hw_phy_config)(struct rtl8125_hw *hw);
+	void (*hw_mac_mcu_config)(struct rtl8125_hw *hw);
+	void (*hw_phy_mcu_config)(struct rtl8125_hw *hw);
+};
+
+struct rtl8125_hw {
+	struct rtl8125_hw_ops hw_ops;
+	struct rtl8125_counters *tally_vaddr;
+	u8  *mmio_addr;
+	u8  *cmac_ioaddr; /* cmac memory map physical address */
+	u64 tally_paddr;
+	u8  chipset_name;
+	u32 mcfg;
+	u32 mtu;
+	u32 rx_buf_sz;
+	u8  mac_addr[MAC_ADDR_LEN];
+	u8  adapter_stopped;
+	u16 cur_page;
+
+	u16 sw_ram_code_ver;
+	u16 hw_ram_code_ver;
+
+	u16 phy_reg_anlpar;
+	u8  efuse_ver;
+
+	u8  autoneg;
+	u8  duplex;
+	u32 speed;
+	u32 advertising;
+	enum rtl8125_fc_mode fcpause;
+
+	u8  HwIcVerUnknown;
+	u8  NotWrRamCodeToMicroP;
+	u8  NotWrMcuPatchCode;
+	u8  HwHasWrRamCodeToMicroP;
+
+	u8  HwSuppNowIsOobVer;
+
+	u8  HwSuppCheckPhyDisableModeVer;
+
+	/* EnableTxNoClose */
+	u8  HwSuppTxNoCloseVer;
+	u8  EnableTxNoClose;
+	u32 NextHwDesCloPtr0;
+	u32 BeginHwDesCloPtr0;
+	u32 MaxTxDescPtrMask;
+	u16 hw_clo_ptr_reg;
+	u16 sw_tail_ptr_reg;
+
+	int phy_auto_nego_reg;
+	int phy_1000_ctrl_reg;
+
+	int phy_2500_ctrl_reg;
+	u8  RequirePhyMdiSwapPatch;
+	u16 MacMcuPageSize;
+	u8  HwSuppMacMcuVer;
+	u32 HwSuppMaxPhyLinkSpeed;
+
+	u16 mcu_pme_setting;
+
+	u8 HwSuppIntMitiVer;
+
+	/* Dash */
+	u8 HwSuppDashVer;
+	u8 DASH;
+	u8 HwSuppOcpChannelVer;
+	u8 AllowAccessDashOcp;
+};
+
+struct rtl8125_sw_stats {
+	u64 tx_packets;
+	u64 tx_bytes;
+	u64 tx_errors;
+	u64 rx_packets;
+	u64 rx_bytes;
+	u64 rx_errors;
+};
+
+struct rtl8125_adapter {
+	struct rtl8125_hw       hw;
+	struct rtl8125_sw_stats	sw_stats;
+};
+
+#define RTL8125_DEV_PRIVATE(eth_dev) \
+	((struct rtl8125_adapter *)((eth_dev)->data->dev_private))
+
+int rtl8125_rx_init(struct rte_eth_dev *dev);
+int rtl8125_tx_init(struct rte_eth_dev *dev);
+
+uint16_t rtl8125_xmit_pkts(void *txq, struct rte_mbuf **tx_pkts,
+                           uint16_t nb_pkts);
+uint16_t rtl8125_recv_pkts(void *rxq, struct rte_mbuf **rx_pkts,
+                           uint16_t nb_pkts);
+uint16_t rtl8125_recv_scattered_pkts(void *rxq, struct rte_mbuf **rx_pkts,
+                                     uint16_t nb_pkts);
+
+int rtl8125_stop_queues(struct rte_eth_dev *dev);
+void rtl8125_free_queues(struct rte_eth_dev *dev);
+
+void rtl8125_tx_queue_release(struct rte_eth_dev *dev, uint16_t tx_queue_id);
+void rtl8125_rx_queue_release(struct rte_eth_dev *dev, uint16_t rx_queue_id);
+
+int rtl8125_tx_done_cleanup(void *tx_queue, uint32_t free_cnt);
+
+int rtl8125_tx_queue_setup(struct rte_eth_dev *dev, uint16_t queue_idx,
+                           uint16_t nb_tx_desc, unsigned int socket_id,
+                           const struct rte_eth_txconf *tx_conf);
+
+int rtl8125_rx_queue_setup(struct rte_eth_dev *dev, uint16_t queue_idx,
+                           uint16_t nb_rx_desc, unsigned int socket_id,
+                           const struct rte_eth_rxconf *rx_conf,
+                           struct rte_mempool *mb_pool);
+
+void rtl8125_rxq_info_get(struct rte_eth_dev *dev, uint16_t queue_idx,
+                          struct rte_eth_rxq_info *qinfo);
+
+void rtl8125_txq_info_get(struct rte_eth_dev *dev, uint16_t queue_idx,
+                          struct rte_eth_txq_info *qinfo);
+
+uint64_t rtl8125_get_tx_port_offloads(void);
+uint64_t rtl8125_get_rx_port_offloads(void);
+
+#endif /* _R8125_ETHDEV_H_ */
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_hw.c
@@ -0,0 +1,1107 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+
+#include "r8125_hw.h"
+#include "r8125_logs.h"
+#include "r8125_dash.h"
+
+void
+rtl8125_mac_ocp_write(struct rtl8125_hw *hw, u16 addr, u16 value)
+{
+	u32 data32;
+
+	data32 = addr / 2;
+	data32 <<= OCPR_Addr_Reg_shift;
+	data32 += value;
+	data32 |= OCPR_Write;
+
+	RTL_W32(hw, MACOCP, data32);
+}
+
+u16
+rtl8125_mac_ocp_read(struct rtl8125_hw *hw, u16 addr)
+{
+	u32 data32;
+	u16 data16 = 0;
+
+	data32 = addr / 2;
+	data32 <<= OCPR_Addr_Reg_shift;
+
+	RTL_W32(hw, MACOCP, data32);
+	data16 = (u16)RTL_R32(hw, MACOCP);
+
+	return data16;
+}
+
+u32
+rtl8125_csi_read(struct rtl8125_hw *hw, u32 addr)
+{
+	u32 cmd;
+	int i;
+	u32 value = 0;
+
+	cmd = CSIAR_Read | CSIAR_ByteEn << CSIAR_ByteEn_shift |
+	      (addr & CSIAR_Addr_Mask);
+
+	RTL_W32(hw, CSIAR, cmd);
+
+	for (i = 0; i < 10; i++) {
+		udelay(100);
+
+		/* Check if the RTL8125 has completed CSI read */
+		if (RTL_R32(hw, CSIAR) & CSIAR_Flag) {
+			value = RTL_R32(hw, CSIDR);
+			break;
+		}
+	}
+
+	udelay(20);
+
+	return value;
+}
+
+void
+rtl8125_get_mac_version(struct rtl8125_hw *hw, struct rte_pci_device *pci_dev)
+{
+	u32 reg, val32;
+	u32 ic_version_id;
+
+	val32 = RTL_R32(hw, TxConfig);
+	reg = val32 & 0x7c800000;
+	ic_version_id = val32 & 0x00700000;
+
+	switch (reg) {
+	case 0x60800000:
+		if (ic_version_id == 0x00000000)
+			hw->mcfg = CFG_METHOD_2;
+
+		else if (ic_version_id == 0x100000)
+			hw->mcfg = CFG_METHOD_3;
+
+		else {
+			hw->mcfg = CFG_METHOD_3;
+			hw->HwIcVerUnknown = TRUE;
+		}
+
+		hw->efuse_ver = EFUSE_SUPPORT_V4;
+		break;
+	case 0x64000000:
+		if (ic_version_id == 0x00000000)
+			hw->mcfg = CFG_METHOD_4;
+
+		else if (ic_version_id == 0x100000)
+			hw->mcfg = CFG_METHOD_5;
+
+		else {
+			hw->mcfg = CFG_METHOD_5;
+			hw->HwIcVerUnknown = TRUE;
+		}
+
+		hw->efuse_ver = EFUSE_SUPPORT_V4;
+		break;
+	case 0x68000000:
+		if (ic_version_id == 0x00000000)
+			hw->mcfg = CFG_METHOD_8;
+		else if (ic_version_id == 0x100000)
+			hw->mcfg = CFG_METHOD_9;
+		else {
+			hw->mcfg = CFG_METHOD_9;
+			hw->HwIcVerUnknown = TRUE;
+		}
+
+		hw->efuse_ver = EFUSE_SUPPORT_V4;
+		break;
+	case 0x68800000:
+		if (ic_version_id == 0x00000000)
+			hw->mcfg = CFG_METHOD_10;
+		else if (ic_version_id == 0x100000)
+			hw->mcfg = CFG_METHOD_11;
+		else {
+			hw->mcfg = CFG_METHOD_11;
+			hw->HwIcVerUnknown = TRUE;
+		}
+
+		hw->efuse_ver = EFUSE_SUPPORT_V4;
+		break;
+	default:
+		PMD_INIT_LOG(NOTICE, "unknown chip version (%x)", reg);
+		hw->mcfg = CFG_METHOD_DEFAULT;
+		hw->HwIcVerUnknown = TRUE;
+		hw->efuse_ver = EFUSE_NOT_SUPPORT;
+		break;
+	}
+
+	if (pci_dev->id.device_id == 0x8162) {
+		if (hw->mcfg == CFG_METHOD_3)
+			hw->mcfg = CFG_METHOD_6;
+		else if (hw->mcfg == CFG_METHOD_5)
+			hw->mcfg = CFG_METHOD_7;
+	}
+}
+
+void
+rtl8125_enable_cfg9346_write(struct rtl8125_hw *hw)
+{
+	RTL_W8(hw, Cfg9346, RTL_R8(hw, Cfg9346) | Cfg9346_Unlock);
+}
+
+void
+rtl8125_disable_cfg9346_write(struct rtl8125_hw *hw)
+{
+	RTL_W8(hw, Cfg9346, RTL_R8(hw, Cfg9346) & ~Cfg9346_Unlock);
+}
+
+void
+rtl8125_rar_set(struct rtl8125_hw *hw, uint8_t *addr)
+{
+	uint32_t rar_low = 0;
+	uint32_t rar_high = 0;
+
+	rar_low = ((uint32_t) addr[0] |
+	           ((uint32_t) addr[1] << 8) |
+	           ((uint32_t) addr[2] << 16) |
+	           ((uint32_t) addr[3] << 24));
+
+	rar_high = ((uint32_t) addr[4] |
+	            ((uint32_t) addr[5] << 8));
+
+	rtl8125_enable_cfg9346_write(hw);
+	RTL_W32(hw, MAC0, rar_low);
+	RTL_W32(hw, MAC4, rar_high);
+
+	rtl8125_disable_cfg9346_write(hw);
+}
+
+int
+rtl8125_get_mac_address(struct rtl8125_hw *hw, struct rte_ether_addr *ea)
+{
+	u8 mac_addr[MAC_ADDR_LEN];
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		*(u32 *)&mac_addr[0] = RTL_R32(hw, BACKUP_ADDR0_8125);
+		*(u16 *)&mac_addr[4] = RTL_R16(hw, BACKUP_ADDR1_8125);
+		break;
+	default:
+		break;
+	}
+
+	rte_ether_addr_copy((struct rte_ether_addr *)mac_addr, ea);
+
+	return 0;
+}
+
+int
+rtl8125_set_hw_ops(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	/* 8125A */
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+		hw->hw_ops = rtl8125a_ops;
+		return 0;
+	/* 8125B */
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+		hw->hw_ops = rtl8125b_ops;
+		return 0;
+	/* 8125BP */
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		hw->hw_ops = rtl8125bp_ops;
+		return 0;
+	/* 8125D */
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		hw->hw_ops = rtl8125d_ops;
+		return 0;
+	default:
+		return -ENOTSUP;
+	}
+}
+
+static bool
+rtl8125_stop_all_request(struct rtl8125_hw *hw)
+{
+	int i;
+
+	RTL_W8(hw, ChipCmd, RTL_R8(hw, ChipCmd) | StopReq);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		for (i = 0; i < 20; i++) {
+			udelay(10);
+			if (!(RTL_R8(hw, ChipCmd) & StopReq)) break;
+		}
+
+		if (i == 20)
+			return 0;
+		break;
+	}
+
+	return 1;
+}
+
+static void
+rtl8125_wait_txrx_fifo_empty(struct rtl8125_hw *hw)
+{
+	int i;
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		for (i = 0; i < 3000; i++) {
+			udelay(50);
+			if ((RTL_R8(hw, MCUCmd_reg) & (Txfifo_empty | Rxfifo_empty)) ==
+			    (Txfifo_empty | Rxfifo_empty))
+				break;
+		}
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+	case CFG_METHOD_7:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		for (i = 0; i < 3000; i++) {
+			udelay(50);
+			if ((RTL_R16(hw, IntrMitigate) & (BIT_0 | BIT_1 | BIT_8)) ==
+			    (BIT_0 | BIT_1 | BIT_8))
+				break;
+		}
+		break;
+	}
+}
+
+static void
+rtl8125_wait_ll_share_fifo_ready(struct rtl8125_hw *hw)
+{
+	int i;
+
+	for (i = 0; i < 10; i++) {
+		udelay(100);
+		if (RTL_R16(hw, 0xD2) & BIT_9)
+			break;
+	}
+}
+
+static void
+rtl8125_disable_now_is_oob(struct rtl8125_hw *hw)
+{
+	if (hw->HwSuppNowIsOobVer == 1)
+		RTL_W8(hw, MCUCmd_reg, RTL_R8(hw, MCUCmd_reg) & ~Now_is_oob);
+}
+
+void
+rtl8125_enable_force_clkreq(struct rtl8125_hw *hw, bool enable)
+{
+	if (enable)
+		RTL_W8(hw, 0xF1, RTL_R8(hw, 0xF1) | BIT_7);
+	else
+		RTL_W8(hw, 0xF1, RTL_R8(hw, 0xF1) & ~BIT_7);
+}
+
+void
+rtl8125_enable_aspm_clkreq_lock(struct rtl8125_hw *hw, bool enable)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_enable_cfg9346_write(hw);
+		if (enable) {
+			RTL_W8(hw, Config2, RTL_R8(hw, Config2) | BIT_7);
+			RTL_W8(hw, Config5, RTL_R8(hw, Config5) | BIT_0);
+		} else {
+			RTL_W8(hw, Config2, RTL_R8(hw, Config2) & ~BIT_7);
+			RTL_W8(hw, Config5, RTL_R8(hw, Config5) & ~BIT_0);
+		}
+		rtl8125_disable_cfg9346_write(hw);
+		break;
+	}
+}
+
+void
+rtl8125_hw_disable_mac_mcu_bps(struct rtl8125_hw *hw)
+{
+	u16 reg_addr;
+
+	rtl8125_enable_aspm_clkreq_lock(hw, 0);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xFC48, 0x0000);
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		for (reg_addr = 0xFC28; reg_addr < 0xFC48; reg_addr += 2)
+			rtl8125_mac_ocp_write(hw, reg_addr, 0x0000);
+
+		mdelay(3);
+
+		rtl8125_mac_ocp_write(hw, 0xFC26, 0x0000);
+		break;
+	}
+}
+
+static void
+rtl8125_enable_rxdvgate(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W8(hw, 0xF2, RTL_R8(hw, 0xF2) | BIT_3);
+		mdelay(2);
+	}
+}
+
+void
+rtl8125_disable_rxdvgate(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W8(hw, 0xF2, RTL_R8(hw, 0xF2) & ~BIT_3);
+		mdelay(2);
+	}
+}
+
+void
+rtl8125_nic_reset(struct rtl8125_hw *hw)
+{
+	int i;
+
+	RTL_W32(hw, RxConfig, (RX_DMA_BURST_unlimited << RxCfgDMAShift));
+
+	rtl8125_enable_rxdvgate(hw);
+
+	rtl8125_stop_all_request(hw);
+
+	rtl8125_wait_txrx_fifo_empty(hw);
+
+	mdelay(2);
+
+	/* Soft reset the chip. */
+	RTL_W8(hw, ChipCmd, CmdReset);
+
+	/* Check that the chip has finished the reset. */
+	for (i = 100; i > 0; i--) {
+		udelay(100);
+		if ((RTL_R8(hw, ChipCmd) & CmdReset) == 0)
+			break;
+	}
+}
+
+static void
+rtl8125_disable_rx_packet_filter(struct rtl8125_hw *hw)
+{
+	RTL_W32(hw, RxConfig, RTL_R32(hw, RxConfig) &
+	        ~(AcceptErr | AcceptRunt | AcceptBroadcast | AcceptMulticast |
+	          AcceptMyPhys | AcceptAllPhys));
+}
+
+static void
+rtl8125_exit_realwow(struct rtl8125_hw *hw)
+{
+	/* Disable realwow function */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xC0BC, 0x00FF);
+		break;
+	}
+}
+
+void
+rtl8125_exit_oob(struct rtl8125_hw *hw)
+{
+	u16 data16;
+
+	rtl8125_disable_rx_packet_filter(hw);
+
+	if (HW_DASH_SUPPORT_DASH(hw)) {
+		rtl8125_driver_start(hw);
+		rtl8125_dash2_disable_txrx(hw);
+	}
+
+	rtl8125_exit_realwow(hw);
+
+	rtl8125_nic_reset(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_disable_now_is_oob(hw);
+
+		data16 = rtl8125_mac_ocp_read(hw, 0xE8DE) & ~BIT_14;
+		rtl8125_mac_ocp_write(hw, 0xE8DE, data16);
+		rtl8125_wait_ll_share_fifo_ready(hw);
+
+		rtl8125_mac_ocp_write(hw, 0xC0AA, 0x07D0);
+
+		rtl8125_mac_ocp_write(hw, 0xC0A6, 0x01B5);
+
+		rtl8125_mac_ocp_write(hw, 0xC01E, 0x5555);
+
+		rtl8125_wait_ll_share_fifo_ready(hw);
+		break;
+	}
+}
+
+void
+rtl8125_disable_ups(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mac_ocp_write(hw, 0xD40A, rtl8125_mac_ocp_read(hw, 0xD40A) & ~(BIT_4));
+	}
+}
+
+static bool
+rtl8125_is_autoneg_mode_valid(u32 autoneg)
+{
+	switch (autoneg) {
+	case AUTONEG_ENABLE:
+	case AUTONEG_DISABLE:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool
+rtl8125_is_speed_mode_valid(u32 speed)
+{
+	switch (speed) {
+	case SPEED_2500:
+	case SPEED_1000:
+	case SPEED_100:
+	case SPEED_10:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool
+rtl8125_is_duplex_mode_valid(u8 duplex)
+{
+	switch (duplex) {
+	case DUPLEX_FULL:
+	case DUPLEX_HALF:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static void
+rtl8125_set_link_option(struct rtl8125_hw *hw,
+                        u8 autoneg,
+                        u32 speed,
+                        u8 duplex,
+                        enum rtl8125_fc_mode fc)
+{
+	u64 adv;
+
+	if (!rtl8125_is_speed_mode_valid(speed))
+		speed = SPEED_2500;
+
+	if (!rtl8125_is_duplex_mode_valid(duplex))
+		duplex = DUPLEX_FULL;
+
+	if (!rtl8125_is_autoneg_mode_valid(autoneg))
+		autoneg = AUTONEG_ENABLE;
+
+	speed = RTE_MIN(speed, hw->HwSuppMaxPhyLinkSpeed);
+
+	adv = 0;
+	switch (speed) {
+	case SPEED_2500:
+		adv |= ADVERTISE_2500_FULL;
+	/* Fall through */
+	default:
+		adv |= (ADVERTISE_10_HALF | ADVERTISE_10_FULL |
+		        ADVERTISE_100_HALF | ADVERTISE_100_FULL |
+		        ADVERTISE_1000_HALF | ADVERTISE_1000_FULL);
+		break;
+	}
+
+	hw->autoneg = autoneg;
+	hw->speed = speed;
+	hw->duplex = duplex;
+	hw->advertising = adv;
+	hw->fcpause = fc;
+}
+
+void
+rtl8125_init_software_variable(struct rtl8125_hw *hw)
+{
+	int tx_no_close_enable = 1;
+	unsigned int speed_mode = SPEED_2500;
+	unsigned int duplex_mode = DUPLEX_FULL;
+	unsigned int autoneg_mode = AUTONEG_ENABLE;
+	u8 tmp;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+		tmp = (u8)rtl8125_mac_ocp_read(hw, 0xD006);
+		if (tmp == 0x02 || tmp == 0x04)
+			hw->HwSuppDashVer = 2;
+		break;
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		hw->HwSuppDashVer = 4;
+		break;
+	default:
+		hw->HwSuppDashVer = 0;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+		if (HW_DASH_SUPPORT_DASH(hw))
+			hw->HwSuppOcpChannelVer = 2;
+		break;
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		hw->HwSuppOcpChannelVer = 2;
+		break;
+	}
+
+	hw->AllowAccessDashOcp = rtl8125_is_allow_access_dash_ocp(hw);
+
+	if (HW_DASH_SUPPORT_DASH(hw) && rtl8125_check_dash(hw))
+		hw->DASH = 1;
+	else
+		hw->DASH = 0;
+
+	if (HW_DASH_SUPPORT_TYPE_2(hw))
+		hw->cmac_ioaddr = hw->mmio_addr;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+		hw->chipset_name = RTL8125A;
+		break;
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+		hw->chipset_name = RTL8125B;
+		break;
+	case CFG_METHOD_6:
+	case CFG_METHOD_7:
+		hw->chipset_name = RTL8168KB;
+		break;
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		hw->chipset_name = RTL8125BP;
+		break;
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		hw->chipset_name = RTL8125D;
+		break;
+	default:
+		hw->chipset_name = UNKNOWN;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		hw->HwSuppNowIsOobVer = 1;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		hw->HwSuppCheckPhyDisableModeVer = 3;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		hw->HwSuppMaxPhyLinkSpeed = 2500;
+		break;
+	default:
+		hw->HwSuppMaxPhyLinkSpeed = 1000;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_7:
+		hw->HwSuppTxNoCloseVer = 3;
+		break;
+	case CFG_METHOD_8 ... CFG_METHOD_11:
+		hw->HwSuppTxNoCloseVer = 6;
+		break;
+	}
+
+	switch (hw->HwSuppTxNoCloseVer) {
+	case 3:
+		hw->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2;
+		hw->hw_clo_ptr_reg = HW_CLO_PTR0_8125;
+		hw->sw_tail_ptr_reg = SW_TAIL_PTR0_8125;
+		break;
+	case 6:
+		hw->MaxTxDescPtrMask = MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4;
+		hw->hw_clo_ptr_reg = HW_CLO_PTR0_8125BP;
+		hw->sw_tail_ptr_reg = SW_TAIL_PTR0_8125BP;
+		break;
+	default:
+		tx_no_close_enable = 0;
+		hw->hw_clo_ptr_reg = HW_CLO_PTR0_8125;
+		hw->sw_tail_ptr_reg = SW_TAIL_PTR0_8125;
+		break;
+	}
+
+	if (hw->HwSuppTxNoCloseVer > 0 && tx_no_close_enable == 1)
+		hw->EnableTxNoClose = TRUE;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_2;
+		break;
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_3;
+		break;
+	case CFG_METHOD_4:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_4;
+		break;
+	case CFG_METHOD_5:
+	case CFG_METHOD_7:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_5;
+		break;
+	case CFG_METHOD_8:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_8;
+		break;
+	case CFG_METHOD_9:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_9;
+		break;
+	case CFG_METHOD_10:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_10;
+		break;
+	case CFG_METHOD_11:
+		hw->sw_ram_code_ver = NIC_RAMCODE_VERSION_CFG_METHOD_11;
+		break;
+	}
+
+	if (hw->HwIcVerUnknown) {
+		hw->NotWrRamCodeToMicroP = TRUE;
+		hw->NotWrMcuPatchCode = TRUE;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		if ((rtl8125_mac_ocp_read(hw, 0xD442) & BIT_5) &&
+		    (rtl8125_mdio_direct_read_phy_ocp(hw, 0xD068) & BIT_1))
+			hw->RequirePhyMdiSwapPatch = TRUE;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		hw->HwSuppMacMcuVer = 2;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		hw->MacMcuPageSize = RTL8125_MAC_MCU_PAGE_SIZE;
+		break;
+	}
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		hw->HwSuppIntMitiVer = 3;
+		break;
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+	case CFG_METHOD_7:
+		hw->HwSuppIntMitiVer = 4;
+		break;
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		hw->HwSuppIntMitiVer = 6;
+		break;
+	}
+
+	rtl8125_set_link_option(hw, autoneg_mode, speed_mode, duplex_mode,
+	                        rtl8125_fc_full);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		hw->mcu_pme_setting = rtl8125_mac_ocp_read(hw, 0xE00A);
+		break;
+	}
+}
+
+void
+rtl8125_get_tally_stats(struct rtl8125_hw *hw, struct rte_eth_stats *rte_stats)
+{
+	struct rtl8125_counters *counters;
+	uint64_t paddr;
+	u32 cmd;
+	u32 wait_cnt;
+
+	counters = hw->tally_vaddr;
+	paddr = hw->tally_paddr;
+	if (!counters)
+		return;
+
+	RTL_W32(hw, CounterAddrHigh, (u64)paddr >> 32);
+	cmd = (u64)paddr & DMA_BIT_MASK(32);
+	RTL_W32(hw, CounterAddrLow, cmd);
+	RTL_W32(hw, CounterAddrLow, cmd | CounterDump);
+
+	wait_cnt = 0;
+	while (RTL_R32(hw, CounterAddrLow) & CounterDump) {
+		udelay(10);
+
+		wait_cnt++;
+		if (wait_cnt > 20)
+			break;
+	}
+
+	/* RX errors */
+	rte_stats->imissed = rte_le_to_cpu_64(counters->rx_missed);
+	rte_stats->ierrors = rte_le_to_cpu_64(counters->rx_errors);
+
+	/* TX errors */
+	rte_stats->oerrors = rte_le_to_cpu_64(counters->tx_errors);
+
+	rte_stats->ipackets = rte_le_to_cpu_64(counters->rx_packets);
+	rte_stats->opackets = rte_le_to_cpu_64(counters->tx_packets);
+}
+
+void
+rtl8125_clear_tally_stats(struct rtl8125_hw *hw)
+{
+	if (!hw->tally_paddr)
+		return;
+
+	RTL_W32(hw, CounterAddrHigh, (u64)hw->tally_paddr >> 32);
+	RTL_W32(hw, CounterAddrLow,
+	        ((u64)hw->tally_paddr & (DMA_BIT_MASK(32))) | CounterReset);
+}
+
+static void
+rtl8125_switch_mac_mcu_ram_code_page(struct rtl8125_hw *hw, u16 page)
+{
+	u16 tmp_ushort;
+
+	page &= (BIT_1 | BIT_0);
+	tmp_ushort = rtl8125_mac_ocp_read(hw, 0xE446);
+	tmp_ushort &= ~(BIT_1 | BIT_0);
+	tmp_ushort |= page;
+	rtl8125_mac_ocp_write(hw, 0xE446, tmp_ushort);
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code(struct rtl8125_hw *hw, const u16 *entry,
+                                u16 entry_cnt)
+{
+	u16 i;
+
+	for (i = 0; i < entry_cnt; i++)
+		rtl8125_mac_ocp_write(hw, 0xF800 + i * 2, entry[i]);
+}
+
+static void
+_rtl8125_write_mac_mcu_ram_code_with_page(struct rtl8125_hw *hw,
+                const u16 *entry, u16 entry_cnt, u16 page_size)
+{
+	u16 i;
+	u16 offset;
+
+	if (page_size == 0) return;
+
+	for (i = 0; i < entry_cnt; i++) {
+		offset = i % page_size;
+		if (offset == 0) {
+			u16 page = (i / page_size);
+			rtl8125_switch_mac_mcu_ram_code_page(hw, page);
+		}
+		rtl8125_mac_ocp_write(hw, 0xF800 + offset * 2, entry[i]);
+	}
+}
+
+void
+rtl8125_write_mac_mcu_ram_code(struct rtl8125_hw *hw, const u16 *entry,
+                               u16 entry_cnt)
+{
+	if (FALSE == HW_SUPPORT_MAC_MCU(hw))
+		return;
+	if (entry == NULL || entry_cnt == 0)
+		return;
+
+	if (hw->MacMcuPageSize > 0)
+		_rtl8125_write_mac_mcu_ram_code_with_page(hw, entry, entry_cnt,
+		                hw->MacMcuPageSize);
+	else
+		_rtl8125_write_mac_mcu_ram_code(hw, entry, entry_cnt);
+}
+
+static u32
+rtl8125_eri_read_with_oob_base_address(struct rtl8125_hw *hw, int addr, int len,
+                                       int type, const u32 base_address)
+{
+	int i, val_shift, shift = 0;
+	u32 value1 = 0;
+	u32 value2 = 0;
+	u32 eri_cmd, tmp, mask;
+	const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) |
+	                                     (base_address & 0x000FFF);
+
+	if (len > 4 || len <= 0)
+		return -1;
+
+	while (len > 0) {
+		val_shift = addr % ERIAR_Addr_Align;
+		addr = addr & ~0x3;
+
+		eri_cmd = ERIAR_Read | transformed_base_address |
+		          type << ERIAR_Type_shift |
+		          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+		          (addr & 0x0FFF);
+		if (addr & 0xF000) {
+			tmp = addr & 0xF000;
+			tmp >>= 12;
+			eri_cmd |= (tmp << 20) & 0x00F00000;
+		}
+
+		RTL_W32(hw, ERIAR, eri_cmd);
+
+		for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+			udelay(R8125_CHANNEL_WAIT_TIME);
+
+			/* Check if the RTL8125 has completed ERI read */
+			if (RTL_R32(hw, ERIAR) & ERIAR_Flag)
+				break;
+		}
+
+		if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+		value1 = RTL_R32(hw, ERIDR) & mask;
+		value2 |= (value1 >> val_shift * 8) << shift * 8;
+
+		if (len <= 4 - val_shift)
+			len = 0;
+		else {
+			len -= (4 - val_shift);
+			shift = 4 - val_shift;
+			addr += 4;
+		}
+	}
+
+	udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+	return value2;
+}
+
+static int
+rtl8125_eri_write_with_oob_base_address(struct rtl8125_hw *hw, int addr,
+                                        int len, u32 value, int type, const u32 base_address)
+{
+	int i, val_shift, shift = 0;
+	u32 value1 = 0;
+	u32 eri_cmd, mask, tmp;
+	const u32 transformed_base_address = ((base_address & 0x00FFF000) << 6) |
+	                                     (base_address & 0x000FFF);
+
+	if (len > 4 || len <= 0)
+		return -1;
+
+	while (len > 0) {
+		val_shift = addr % ERIAR_Addr_Align;
+		addr = addr & ~0x3;
+
+		if (len == 1)       mask = (0xFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else if (len == 2)  mask = (0xFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else if (len == 3)  mask = (0xFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+		else            mask = (0xFFFFFFFF << (val_shift * 8)) & 0xFFFFFFFF;
+
+		value1 = rtl8125_eri_read_with_oob_base_address(hw, addr, 4, type,
+		                base_address) & ~mask;
+		value1 |= ((value << val_shift * 8) >> shift * 8);
+
+		RTL_W32(hw, ERIDR, value1);
+
+		eri_cmd = ERIAR_Write | transformed_base_address |
+		          type << ERIAR_Type_shift |
+		          ERIAR_ByteEn << ERIAR_ByteEn_shift |
+		          (addr & 0x0FFF);
+		if (addr & 0xF000) {
+			tmp = addr & 0xF000;
+			tmp >>= 12;
+			eri_cmd |= (tmp << 20) & 0x00F00000;
+		}
+
+		RTL_W32(hw, ERIAR, eri_cmd);
+
+		for (i = 0; i < R8125_CHANNEL_WAIT_COUNT; i++) {
+			udelay(R8125_CHANNEL_WAIT_TIME);
+
+			/* Check if the RTL8125 has completed ERI write */
+			if (!(RTL_R32(hw, ERIAR) & ERIAR_Flag))
+				break;
+		}
+
+		if (len <= 4 - val_shift)
+			len = 0;
+		else {
+			len -= (4 - val_shift);
+			shift = 4 - val_shift;
+			addr += 4;
+		}
+	}
+
+	udelay(R8125_CHANNEL_EXIT_DELAY_TIME);
+
+	return 0;
+}
+
+static u32
+rtl8125_ocp_read_with_oob_base_address(struct rtl8125_hw *hw, u16 addr, u8 len,
+                                       const u32 base_address)
+{
+	return rtl8125_eri_read_with_oob_base_address(hw, addr, len, ERIAR_OOB,
+	                base_address);
+}
+
+u32
+rtl8125_ocp_read(struct rtl8125_hw *hw, u16 addr, u8 len)
+{
+	u32 value = 0;
+
+	if (!hw->AllowAccessDashOcp)
+		return 0xffffffff;
+
+	if (hw->HwSuppOcpChannelVer == 2)
+		value = rtl8125_ocp_read_with_oob_base_address(hw, addr, len, NO_BASE_ADDRESS);
+
+	return value;
+}
+
+static u32
+rtl8125_ocp_write_with_oob_base_address(struct rtl8125_hw *hw, u16 addr, u8 len,
+                                        u32 value, const u32 base_address)
+{
+	return rtl8125_eri_write_with_oob_base_address(hw, addr, len, value, ERIAR_OOB,
+	                base_address);
+}
+
+void
+rtl8125_ocp_write(struct rtl8125_hw *hw, u16 addr, u8 len, u32 value)
+{
+	if (!hw->AllowAccessDashOcp)
+		return;
+
+	if (hw->HwSuppOcpChannelVer == 2)
+		rtl8125_ocp_write_with_oob_base_address(hw, addr, len, value, NO_BASE_ADDRESS);
+}
+
+void
+rtl8125_oob_mutex_lock(struct rtl8125_hw *hw)
+{
+	u8 reg_16, reg_a0;
+	u32 wait_cnt_0, wait_cnt_1;
+	u16 ocp_reg_mutex_ib;
+	u16 ocp_reg_mutex_oob;
+	u16 ocp_reg_mutex_prio;
+
+	if (!hw->DASH)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		ocp_reg_mutex_oob = 0x110;
+		ocp_reg_mutex_ib = 0x114;
+		ocp_reg_mutex_prio = 0x11C;
+		break;
+	default:
+		return;
+	}
+
+	rtl8125_ocp_write(hw, ocp_reg_mutex_ib, 1, BIT_0);
+	reg_16 = rtl8125_ocp_read(hw, ocp_reg_mutex_oob, 1);
+	wait_cnt_0 = 0;
+	while (reg_16) {
+		reg_a0 = rtl8125_ocp_read(hw, ocp_reg_mutex_prio, 1);
+		if (reg_a0) {
+			rtl8125_ocp_write(hw, ocp_reg_mutex_ib, 1, 0x00);
+			reg_a0 = rtl8125_ocp_read(hw, ocp_reg_mutex_prio, 1);
+			wait_cnt_1 = 0;
+			while (reg_a0) {
+				reg_a0 = rtl8125_ocp_read(hw, ocp_reg_mutex_prio, 1);
+
+				wait_cnt_1++;
+
+				if (wait_cnt_1 > 2000)
+					break;
+			};
+			rtl8125_ocp_write(hw, ocp_reg_mutex_ib, 1, BIT_0);
+
+		}
+		reg_16 = rtl8125_ocp_read(hw, ocp_reg_mutex_oob, 1);
+
+		wait_cnt_0++;
+
+		if (wait_cnt_0 > 2000)
+			break;
+	};
+}
+
+void
+rtl8125_oob_mutex_unlock(struct rtl8125_hw *hw)
+{
+	u16 ocp_reg_mutex_ib;
+	u16 ocp_reg_mutex_prio;
+
+	if (!hw->DASH)
+		return;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		ocp_reg_mutex_ib = 0x114;
+		ocp_reg_mutex_prio = 0x11C;
+		break;
+	default:
+		return;
+	}
+
+	rtl8125_ocp_write(hw, ocp_reg_mutex_prio, 1, BIT_0);
+	rtl8125_ocp_write(hw, ocp_reg_mutex_ib, 1, 0x00);
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_hw.h
@@ -0,0 +1,97 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _R8125_HW_H_
+#define _R8125_HW_H_
+
+#include <stdint.h>
+
+#include <bus_pci_driver.h>
+#include <rte_ethdev.h>
+#include <rte_ethdev_core.h>
+
+#include "r8125_base.h"
+#include "r8125_ethdev.h"
+#include "r8125_phy.h"
+#include "r8125_dash.h"
+
+u16 rtl8125_mac_ocp_read(struct rtl8125_hw *hw, u16 addr);
+void rtl8125_mac_ocp_write(struct rtl8125_hw *hw, u16 addr, u16 value);
+
+u32 rtl8125_csi_read(struct rtl8125_hw *hw, u32 addr);
+
+void rtl8125_get_mac_version(struct rtl8125_hw *hw,
+                             struct rte_pci_device *pci_dev);
+int rtl8125_get_mac_address(struct rtl8125_hw *hw, struct rte_ether_addr *ea);
+
+void rtl8125_enable_cfg9346_write(struct rtl8125_hw *hw);
+void rtl8125_disable_cfg9346_write(struct rtl8125_hw *hw);
+
+void rtl8125_rar_set(struct rtl8125_hw *hw, uint8_t *addr);
+
+void rtl8125_hw_disable_mac_mcu_bps(struct rtl8125_hw *hw);
+
+void rtl8125_disable_ups(struct rtl8125_hw *hw);
+
+void rtl8125_disable_rxdvgate(struct rtl8125_hw *hw);
+
+void rtl8125_init_software_variable(struct rtl8125_hw *hw);
+
+void rtl8125_get_tally_stats(struct rtl8125_hw *hw,
+                             struct rte_eth_stats *stats);
+void rtl8125_clear_tally_stats(struct rtl8125_hw *hw);
+
+void rtl8125_exit_oob(struct rtl8125_hw *hw);
+void rtl8125_nic_reset(struct rtl8125_hw *hw);
+
+int rtl8125_set_hw_ops(struct rtl8125_hw *hw);
+
+void rtl8125_write_mac_mcu_ram_code(struct rtl8125_hw *hw, const u16 *entry,
+                                    u16 entry_cnt);
+
+void rtl8125_enable_force_clkreq(struct rtl8125_hw *hw, bool enable);
+void rtl8125_enable_aspm_clkreq_lock(struct rtl8125_hw *hw, bool enable);
+
+bool rtl8125_is_speed_mode_valid(u32 speed);
+
+void rtl8125_ocp_write(struct rtl8125_hw *hw, u16 addr, u8 len, u32 value);
+u32 rtl8125_ocp_read(struct rtl8125_hw *hw, u16 addr, u8 len);
+
+void rtl8125_oob_mutex_lock(struct rtl8125_hw *hw);
+void rtl8125_oob_mutex_unlock(struct rtl8125_hw *hw);
+
+extern const struct rtl8125_hw_ops rtl8125a_ops;
+extern const struct rtl8125_hw_ops rtl8125b_ops;
+extern const struct rtl8125_hw_ops rtl8125bp_ops;
+extern const struct rtl8125_hw_ops rtl8125d_ops;
+
+#define RTL8125_MAC_MCU_PAGE_SIZE 256
+
+#define ARRAY_SIZE(arr) RTE_DIM(arr)
+
+#define HW_SUPPORT_CHECK_PHY_DISABLE_MODE(_M) ((_M)->HwSuppCheckPhyDisableModeVer > 0 )
+#define HW_HAS_WRITE_PHY_MCU_RAM_CODE(_M)     (((_M)->HwHasWrRamCodeToMicroP == TRUE) ? 1 : 0)
+#define HW_SUPPORT_D0_SPEED_UP(_M)            ((_M)->HwSuppD0SpeedUpVer > 0)
+#define HW_SUPPORT_MAC_MCU(_M)                ((_M)->HwSuppMacMcuVer > 0)
+
+#define HW_SUPP_PHY_LINK_SPEED_GIGA(_M)	      ((_M)->HwSuppMaxPhyLinkSpeed >= 1000)
+#define HW_SUPP_PHY_LINK_SPEED_2500M(_M)      ((_M)->HwSuppMaxPhyLinkSpeed >= 2500)
+
+#define NO_BASE_ADDRESS 0x00000000
+
+/* Tx NO CLOSE */
+#define MAX_TX_NO_CLOSE_DESC_PTR_V2            0x10000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V2       0xFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V3            0x100000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V3       0xFFFFFFFF
+#define MAX_TX_NO_CLOSE_DESC_PTR_V4            0x80000000
+#define MAX_TX_NO_CLOSE_DESC_PTR_MASK_V4       0x7FFFFFFF
+#define TX_NO_CLOSE_SW_PTR_MASK_V2             0x1FFFF
+
+/* Channel wait count */
+#define R8125_CHANNEL_WAIT_COUNT       20000
+#define R8125_CHANNEL_WAIT_TIME        1   /* 1us */
+#define R8125_CHANNEL_EXIT_DELAY_TIME  20  /* 20us */
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_logs.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _r8125_LOGS_H_
+#define _r8125_LOGS_H_
+
+#include <rte_log.h>
+
+extern int r8125_logtype_init;
+#define PMD_INIT_LOG(level, fmt, args...) \
+	rte_log(RTE_LOG_ ## level, r8125_logtype_init, \
+		"%s(): " fmt "\n", __func__, ##args)
+
+#define PMD_INIT_FUNC_TRACE() PMD_INIT_LOG(DEBUG, " >>")
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_RX
+extern int r8125_logtype_rx;
+#define PMD_RX_LOG(level, fmt, args...)			\
+	rte_log(RTE_LOG_ ## level, r8125_logtype_rx,	\
+		"%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_RX_LOG(level, fmt, args...) do { } while (0)
+#endif
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX
+extern int r8125_logtype_tx;
+#define PMD_TX_LOG(level, fmt, args...)			\
+	rte_log(RTE_LOG_ ## level, r8125_logtype_tx,	\
+		"%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_TX_LOG(level, fmt, args...) do { } while (0)
+#endif
+
+#ifdef RTE_LIBRTE_R8125_DEBUG_TX_FREE
+extern int r8125_logtype_tx_free;
+#define PMD_TX_FREE_LOG(level, fmt, args...)			\
+	rte_log(RTE_LOG_ ## level, r8125_logtype_tx_free,	\
+		"%s(): " fmt "\n", __func__, ## args)
+#else
+#define PMD_TX_FREE_LOG(level, fmt, args...) do { } while (0)
+#endif
+
+extern int r8125_logtype_driver;
+#define PMD_DRV_LOG_RAW(level, fmt, args...) \
+	rte_log(RTE_LOG_ ## level, r8125_logtype_driver, "%s(): " fmt, \
+		__func__, ## args)
+
+#define PMD_DRV_LOG(level, fmt, args...) \
+	PMD_DRV_LOG_RAW(level, fmt "\n", ## args)
+
+#endif /* _r8125_LOGS_H_ */
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_phy.c
@@ -0,0 +1,900 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+
+#include "r8125_ethdev.h"
+#include "r8125_hw.h"
+#include "r8125_phy.h"
+#include "r8125_logs.h"
+
+static u16
+rtl8125_map_phy_ocp_addr(u16 PageNum, u8 RegNum)
+{
+	u16 ocp_page_num = 0;
+	u16 ocp_phy_address = 0;
+	u8 ocp_reg_num = 0;
+
+
+	if (PageNum == 0) {
+		ocp_page_num = OCP_STD_PHY_BASE_PAGE + (RegNum / 8);
+		ocp_reg_num = 0x10 + (RegNum % 8);
+	} else {
+		ocp_page_num = PageNum;
+		ocp_reg_num = RegNum;
+	}
+
+	ocp_page_num <<= 4;
+
+	if (ocp_reg_num < 16)
+		ocp_phy_address = 0;
+
+	else {
+		ocp_reg_num -= 16;
+		ocp_reg_num <<= 1;
+
+		ocp_phy_address = ocp_page_num + ocp_reg_num;
+	}
+
+
+	return ocp_phy_address;
+}
+
+static u32
+rtl8125_mdio_real_read_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr)
+{
+	u32 data32;
+	int i, value = 0;
+
+	data32 = RegAddr / 2;
+	data32 <<= OCPR_Addr_Reg_shift;
+
+	RTL_W32(hw, PHYOCP, data32);
+	for (i = 0; i < 100; i++) {
+		udelay(1);
+
+		if (RTL_R32(hw, PHYOCP) & OCPR_Flag)
+			break;
+	}
+	value = RTL_R32(hw, PHYOCP) & OCPDR_Data_Mask;
+
+	return value;
+}
+
+u32
+rtl8125_mdio_direct_read_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr)
+{
+	return rtl8125_mdio_real_read_phy_ocp(hw, RegAddr);
+}
+
+static u32
+rtl8125_mdio_read_phy_ocp(struct rtl8125_hw *hw, u16 PageNum, u32 RegAddr)
+{
+	u16 ocp_addr;
+
+	ocp_addr = rtl8125_map_phy_ocp_addr(PageNum, RegAddr);
+
+	return rtl8125_mdio_direct_read_phy_ocp(hw, ocp_addr);
+}
+
+static u32
+rtl8125_mdio_real_read(struct rtl8125_hw *hw, u32 RegAddr)
+{
+	return rtl8125_mdio_read_phy_ocp(hw, hw->cur_page, RegAddr);
+}
+
+static void
+rtl8125_mdio_real_write_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr, u32 value)
+{
+	u32 data32;
+	int i;
+
+	data32 = RegAddr / 2;
+	data32 <<= OCPR_Addr_Reg_shift;
+	data32 |= OCPR_Write | value;
+
+	RTL_W32(hw, PHYOCP, data32);
+	for (i = 0; i < 100; i++) {
+		udelay(1);
+
+		if (!(RTL_R32(hw, PHYOCP) & OCPR_Flag))
+			break;
+	}
+}
+
+void
+rtl8125_mdio_direct_write_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr, u32 value)
+{
+	rtl8125_mdio_real_write_phy_ocp(hw, RegAddr, value);
+}
+
+static void
+rtl8125_mdio_write_phy_ocp(struct rtl8125_hw *hw, u16 PageNum, u32 RegAddr,
+                           u32 value)
+{
+	u16 ocp_addr;
+
+	ocp_addr = rtl8125_map_phy_ocp_addr(PageNum, RegAddr);
+
+	rtl8125_mdio_direct_write_phy_ocp(hw, ocp_addr, value);
+}
+
+static void
+rtl8125_mdio_real_write(struct rtl8125_hw *hw, u32 RegAddr, u32 value)
+{
+	if (RegAddr == 0x1F)
+		hw->cur_page = value;
+	rtl8125_mdio_write_phy_ocp(hw, hw->cur_page, RegAddr, value);
+}
+
+u32
+rtl8125_mdio_read(struct rtl8125_hw *hw, u32 RegAddr)
+{
+	return rtl8125_mdio_real_read(hw, RegAddr);
+}
+
+void
+rtl8125_mdio_write(struct rtl8125_hw *hw, u32 RegAddr, u32 value)
+{
+	rtl8125_mdio_real_write(hw, RegAddr, value);
+}
+
+void
+rtl8125_clear_and_set_eth_phy_ocp_bit(struct rtl8125_hw *hw, u16 addr,
+                                      u16 clearmask, u16 setmask)
+{
+	u16 phy_reg_value;
+
+	phy_reg_value = rtl8125_mdio_direct_read_phy_ocp(hw, addr);
+	phy_reg_value &= ~clearmask;
+	phy_reg_value |= setmask;
+	rtl8125_mdio_direct_write_phy_ocp(hw, addr, phy_reg_value);
+}
+
+void
+rtl8125_clear_eth_phy_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask)
+{
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, addr, mask, 0);
+}
+
+void
+rtl8125_set_eth_phy_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask)
+{
+	rtl8125_clear_and_set_eth_phy_ocp_bit(hw, addr, 0, mask);
+}
+
+void
+rtl8125_ephy_write(struct rtl8125_hw *hw, int addr, int value)
+{
+	int i;
+
+	RTL_W32(hw, EPHYAR, EPHYAR_Write |
+	        (addr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift |
+	        (value & EPHYAR_Data_Mask));
+
+	for (i = 0; i < 10; i++) {
+		udelay(100);
+
+		/* Check if the RTL8125 has completed EPHY write */
+		if (!(RTL_R32(hw, EPHYAR) & EPHYAR_Flag))
+			break;
+	}
+
+	udelay(20);
+}
+
+static u16
+rtl8125_ephy_read(struct rtl8125_hw *hw, int addr)
+{
+	int i;
+	u16 value = 0xffff;
+
+	RTL_W32(hw, EPHYAR, EPHYAR_Read |
+	        (addr & EPHYAR_Reg_Mask_v2) << EPHYAR_Reg_shift);
+
+	for (i = 0; i < 10; i++) {
+		udelay(100);
+
+		/* Check if the RTL8125 has completed EPHY read */
+		if (RTL_R32(hw, EPHYAR) & EPHYAR_Flag) {
+			value = (u16)(RTL_R32(hw, EPHYAR) & EPHYAR_Data_Mask);
+			break;
+		}
+	}
+
+	udelay(20);
+
+	return value;
+}
+
+void
+rtl8125_clear_and_set_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr,
+                                   u16 clearmask, u16 setmask)
+{
+	u16 ephy_value;
+
+	ephy_value = rtl8125_ephy_read(hw, addr);
+	ephy_value &= ~clearmask;
+	ephy_value |= setmask;
+	rtl8125_ephy_write(hw, addr, ephy_value);
+}
+
+void
+rtl8125_clear_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr, u16 mask)
+{
+	rtl8125_clear_and_set_pcie_phy_bit(hw, addr, mask, 0);
+}
+
+void
+rtl8125_set_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr, u16 mask)
+{
+	rtl8125_clear_and_set_pcie_phy_bit(hw, addr, 0, mask);
+}
+
+static void
+rtl8125_clear_set_mac_ocp_bit(struct rtl8125_hw *hw, u16 addr,
+                              u16 clearmask, u16 setmask)
+{
+	u16 phy_reg_value;
+
+	phy_reg_value = rtl8125_mac_ocp_read(hw, addr);
+	phy_reg_value &= ~clearmask;
+	phy_reg_value |= setmask;
+	rtl8125_mac_ocp_write(hw, addr, phy_reg_value);
+}
+
+void
+rtl8125_clear_mac_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask)
+{
+	rtl8125_clear_set_mac_ocp_bit(hw, addr, mask, 0);
+}
+
+void
+rtl8125_set_mac_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask)
+{
+	rtl8125_clear_set_mac_ocp_bit(hw, addr, 0, mask);
+}
+
+static u16
+rtl8125_get_hw_phy_mcu_code_ver(struct rtl8125_hw *hw)
+{
+	u16 hw_ram_code_ver = ~0;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x801E);
+		hw_ram_code_ver = rtl8125_mdio_direct_read_phy_ocp(hw, 0xA438);
+		break;
+	}
+
+	return hw_ram_code_ver;
+}
+
+static int
+rtl8125_check_hw_phy_mcu_code_ver(struct rtl8125_hw *hw)
+{
+	int ram_code_ver_match = 0;
+
+	hw->hw_ram_code_ver = rtl8125_get_hw_phy_mcu_code_ver(hw);
+
+	if (hw->hw_ram_code_ver == hw->sw_ram_code_ver) {
+		ram_code_ver_match = 1;
+		hw->HwHasWrRamCodeToMicroP = TRUE;
+	} else
+		hw->HwHasWrRamCodeToMicroP = FALSE;
+
+	return ram_code_ver_match;
+}
+
+static void
+rtl8125_write_hw_phy_mcu_code_ver(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA436, 0x801E);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA438, hw->sw_ram_code_ver);
+		hw->hw_ram_code_ver = hw->sw_ram_code_ver;
+		break;
+	}
+}
+
+bool
+rtl8125_set_phy_mcu_patch_request(struct rtl8125_hw *hw)
+{
+	u16 gphy_val;
+	u16 wait_cnt;
+	bool bool_success = TRUE;
+
+	rtl8125_set_eth_phy_ocp_bit(hw, 0xB820, BIT_4);
+
+	wait_cnt = 0;
+	do {
+		gphy_val = rtl8125_mdio_direct_read_phy_ocp(hw, 0xB800);
+		udelay(100);
+		wait_cnt++;
+	} while (!(gphy_val & BIT_6) && (wait_cnt < 1000));
+
+	if (!(gphy_val & BIT_6) && (wait_cnt == 1000))
+		bool_success = FALSE;
+
+	if (!bool_success)
+		PMD_INIT_LOG(NOTICE, "rtl8125_set_phy_mcu_patch_request fail.");
+
+	return bool_success;
+}
+
+bool
+rtl8125_clear_phy_mcu_patch_request(struct rtl8125_hw *hw)
+{
+	u16 gphy_val;
+	u16 wait_cnt;
+	bool bool_success = TRUE;
+
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xB820, BIT_4);
+
+	wait_cnt = 0;
+	do {
+		gphy_val = rtl8125_mdio_direct_read_phy_ocp(hw, 0xB800);
+		udelay(100);
+		wait_cnt++;
+	} while ((gphy_val & BIT_6) && (wait_cnt < 1000));
+
+	if ((gphy_val & BIT_6) && (wait_cnt == 1000)) bool_success = FALSE;
+
+	if (!bool_success)
+		PMD_INIT_LOG(NOTICE, "rtl8125_clear_phy_mcu_patch_request fail.");
+
+	return bool_success;
+}
+
+void
+rtl8125_disable_ocp_phy_power_saving(struct rtl8125_hw *hw)
+{
+	u16 val;
+
+	if (hw->mcfg == CFG_METHOD_2 || hw->mcfg == CFG_METHOD_3 ||
+	    hw->mcfg == CFG_METHOD_6) {
+		val = rtl8125_mdio_direct_read_phy_ocp(hw, 0xC416);
+		if (val != 0x0050) {
+			rtl8125_set_phy_mcu_patch_request(hw);
+			rtl8125_mdio_direct_write_phy_ocp(hw, 0xC416, 0x0000);
+			rtl8125_mdio_direct_write_phy_ocp(hw, 0xC416, 0x0500);
+			rtl8125_clear_phy_mcu_patch_request(hw);
+		}
+	}
+}
+
+static void
+rtl8125_enable_phy_disable_mode(struct rtl8125_hw *hw)
+{
+	switch (hw->HwSuppCheckPhyDisableModeVer) {
+	case 3:
+		RTL_W8(hw, 0xF2, RTL_R8(hw, 0xF2) | BIT_5);
+		break;
+	}
+}
+
+static void
+rtl8125_disable_phy_disable_mode(struct rtl8125_hw *hw)
+{
+	switch (hw->HwSuppCheckPhyDisableModeVer) {
+	case 3:
+		RTL_W8(hw, 0xF2, RTL_R8(hw, 0xF2) & ~BIT_5);
+		break;
+	}
+
+	mdelay(1);
+}
+
+static u8
+rtl8125_is_phy_disable_mode_enabled(struct rtl8125_hw *hw)
+{
+	u8 phy_disable_mode_enabled = FALSE;
+
+	switch (hw->HwSuppCheckPhyDisableModeVer) {
+	case 3:
+		if (RTL_R8(hw, 0xF2) & BIT_5)
+			phy_disable_mode_enabled = TRUE;
+		break;
+	}
+
+	return phy_disable_mode_enabled;
+}
+
+static u8
+rtl8125_is_gpio_low(struct rtl8125_hw *hw)
+{
+	u8 gpio_low = FALSE;
+
+	switch (hw->HwSuppCheckPhyDisableModeVer) {
+	case 3:
+		if (!(rtl8125_mac_ocp_read(hw, 0xDC04) & BIT_13))
+			gpio_low = TRUE;
+		break;
+	}
+
+	return gpio_low;
+}
+
+static u8
+rtl8125_is_in_phy_disable_mode(struct rtl8125_hw *hw)
+{
+	u8 in_phy_disable_mode = FALSE;
+
+	if (rtl8125_is_phy_disable_mode_enabled(hw) && rtl8125_is_gpio_low(hw))
+		in_phy_disable_mode = TRUE;
+
+	return in_phy_disable_mode;
+}
+
+static void
+rtl8125_init_hw_phy_mcu(struct rtl8125_hw *hw)
+{
+	u8 require_disable_phy_disable_mode = FALSE;
+
+	if (hw->NotWrRamCodeToMicroP == TRUE)
+		return;
+
+	if (rtl8125_check_hw_phy_mcu_code_ver(hw))
+		return;
+
+	if (HW_SUPPORT_CHECK_PHY_DISABLE_MODE(hw) && rtl8125_is_in_phy_disable_mode(hw))
+		require_disable_phy_disable_mode = TRUE;
+
+	if (require_disable_phy_disable_mode)
+		rtl8125_disable_phy_disable_mode(hw);
+
+	hw->hw_ops.hw_phy_mcu_config(hw);
+
+	if (require_disable_phy_disable_mode)
+		rtl8125_enable_phy_disable_mode(hw);
+
+	rtl8125_write_hw_phy_mcu_code_ver(hw);
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+
+	hw->HwHasWrRamCodeToMicroP = TRUE;
+}
+
+static int
+rtl8125_wait_phy_reset_complete(struct rtl8125_hw *hw)
+{
+	int i, val;
+
+	for (i = 0; i < 2500; i++) {
+		val = rtl8125_mdio_read(hw, MII_BMCR) & BMCR_RESET;
+		if (!val)
+			return 0;
+
+		mdelay(1);
+	}
+
+	return -1;
+}
+
+static void
+rtl8125_xmii_reset_enable(struct rtl8125_hw *hw)
+{
+	if (rtl8125_is_in_phy_disable_mode(hw))
+		return;
+
+	rtl8125_mdio_write(hw, 0x1f, 0x0000);
+	rtl8125_mdio_write(hw, MII_ADVERTISE, rtl8125_mdio_read(hw, MII_ADVERTISE) &
+	                   ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+	                     ADVERTISE_100HALF | ADVERTISE_100FULL));
+	rtl8125_mdio_write(hw, MII_CTRL1000, rtl8125_mdio_read(hw, MII_CTRL1000) &
+	                   ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL));
+	rtl8125_mdio_direct_write_phy_ocp(hw, 0xA5D4,
+	                                  rtl8125_mdio_direct_read_phy_ocp(hw, 0xA5D4) & ~(RTK_ADVERTISE_2500FULL));
+	rtl8125_mdio_write(hw, MII_BMCR, BMCR_RESET | BMCR_ANENABLE);
+
+	if (rtl8125_wait_phy_reset_complete(hw) == 0)
+		return;
+}
+
+static void
+rtl8125_phy_restart_nway(struct rtl8125_hw *hw)
+{
+	if (rtl8125_is_in_phy_disable_mode(hw))
+		return;
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+	rtl8125_mdio_write(hw, MII_BMCR, BMCR_ANENABLE | BMCR_ANRESTART);
+}
+
+static void
+rtl8125_phy_setup_force_mode(struct rtl8125_hw *hw, u32 speed, u8 duplex)
+{
+	u16 bmcr_true_force = 0;
+
+	if (rtl8125_is_in_phy_disable_mode(hw)) return;
+
+	if ((speed == SPEED_10) && (duplex == DUPLEX_HALF))
+		bmcr_true_force = BMCR_SPEED10;
+
+	else if ((speed == SPEED_10) && (duplex == DUPLEX_FULL))
+		bmcr_true_force = BMCR_SPEED10 | BMCR_FULLDPLX;
+
+	else if ((speed == SPEED_100) && (duplex == DUPLEX_HALF))
+		bmcr_true_force = BMCR_SPEED100;
+
+	else if ((speed == SPEED_100) && (duplex == DUPLEX_FULL))
+		bmcr_true_force = BMCR_SPEED100 | BMCR_FULLDPLX;
+
+	else
+		return;
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+	rtl8125_mdio_write(hw, MII_BMCR, bmcr_true_force);
+}
+
+static int
+rtl8125_set_speed_xmii(struct rtl8125_hw *hw, u8 autoneg, u32 speed, u8 duplex,
+                       u32 adv)
+{
+	int auto_nego = 0;
+	int giga_ctrl = 0;
+	int ctrl_2500 = 0;
+	int rc = -EINVAL;
+
+	/* Disable giga lite */
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA428, BIT_9);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA5EA, BIT_0);
+
+	if (!rtl8125_is_speed_mode_valid(speed)) {
+		speed = SPEED_2500;
+		duplex = DUPLEX_FULL;
+		adv |= hw->advertising;
+	}
+
+	giga_ctrl = rtl8125_mdio_read(hw, MII_CTRL1000);
+	giga_ctrl &= ~(ADVERTISE_1000HALF | ADVERTISE_1000FULL);
+	ctrl_2500 = rtl8125_mdio_direct_read_phy_ocp(hw, 0xA5D4);
+	ctrl_2500 &= ~RTK_ADVERTISE_2500FULL;
+
+	if (autoneg == AUTONEG_ENABLE) {
+		/* N-way force */
+		auto_nego = rtl8125_mdio_read(hw, MII_ADVERTISE);
+		auto_nego &= ~(ADVERTISE_10HALF | ADVERTISE_10FULL |
+		               ADVERTISE_100HALF | ADVERTISE_100FULL |
+		               ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM);
+
+		if (adv & ADVERTISE_10_HALF)
+			auto_nego |= ADVERTISE_10HALF;
+		if (adv & ADVERTISE_10_FULL)
+			auto_nego |= ADVERTISE_10FULL;
+		if (adv & ADVERTISE_100_HALF)
+			auto_nego |= ADVERTISE_100HALF;
+		if (adv & ADVERTISE_100_FULL)
+			auto_nego |= ADVERTISE_100FULL;
+		if (adv & ADVERTISE_1000_HALF)
+			giga_ctrl |= ADVERTISE_1000HALF;
+		if (adv & ADVERTISE_1000_FULL)
+			giga_ctrl |= ADVERTISE_1000FULL;
+		if (adv & ADVERTISE_2500_FULL)
+			ctrl_2500 |= RTK_ADVERTISE_2500FULL;
+
+		/* Flow control */
+		if (hw->fcpause == rtl8125_fc_full)
+			auto_nego |= ADVERTISE_PAUSE_CAP | ADVERTISE_PAUSE_ASYM;
+
+		hw->phy_auto_nego_reg = auto_nego;
+		hw->phy_1000_ctrl_reg = giga_ctrl;
+
+		hw->phy_2500_ctrl_reg = ctrl_2500;
+
+		rtl8125_mdio_write(hw, 0x1f, 0x0000);
+		rtl8125_mdio_write(hw, MII_ADVERTISE, auto_nego);
+		rtl8125_mdio_write(hw, MII_CTRL1000, giga_ctrl);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xA5D4, ctrl_2500);
+		rtl8125_phy_restart_nway(hw);
+		mdelay(20);
+	} else {
+		/* True force */
+		if (speed == SPEED_10 || speed == SPEED_100)
+			rtl8125_phy_setup_force_mode(hw, speed, duplex);
+		else
+			goto out;
+	}
+	hw->autoneg = autoneg;
+	hw->speed = speed;
+	hw->duplex = duplex;
+	hw->advertising = adv;
+
+	rc = 0;
+out:
+	return rc;
+}
+
+static void
+rtl8125_wait_phy_ups_resume(struct rtl8125_hw *hw, u16 PhyState)
+{
+	u16 tmp_phy_state;
+	int i = 0;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		do {
+			tmp_phy_state = rtl8125_mdio_direct_read_phy_ocp(hw, 0xA420);
+			tmp_phy_state &= 0x7;
+			mdelay(1);
+			i++;
+		} while ((i < 100) && (tmp_phy_state != PhyState));
+	}
+}
+
+static void
+rtl8125_phy_power_up(struct rtl8125_hw *hw)
+{
+	if (rtl8125_is_in_phy_disable_mode(hw))
+		return;
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+	rtl8125_mdio_write(hw, MII_BMCR, BMCR_ANENABLE);
+
+	/* Wait ups resume (phy state 3) */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_wait_phy_ups_resume(hw, 3);
+	}
+}
+
+void
+rtl8125_powerup_pll(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W8(hw, PMCH, RTL_R8(hw, PMCH) | BIT_7 | BIT_6);
+	}
+
+	rtl8125_phy_power_up(hw);
+}
+
+static void
+rtl8125_phy_power_down(struct rtl8125_hw *hw)
+{
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+	rtl8125_mdio_write(hw, MII_BMCR, BMCR_ANENABLE | BMCR_PDOWN);
+}
+
+void
+rtl8125_powerdown_pll(struct rtl8125_hw *hw)
+{
+	if (hw->DASH)
+		return;
+
+	rtl8125_phy_power_down(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W8(hw, PMCH, RTL_R8(hw, PMCH) & ~BIT_7);
+		break;
+	}
+}
+
+int
+rtl8125_set_speed(struct rtl8125_hw *hw)
+{
+	int ret;
+
+	ret = rtl8125_set_speed_xmii(hw, hw->autoneg, hw->speed, hw->duplex,
+	                             hw->advertising);
+
+	return ret;
+}
+
+static void
+rtl8125_disable_aldps(struct rtl8125_hw *hw)
+{
+	u16 tmp_ushort;
+	u32 timeout, wait_cnt;
+
+	tmp_ushort = rtl8125_mdio_real_read_phy_ocp(hw, 0xA430);
+	if (tmp_ushort & BIT_2) {
+		timeout = 0;
+		wait_cnt = 200;
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA430, BIT_2);
+
+		do {
+			udelay(100);
+
+			tmp_ushort = rtl8125_mac_ocp_read(hw, 0xE908);
+
+			timeout++;
+		} while (!(tmp_ushort & BIT_7) && timeout < wait_cnt);
+	}
+}
+
+static bool
+rtl8125_is_adv_eee_enabled(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_9:
+		if (rtl8125_mdio_direct_read_phy_ocp(hw, 0xA430) & BIT_15)
+			return true;
+		break;
+	default:
+		break;
+	}
+
+	return false;
+}
+
+static void
+_rtl8125_disable_adv_eee(struct rtl8125_hw *hw)
+{
+	bool lock;
+
+	if (rtl8125_is_adv_eee_enabled(hw))
+		lock = true;
+	else
+		lock = false;
+
+	if (lock)
+		rtl8125_set_phy_mcu_patch_request(hw);
+
+	rtl8125_clear_mac_ocp_bit(hw, 0xE052, BIT_0);
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA442, (BIT_12 | BIT_13));
+	rtl8125_clear_eth_phy_ocp_bit(hw, 0xA430, BIT_15);
+
+	if (lock)
+		rtl8125_clear_phy_mcu_patch_request(hw);
+}
+
+static void
+rtl8125_disable_adv_eee(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		rtl8125_oob_mutex_lock(hw);
+		break;
+	}
+
+	_rtl8125_disable_adv_eee(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+		rtl8125_oob_mutex_unlock(hw);
+		break;
+	}
+}
+
+static void
+rtl8125_disable_eee(struct rtl8125_hw *hw)
+{
+	switch (hw->mcfg) {
+	case CFG_METHOD_2:
+	case CFG_METHOD_3:
+	case CFG_METHOD_6:
+		rtl8125_clear_mac_ocp_bit(hw, 0xE040, (BIT_1 | BIT_0));
+		rtl8125_clear_mac_ocp_bit(hw, 0xEB62, (BIT_2 | BIT_1));
+
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA432, BIT_4);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA5D0, (BIT_2 | BIT_1));
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA6D4, BIT_0);
+
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA6D8, BIT_4);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA428, BIT_7);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA4A2, BIT_9);
+		break;
+	case CFG_METHOD_4:
+	case CFG_METHOD_5:
+	case CFG_METHOD_7:
+	case CFG_METHOD_8:
+	case CFG_METHOD_9:
+	case CFG_METHOD_10:
+	case CFG_METHOD_11:
+		rtl8125_clear_mac_ocp_bit(hw, 0xE040, (BIT_1 | BIT_0));
+
+		rtl8125_set_eth_phy_ocp_bit(hw, 0xA432, BIT_4);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA5D0, (BIT_2 | BIT_1));
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA6D4, BIT_0);
+
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA6D8, BIT_4);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA428, BIT_7);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA4A2, BIT_9);
+		break;
+	default:
+		/* Not support EEE */
+		break;
+	}
+
+	/* Advanced EEE */
+	rtl8125_disable_adv_eee(hw);
+}
+
+static void
+rtl8125_set_hw_phy_before_init_phy_mcu(struct rtl8125_hw *hw)
+{
+	u16 phy_reg_value;
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_4:
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xBF86, 0x9000);
+
+		rtl8125_set_eth_phy_ocp_bit(hw, 0xC402, BIT_10);
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xC402, BIT_10);
+
+		phy_reg_value = rtl8125_mdio_direct_read_phy_ocp(hw, 0xBF86);
+		phy_reg_value &= (BIT_1 | BIT_0);
+		if (phy_reg_value != 0)
+			PMD_INIT_LOG(NOTICE, "PHY watch dog not clear, value = 0x%x", phy_reg_value);
+
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xBD86, 0x1010);
+		rtl8125_mdio_direct_write_phy_ocp(hw, 0xBD88, 0x1010);
+
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBD4E, (BIT_11 | BIT_10), BIT_11);
+		rtl8125_clear_and_set_eth_phy_ocp_bit(hw, 0xBF46,
+		                                      (BIT_11 | BIT_10 | BIT_9 | BIT_8), (BIT_10 | BIT_9 | BIT_8));
+		break;
+	}
+}
+
+void
+rtl8125_hw_phy_config(struct rtl8125_hw *hw)
+{
+	rtl8125_xmii_reset_enable(hw);
+
+	rtl8125_set_hw_phy_before_init_phy_mcu(hw);
+
+	rtl8125_init_hw_phy_mcu(hw);
+
+	hw->hw_ops.hw_phy_config(hw);
+
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		rtl8125_disable_aldps(hw);
+		break;
+	}
+
+	/* Legacy force mode (chap 22) */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+	default:
+		rtl8125_clear_eth_phy_ocp_bit(hw, 0xA5B4, BIT_15);
+		break;
+	}
+
+	rtl8125_mdio_write(hw, 0x1F, 0x0000);
+
+	if (HW_HAS_WRITE_PHY_MCU_RAM_CODE(hw))
+		rtl8125_disable_eee(hw);
+}
+
+void
+rtl8125_set_phy_mcu_ram_code(struct rtl8125_hw *hw, const u16 *ramcode,
+                             u16 codesize)
+{
+	u16 i;
+	u16 addr;
+	u16 val;
+
+	if (ramcode == NULL || codesize % 2)
+		goto out;
+
+	for (i = 0; i < codesize; i += 2) {
+		addr = ramcode[i];
+		val = ramcode[i + 1];
+		if (addr == 0xFFFF && val == 0xFFFF)
+			break;
+		rtl8125_mdio_direct_write_phy_ocp(hw, addr, val);
+	}
+
+out:
+	return;
+}
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_phy.h
@@ -0,0 +1,141 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#ifndef _R8125_PHY_H_
+#define _R8125_PHY_H_
+
+#include <stdint.h>
+#include <stdbool.h>
+
+#include <rte_ethdev.h>
+#include <rte_ethdev_core.h>
+
+#include "r8125_base.h"
+#include "r8125_ethdev.h"
+
+/* Generic MII registers. */
+#define MII_BMCR		0x00	/* Basic mode control register */
+#define MII_BMSR		0x01	/* Basic mode status register  */
+#define MII_PHYSID1		0x02	/* PHYS ID 1                   */
+#define MII_PHYSID2		0x03	/* PHYS ID 2                   */
+#define MII_ADVERTISE		0x04	/* Advertisement control reg   */
+#define MII_LPA			0x05	/* Link partner ability reg    */
+#define MII_EXPANSION		0x06	/* Expansion register          */
+#define MII_CTRL1000		0x09	/* 1000BASE-T control          */
+#define MII_STAT1000		0x0a	/* 1000BASE-T status           */
+#define	MII_MMD_CTRL		0x0d	/* MMD Access Control Register */
+#define	MII_MMD_DATA		0x0e	/* MMD Access Data Register    */
+#define MII_ESTATUS		0x0f	/* Extended Status             */
+#define MII_DCOUNTER		0x12	/* Disconnect counter          */
+#define MII_FCSCOUNTER		0x13	/* False carrier counter       */
+#define MII_NWAYTEST		0x14	/* N-way auto-neg test reg     */
+#define MII_RERRCOUNTER		0x15	/* Receive error counter       */
+#define MII_SREVISION		0x16	/* Silicon revision            */
+#define MII_RESV1		0x17	/* Reserved...                 */
+#define MII_LBRERROR		0x18	/* Lpback, rx, bypass error    */
+#define MII_PHYADDR		0x19	/* PHY address                 */
+#define MII_RESV2		0x1a	/* Reserved...                 */
+#define MII_TPISTATUS		0x1b	/* TPI status for 10mbps       */
+#define MII_NCONFIG		0x1c	/* Network interface config    */
+
+/* Basic mode control register. */
+#define BMCR_RESV		0x003f	/* Unused...                   */
+#define BMCR_SPEED1000		0x0040	/* MSB of Speed (1000)         */
+#define BMCR_CTST		0x0080	/* Collision test              */
+#define BMCR_FULLDPLX		0x0100	/* Full duplex                 */
+#define BMCR_ANRESTART		0x0200	/* Auto negotiation restart    */
+#define BMCR_ISOLATE		0x0400	/* Isolate data paths from MII */
+#define BMCR_PDOWN		0x0800	/* Enable low power state      */
+#define BMCR_ANENABLE		0x1000	/* Enable auto negotiation     */
+#define BMCR_SPEED100		0x2000	/* Select 100Mbps              */
+#define BMCR_LOOPBACK		0x4000	/* TXD loopback bits           */
+#define BMCR_RESET		0x8000	/* Reset to default state      */
+#define BMCR_SPEED10		0x0000	/* Select 10Mbps               */
+
+/* Basic mode status register. */
+#define BMSR_ERCAP		0x0001	/* Ext-reg capability          */
+#define BMSR_JCD		0x0002	/* Jabber detected             */
+#define BMSR_LSTATUS		0x0004	/* Link status                 */
+#define BMSR_ANEGCAPABLE	0x0008	/* Able to do auto-negotiation */
+#define BMSR_RFAULT		0x0010	/* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE	0x0020	/* Auto-negotiation complete   */
+#define BMSR_RESV		0x00c0	/* Unused...                   */
+#define BMSR_ESTATEN		0x0100	/* Extended Status in R15      */
+#define BMSR_100HALF2		0x0200	/* Can do 100BASE-T2 HDX       */
+#define BMSR_100FULL2		0x0400	/* Can do 100BASE-T2 FDX       */
+#define BMSR_10HALF		0x0800	/* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL		0x1000	/* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF		0x2000	/* Can do 100mbps, half-duplex */
+#define BMSR_100FULL		0x4000	/* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4		0x8000	/* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register. */
+#define ADVERTISE_SLCT		0x001f	/* Selector bits               */
+#define ADVERTISE_CSMA		0x0001	/* Only selector supported     */
+#define ADVERTISE_10HALF	0x0020	/* Try for 10mbps half-duplex  */
+#define ADVERTISE_1000XFULL	0x0020	/* Try for 1000BASE-X full-duplex */
+#define ADVERTISE_10FULL	0x0040	/* Try for 10mbps full-duplex  */
+#define ADVERTISE_1000XHALF	0x0040	/* Try for 1000BASE-X half-duplex */
+#define ADVERTISE_100HALF	0x0080	/* Try for 100mbps half-duplex */
+#define ADVERTISE_1000XPAUSE	0x0080	/* Try for 1000BASE-X pause    */
+#define ADVERTISE_100FULL	0x0100	/* Try for 100mbps full-duplex */
+#define ADVERTISE_1000XPSE_ASYM	0x0100	/* Try for 1000BASE-X asym pause */
+#define ADVERTISE_100BASE4	0x0200	/* Try for 100mbps 4k packets  */
+#define ADVERTISE_PAUSE_CAP	0x0400	/* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM	0x0800	/* Try for asymetric pause     */
+#define ADVERTISE_RESV		0x1000	/* Unused...                   */
+#define ADVERTISE_RFAULT	0x2000	/* Say we can detect faults    */
+#define ADVERTISE_LPACK		0x4000	/* Ack link partners response  */
+#define ADVERTISE_NPAGE		0x8000	/* Next page bit               */
+
+/* 1000BASE-T Control register */
+#define ADVERTISE_1000FULL	0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF	0x0100  /* Advertise 1000BASE-T half duplex */
+
+#define RTK_ADVERTISE_2500FULL		0x80
+#define RTK_LPA_ADVERTISE_2500FULL	0x20
+
+#define ADVERTISE_FULL		(ADVERTISE_100FULL | ADVERTISE_10FULL | \
+				  ADVERTISE_CSMA)
+#define ADVERTISE_ALL		(ADVERTISE_10HALF | ADVERTISE_10FULL | \
+				  ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+void rtl8125_clear_and_set_eth_phy_ocp_bit(struct rtl8125_hw *hw, u16 addr,
+                u16 clearmask, u16 setmask);
+void rtl8125_clear_eth_phy_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask);
+void rtl8125_set_eth_phy_ocp_bit(struct rtl8125_hw *hw,  u16 addr, u16 mask);
+
+void rtl8125_ephy_write(struct rtl8125_hw *hw, int addr, int value);
+
+void rtl8125_clear_and_set_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr,
+                                        u16 clearmask, u16 setmask);
+void rtl8125_clear_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr, u16 mask);
+void rtl8125_set_pcie_phy_bit(struct rtl8125_hw *hw, u8 addr, u16 mask);
+
+bool rtl8125_set_phy_mcu_patch_request(struct rtl8125_hw *hw);
+bool rtl8125_clear_phy_mcu_patch_request(struct rtl8125_hw *hw);
+
+void rtl8125_disable_ocp_phy_power_saving(struct rtl8125_hw *hw);
+
+void rtl8125_hw_phy_config(struct rtl8125_hw *hw);
+
+void rtl8125_powerup_pll(struct rtl8125_hw *hw);
+void rtl8125_powerdown_pll(struct rtl8125_hw *hw);
+int rtl8125_set_speed(struct rtl8125_hw *hw);
+
+u32 rtl8125_mdio_direct_read_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr);
+u32 rtl8125_mdio_read(struct rtl8125_hw *hw, u32 RegAddr);
+
+void rtl8125_mdio_direct_write_phy_ocp(struct rtl8125_hw *hw, u32 RegAddr,
+                                       u32 value);
+void rtl8125_mdio_write(struct rtl8125_hw *hw, u32 RegAddr, u32 value);
+
+void rtl8125_set_phy_mcu_ram_code(struct rtl8125_hw *hw, const u16 *ramcode,
+                                  u16 codesize);
+
+void rtl8125_clear_mac_ocp_bit(struct rtl8125_hw *hw, u16 addr,
+                               u16 mask);
+void rtl8125_set_mac_ocp_bit(struct rtl8125_hw *hw, u16 addr, u16 mask);
+
+#endif
\ No newline at end of file
--- /dev/null
+++ b/drivers/net/r8125/r8125_rxtx.c
@@ -0,0 +1,1493 @@
+/* SPDX-License-Identifier: BSD-3-Clause
+ * Copyright(c) 2024 Realtek Corporation. All rights reserved
+ */
+
+#include <sys/queue.h>
+#include <stdio.h>
+#include <errno.h>
+#include <stdint.h>
+#include <stdarg.h>
+
+#include <rte_eal.h>
+
+#include <rte_string_fns.h>
+#include <rte_common.h>
+#include <rte_interrupts.h>
+#include <rte_byteorder.h>
+#include <rte_log.h>
+#include <rte_debug.h>
+#include <rte_pci.h>
+#include <bus_pci_driver.h>
+#include <rte_ether.h>
+#include <ethdev_driver.h>
+#include <ethdev_pci.h>
+#include <rte_memory.h>
+#include <rte_malloc.h>
+#include <dev_driver.h>
+
+#include "r8125_ethdev.h"
+#include "r8125_hw.h"
+#include "r8125_logs.h"
+
+/* Bit mask to indicate what bits required for building TX context */
+#define RTL_TX_OFFLOAD_MASK (			 \
+		RTE_MBUF_F_TX_IPV6 |		 \
+		RTE_MBUF_F_TX_IPV4 |		 \
+		RTE_MBUF_F_TX_VLAN |		 \
+		RTE_MBUF_F_TX_IP_CKSUM |	 \
+		RTE_MBUF_F_TX_L4_MASK |		 \
+		RTE_MBUF_F_TX_TCP_SEG)
+
+#define MIN_PATCH_LENGTH 47
+#define ETH_ZLEN	 60		/* Min. octets in frame sans FCS */
+
+/* Struct TxDesc in kernel r8125 */
+struct rtl8125_tx_desc {
+	u32 opts1;
+	u32 opts2;
+	u64 addr;
+	u32 reserved0;
+	u32 reserved1;
+	u32 reserved2;
+	u32 reserved3;
+};
+
+/* Struct RxDesc in kernel r8125 */
+struct rtl8125_rx_desc {
+	u32 opts1;
+	u32 opts2;
+	u64 addr;
+};
+
+/* Structure associated with each descriptor of the TX ring of a TX queue. */
+struct rtl8125_tx_entry {
+	struct rte_mbuf *mbuf;
+};
+
+/* Structure associated with each descriptor of the RX ring of a RX queue. */
+struct rtl8125_rx_entry {
+	struct rte_mbuf *mbuf;
+};
+
+/* Structure associated with each TX queue. */
+struct rtl8125_tx_queue {
+	struct rtl8125_tx_desc	*hw_ring;
+	struct rtl8125_tx_entry         *sw_ring;
+	struct rtl8125_hw		*hw;
+	uint64_t		hw_ring_phys_addr;
+	uint16_t		nb_tx_desc;
+	uint32_t		tx_tail;
+	uint16_t		tx_head;
+	uint16_t		queue_id;
+	uint16_t		port_id;
+	uint16_t		tx_free_thresh;
+	uint16_t		tx_free;
+};
+
+/* Structure associated with each RX queue. */
+struct rtl8125_rx_queue {
+	struct rte_mempool	*mb_pool;
+	struct rtl8125_rx_desc	*hw_ring;
+	struct rtl8125_rx_entry         *sw_ring;
+	struct rte_mbuf         *pkt_first_seg; /* First segment of current packet. */
+	struct rte_mbuf         *pkt_last_seg;  /* Last segment of current packet. */
+	struct rtl8125_hw       *hw;
+	uint64_t		hw_ring_phys_addr;
+	uint64_t		offloads;
+	uint16_t		nb_rx_desc;
+	uint16_t		rx_tail;
+	uint16_t		nb_rx_hold;
+	uint16_t		queue_id;
+	uint16_t		port_id;
+	uint16_t		rx_free_thresh;
+};
+
+enum _DescStatusBit {
+	DescOwn     = (1 << 31), /* Descriptor is owned by NIC. */
+	RingEnd     = (1 << 30), /* End of descriptor ring */
+	FirstFrag   = (1 << 29), /* First segment of a packet */
+	LastFrag    = (1 << 28), /* Final segment of a packet */
+
+	DescOwn_V3  = DescOwn, /* Descriptor is owned by NIC. */
+	RingEnd_V3  = RingEnd, /* End of descriptor ring */
+	FirstFrag_V3 = (1 << 25), /* First segment of a packet */
+	LastFrag_V3 = (1 << 24), /* Final segment of a packet */
+
+	/* TX private */
+	/*------ offset 0 of TX descriptor ------*/
+	LargeSend   = (1 << 27), /* TCP Large Send Offload (TSO) */
+	GiantSendv4 = (1 << 26), /* TCP Giant Send Offload V4 (GSOv4) */
+	GiantSendv6 = (1 << 25), /* TCP Giant Send Offload V6 (GSOv6) */
+	LargeSend_DP = (1 << 16), /* TCP Large Send Offload (TSO) */
+	MSSShift    = 16,        /* MSS value position */
+	MSSMask     = 0x7FFU,    /* MSS value 11 bits */
+	TxIPCS      = (1 << 18), /* Calculate IP checksum */
+	TxUDPCS     = (1 << 17), /* Calculate UDP/IP checksum */
+	TxTCPCS     = (1 << 16), /* Calculate TCP/IP checksum */
+	TxVlanTag   = (1 << 17), /* Add VLAN tag */
+
+	/*@@@@@@ offset 4 of TX descriptor => bits for RTL8125 only     begin @@@@@@*/
+	TxUDPCS_C   = (1 << 31), /* Calculate UDP/IP checksum */
+	TxTCPCS_C   = (1 << 30), /* Calculate TCP/IP checksum */
+	TxIPCS_C    = (1 << 29), /* Calculate IP checksum */
+	TxIPV6F_C   = (1 << 28), /* Indicate it is an IPv6 packet */
+	/*@@@@@@ offset 4 of tx descriptor => bits for RTL8125 only     end @@@@@@*/
+
+	/* RX private */
+	/* ------ offset 0 of RX descriptor ------ */
+	PID1        = (1 << 18), /* Protocol ID bit 1/2 */
+	PID0        = (1 << 17), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP  PID1
+#define RxProtoTCP  PID0
+#define RxProtoIP   (PID1 | PID0)
+#define RxProtoMask RxProtoIP
+
+	RxIPF       = (1 << 16), /* IP checksum failed */
+	RxUDPF      = (1 << 15), /* UDP/IP checksum failed */
+	RxTCPF      = (1 << 14), /* TCP/IP checksum failed */
+	RxVlanTag   = (1 << 16), /* VLAN tag available */
+
+	/*@@@@@@ offset 0 of RX descriptor => bits for RTL8125 only     begin @@@@@@*/
+	RxUDPT      = (1 << 18),
+	RxTCPT      = (1 << 17),
+	/*@@@@@@ offset 0 of RX descriptor => bits for RTL8125 only     end @@@@@@*/
+
+	/*@@@@@@ offset 4 of RX descriptor => bits for RTL8125 only     begin @@@@@@*/
+	RxV6F       = (1 << 31),
+	RxV4F       = (1 << 30),
+	/*@@@@@@ offset 4 of RX descriptor => bits for RTL8125 only     end @@@@@@*/
+
+	PID1_v3        = (1 << 29), /* Protocol ID bit 1/2 */
+	PID0_v3        = (1 << 28), /* Protocol ID bit 2/2 */
+
+#define RxProtoUDP_v3  PID1_v3
+#define RxProtoTCP_v3  PID0_v3
+#define RxProtoIP_v3   (PID1_v3 | PID0_v3)
+#define RxProtoMask_v3 RxProtoIP_v3
+
+	RxIPF_v3       = (1 << 26), /* IP checksum failed */
+	RxUDPF_v3      = (1 << 25), /* UDP/IP checksum failed */
+	RxTCPF_v3      = (1 << 24), /* TCP/IP checksum failed */
+	RxSCTPF_v3     = (1 << 23), /* TCP/IP checksum failed */
+	RxVlanTag_v3   = (RxVlanTag), /* VLAN tag available */
+
+	/*@@@@@@ offset 0 of RX descriptor => bits for RTL8125 only     begin @@@@@@*/
+	RxUDPT_v3      = (1 << 29),
+	RxTCPT_v3      = (1 << 28),
+	RxSCTP_v3      = (1 << 27),
+	/*@@@@@@ offset 0 of RX descriptor => bits for RTL8125 only     end @@@@@@*/
+
+	/*@@@@@@ offset 4 of RX descriptor => bits for RTL8125 only     begin @@@@@@*/
+	RxV6F_v3       = RxV6F,
+	RxV4F_v3       = RxV4F,
+	/*@@@@@@ offset 4 of RX descriptor => bits for RTL8125 only     end @@@@@@*/
+};
+
+#define GTTCPHO_SHIFT  18
+#define GTTCPHO_MAX    0x70U
+#define GTPKTSIZE_MAX  0x3ffffU
+#define TCPHO_SHIFT    18
+#define TCPHO_MAX      0x3ffU
+#define LSOPKTSIZE_MAX 0xffffU
+#define MSS_MAX        0x07ffu /* MSS value */
+
+/* ---------------------------------RX---------------------------------- */
+
+static void
+rtl8125_rx_queue_release_mbufs(struct rtl8125_rx_queue *rxq)
+{
+	int i;
+
+	PMD_INIT_FUNC_TRACE();
+	if (rxq != NULL) {
+		if (rxq->sw_ring != NULL) {
+			for (i = 0; i < rxq->nb_rx_desc; i++) {
+				if (rxq->sw_ring[i].mbuf != NULL) {
+					rte_pktmbuf_free_seg(rxq->sw_ring[i].mbuf);
+					rxq->sw_ring[i].mbuf = NULL;
+				}
+			}
+		}
+	}
+}
+
+void
+rtl8125_rx_queue_release(struct rte_eth_dev *dev, uint16_t rx_queue_id)
+{
+	struct rtl8125_rx_queue *rxq = dev->data->rx_queues[rx_queue_id];
+	PMD_INIT_FUNC_TRACE();
+
+	if (rxq != NULL) {
+		rtl8125_rx_queue_release_mbufs(rxq);
+		rte_free(rxq->sw_ring);
+		rte_free(rxq);
+	}
+}
+
+void
+rtl8125_rxq_info_get(struct rte_eth_dev *dev, uint16_t queue_id,
+                     struct rte_eth_rxq_info *qinfo)
+{
+	struct rtl8125_rx_queue *rxq;
+
+	rxq = dev->data->rx_queues[queue_id];
+
+	qinfo->mp = rxq->mb_pool;
+	qinfo->scattered_rx = dev->data->scattered_rx;
+	qinfo->nb_desc = rxq->nb_rx_desc;
+
+	qinfo->conf.rx_free_thresh = rxq->rx_free_thresh;
+	qinfo->conf.offloads = rxq->offloads;
+}
+
+static void
+rtl8125_reset_rx_queue(struct rtl8125_rx_queue *rxq)
+{
+	static const struct rtl8125_rx_desc zero_rxd = {0};
+	int i;
+
+	for (i = 0; i < rxq->nb_rx_desc; i++)
+		rxq->hw_ring[i] = zero_rxd;
+
+	rxq->hw_ring[rxq->nb_rx_desc - 1].opts1 = rte_cpu_to_le_32(RingEnd);
+	rxq->rx_tail = 0;
+	rxq->pkt_first_seg = NULL;
+	rxq->pkt_last_seg = NULL;
+}
+
+uint64_t
+rtl8125_get_rx_port_offloads(void)
+{
+	uint64_t offloads;
+
+	offloads = RTE_ETH_RX_OFFLOAD_IPV4_CKSUM  |
+	           RTE_ETH_RX_OFFLOAD_UDP_CKSUM   |
+	           RTE_ETH_RX_OFFLOAD_TCP_CKSUM   |
+	           RTE_ETH_RX_OFFLOAD_SCATTER     |
+	           RTE_ETH_RX_OFFLOAD_VLAN_STRIP;
+
+	return offloads;
+}
+
+int
+rtl8125_rx_queue_setup(struct rte_eth_dev *dev, uint16_t queue_idx,
+                       uint16_t nb_rx_desc, unsigned int socket_id,
+                       const struct rte_eth_rxconf *rx_conf,
+                       struct rte_mempool *mb_pool)
+{
+	struct rtl8125_rx_queue *rxq;
+	const struct rte_memzone *mz;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	uint32_t size;
+
+	PMD_INIT_FUNC_TRACE();
+	if (nb_rx_desc > R8125_MAX_RX_DESC || nb_rx_desc < R8125_MIN_RX_DESC) {
+		PMD_INIT_LOG(ERR, "Number of Rx descriptors must be "
+		             "less than or equal to %d, "
+		             "greater than or equal to %d",
+		             R8125_MAX_RX_DESC, R8125_MIN_RX_DESC);
+		return -EINVAL;
+	}
+
+	/*
+	 * If this queue existed already, free the associated memory. The
+	 * queue cannot be reused in case we need to allocate memory on
+	 * different socket than was previously used.
+	 */
+	if (dev->data->rx_queues[queue_idx] != NULL) {
+		rtl8125_rx_queue_release(dev, queue_idx);
+		dev->data->rx_queues[queue_idx] = NULL;
+	}
+
+	/* First allocate the rx queue data structure */
+	rxq = rte_zmalloc_socket("r8125 RX queue", sizeof(struct rtl8125_rx_queue),
+	                         RTE_CACHE_LINE_SIZE, socket_id);
+
+	if (rxq == NULL) {
+		PMD_INIT_LOG(ERR, "Cannot allocate Rx queue structure");
+		return -ENOMEM;
+	}
+
+	/* Setup queue */
+	rxq->mb_pool = mb_pool;
+	rxq->nb_rx_desc = nb_rx_desc;
+	rxq->port_id = dev->data->port_id;
+	rxq->queue_id = queue_idx;
+	rxq->rx_free_thresh = rx_conf->rx_free_thresh;
+
+	/* Allocate memory for the software ring */
+	rxq->sw_ring = rte_zmalloc_socket("r8125 sw rx ring",
+	                                  nb_rx_desc * sizeof(struct rtl8125_rx_entry),
+	                                  RTE_CACHE_LINE_SIZE, socket_id);
+
+	if (rxq->sw_ring == NULL) {
+		PMD_INIT_LOG(ERR,
+		             "Port %d: Cannot allocate software ring for queue %d",
+		             rxq->port_id, rxq->queue_id);
+		rte_free(rxq);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Allocate RX ring hardware descriptors. A memzone large enough to
+	 * handle the maximum ring size is allocated in order to allow for
+	 * resizing in later calls to the queue setup function.
+	 */
+	size = sizeof(struct rtl8125_rx_desc) * (nb_rx_desc + 1);
+	mz = rte_eth_dma_zone_reserve(dev, "rx_ring", queue_idx, size,
+	                              R8125_RING_ALIGN, socket_id);
+	if (mz == NULL) {
+		PMD_INIT_LOG(ERR,
+		             "Port %d: Cannot allocate software ring for queue %d",
+		             rxq->port_id, rxq->queue_id);
+		rtl8125_rx_queue_release(dev, rxq->queue_id);
+		return -ENOMEM;
+	}
+
+	rxq->hw = hw;
+	rxq->hw_ring = mz->addr;
+	rxq->hw_ring_phys_addr = mz->iova;
+	rxq->offloads = rx_conf->offloads | dev->data->dev_conf.rxmode.offloads;
+
+	rtl8125_reset_rx_queue(rxq);
+
+	dev->data->rx_queues[queue_idx] = rxq;
+
+	return 0;
+}
+
+static int
+rtl8125_alloc_rx_queue_mbufs(struct rtl8125_rx_queue *rxq)
+{
+	struct rtl8125_rx_entry *rxe = rxq->sw_ring;
+	struct rtl8125_hw *hw = rxq->hw;
+	struct rtl8125_rx_desc *rxd;
+	int i;
+	uint64_t dma_addr;
+
+	rxd = &rxq->hw_ring[0];
+
+	/* Initialize software ring entries */
+	for (i = 0; i < rxq->nb_rx_desc; i++) {
+		struct rte_mbuf *mbuf = rte_mbuf_raw_alloc(rxq->mb_pool);
+
+		if (mbuf == NULL) {
+			PMD_INIT_LOG(ERR, "RX mbuf alloc failed "
+			             "queue_id=%hu", rxq->queue_id);
+			return -ENOMEM;
+		}
+
+		dma_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(mbuf));
+
+		rxd = &rxq->hw_ring[i];
+		rxd->addr = dma_addr;
+		rxd->opts2 = 0;
+		rte_wmb();
+		rxd->opts1 = rte_cpu_to_le_32(DescOwn | hw->rx_buf_sz);
+		rxe[i].mbuf = mbuf;
+	}
+
+	/* Mark as last desc */
+	rxd->opts1 |= rte_cpu_to_le_32(RingEnd);
+
+	return 0;
+}
+
+static int
+rtl8125_hw_set_features(struct rtl8125_hw *hw, uint64_t offloads)
+{
+	u16 cp_cmd;
+	u32 rx_config;
+
+	rx_config = RTL_R32(hw, RxConfig);
+	if (offloads & RTE_ETH_RX_OFFLOAD_VLAN_STRIP)
+		rx_config |= (EnableInnerVlan | EnableOuterVlan);
+	else
+		rx_config &= ~(EnableInnerVlan | EnableOuterVlan);
+
+	RTL_W32(hw, RxConfig, rx_config);
+
+	cp_cmd = RTL_R16(hw, CPlusCmd);
+
+	if (offloads & RTE_ETH_RX_OFFLOAD_CHECKSUM)
+		cp_cmd |= RxChkSum;
+	else
+		cp_cmd &= ~RxChkSum;
+
+	RTL_W16(hw, CPlusCmd, cp_cmd);
+
+	return 0;
+}
+
+static void
+rtl8125_hw_set_rx_packet_filter(struct rtl8125_hw *hw)
+{
+	int rx_mode;
+
+	hw->hw_ops.hw_init_rxcfg(hw);
+
+	rx_mode = AcceptBroadcast | AcceptMyPhys;
+	RTL_W32(hw, RxConfig, rx_mode | (RTL_R32(hw, RxConfig)));
+}
+
+int
+rtl8125_rx_init(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rtl8125_rx_queue *rxq;
+	int ret;
+	u32 max_rx_pkt_size;
+
+	rxq = dev->data->rx_queues[0];
+
+	if (rxq->mb_pool == NULL) {
+		PMD_INIT_LOG(ERR, "r8125 rx queue pool not setup!");
+		return -ENOMEM;
+	}
+
+	RTL_W32(hw, RxDescAddrLow, ((u64) rxq->hw_ring_phys_addr & DMA_BIT_MASK(32)));
+	RTL_W32(hw, RxDescAddrHigh, ((u64) rxq->hw_ring_phys_addr >> 32));
+
+	dev->rx_pkt_burst = rtl8125_recv_pkts;
+	hw->rx_buf_sz = rte_pktmbuf_data_room_size(rxq->mb_pool) - RTE_PKTMBUF_HEADROOM;
+
+	max_rx_pkt_size = dev->data->mtu + R8125_ETH_OVERHEAD;
+
+	if (dev->data->dev_conf.rxmode.offloads & RTE_ETH_RX_OFFLOAD_SCATTER ||
+	    max_rx_pkt_size > hw->rx_buf_sz) {
+		if (!dev->data->scattered_rx)
+			PMD_INIT_LOG(DEBUG, "forcing scatter mode");
+		dev->rx_pkt_burst = rtl8125_recv_scattered_pkts;
+		dev->data->scattered_rx = 1;
+	}
+
+	RTL_W16(hw, RxMaxSize, max_rx_pkt_size);
+
+	ret = rtl8125_alloc_rx_queue_mbufs(rxq);
+	if (ret) {
+		PMD_INIT_LOG(ERR, "r8125 rx mbuf alloc failed!");
+		return ret;
+	}
+
+	rtl8125_enable_cfg9346_write(hw);
+
+	/* RX accept type and csum vlan offload */
+	rtl8125_hw_set_features(hw, rxq->offloads);
+
+	rtl8125_disable_rxdvgate(hw);
+
+	/* Set Rx packet filter */
+	rtl8125_hw_set_rx_packet_filter(hw);
+
+	rtl8125_disable_cfg9346_write(hw);
+
+	RTL_W8(hw, ChipCmd, RTL_R8(hw, ChipCmd) | CmdRxEnb);
+
+	dev->data->rx_queue_state[0] = RTE_ETH_QUEUE_STATE_STARTED;
+
+	return 0;
+}
+
+static inline void
+rtl8125_mark_to_asic(struct rtl8125_rx_desc *rxd, u32 size)
+{
+	u32 eor = rte_le_to_cpu_32(rxd->opts1) & RingEnd;
+	rxd->opts1 = rte_cpu_to_le_32(DescOwn | eor | size);
+}
+
+static inline uint64_t
+rtl8125_rx_desc_error_to_pkt_flags(struct rtl8125_rx_queue *rxq,
+                                   uint32_t opts1,
+                                   uint32_t opts2)
+{
+	uint64_t pkt_flags = 0;
+
+	if (!(rxq->offloads & RTE_ETH_RX_OFFLOAD_CHECKSUM))
+		goto exit;
+
+	/* RX csum offload for RTL8125*/
+	if (((opts2 & RxV4F) && !(opts1 & RxIPF)) || (opts2 & RxV6F)) {
+		pkt_flags |= RTE_MBUF_F_RX_IP_CKSUM_GOOD;
+		if (((opts1 & RxTCPT) && !(opts1 & RxTCPF)) ||
+		    ((opts1 & RxUDPT) && !(opts1 & RxUDPF)))
+			pkt_flags |= RTE_MBUF_F_RX_L4_CKSUM_GOOD;
+	}
+
+exit:
+	return pkt_flags;
+}
+
+/* PMD receive function */
+uint16_t
+rtl8125_recv_pkts(void *rx_queue, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
+{
+	struct rtl8125_rx_queue *rxq = (struct rtl8125_rx_queue *)rx_queue;
+	struct rte_eth_dev *dev = &rte_eth_devices[rxq->port_id];
+	struct rtl8125_hw *hw = rxq->hw;
+	struct rtl8125_rx_desc *rxd;
+	struct rtl8125_rx_desc *hw_ring;
+	struct rtl8125_rx_entry *rxe;
+	struct rtl8125_rx_entry *sw_ring = rxq->sw_ring;
+	struct rte_mbuf *new_mb;
+	struct rte_mbuf *rmb;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_sw_stats *stats = &adapter->sw_stats;
+	uint16_t nb_rx = 0;
+	uint16_t nb_hold = 0;
+	uint16_t tail = rxq->rx_tail;
+	const uint16_t nb_rx_desc = rxq->nb_rx_desc;
+	uint32_t opts1;
+	uint32_t opts2;
+	uint16_t pkt_len = 0;
+	uint64_t dma_addr;
+
+	hw_ring = rxq->hw_ring;
+
+	RTE_ASSERT(RTL_R8(hw, ChipCmd) & CmdRxEnb);
+
+	while (nb_rx < nb_pkts) {
+
+		rxd = &hw_ring[tail];
+
+		opts1 = rte_le_to_cpu_32(rxd->opts1);
+		if (opts1 & DescOwn)
+			break;
+
+		/*
+		 * This barrier is needed to keep us from reading
+		 * any other fields out of the Rx descriptor until
+		 * we know the status of DescOwn.
+		 */
+		rte_rmb();
+
+		if (unlikely(opts1 & RxRES)) {
+			stats->rx_errors++;
+			rtl8125_mark_to_asic(rxd, hw->rx_buf_sz);
+			nb_hold++;
+			tail = (tail + 1) % nb_rx_desc;
+		} else {
+			opts2 = rte_le_to_cpu_32(rxd->opts2);
+
+			new_mb = rte_mbuf_raw_alloc(rxq->mb_pool);
+			if (new_mb == NULL) {
+				PMD_RX_LOG(DEBUG, "RX mbuf alloc failed port_id=%u "
+				           "queue_id=%u",
+				           (uint32_t)rxq->port_id, (uint32_t)rxq->queue_id);
+				dev->data->rx_mbuf_alloc_failed++;
+				break;
+			}
+
+			nb_hold++;
+			rxe = &sw_ring[tail];
+
+			rmb = rxe->mbuf;
+
+			tail = (tail + 1) % nb_rx_desc;
+
+			/* Prefetch next mbufs */
+			rte_prefetch0(sw_ring[tail].mbuf);
+
+			/*
+			 * When next RX descriptor is on a cache-line boundary,
+			 * prefetch the next 4 RX descriptors and the next 8 pointers
+			 * to mbufs.
+			 */
+			if ((tail & 0x3) == 0) {
+				rte_prefetch0(&sw_ring[tail]);
+				rte_prefetch0(&hw_ring[tail]);
+			}
+
+			/* Refill the RX desc */
+			rxe->mbuf = new_mb;
+			dma_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(new_mb));
+
+			/* Setup RX descriptor */
+			rxd->addr = dma_addr;
+			rxd->opts2 = 0;
+			rte_wmb();
+			rtl8125_mark_to_asic(rxd, hw->rx_buf_sz);
+
+			pkt_len = opts1 & 0x00003fff;
+			pkt_len -= RTE_ETHER_CRC_LEN;
+
+			rmb->data_off = RTE_PKTMBUF_HEADROOM;
+			rte_prefetch1((char *)rmb->buf_addr + rmb->data_off);
+			rmb->nb_segs = 1;
+			rmb->next = NULL;
+			rmb->pkt_len = pkt_len;
+			rmb->data_len = pkt_len;
+			rmb->port = rxq->port_id;
+
+			if (opts2 & RxVlanTag)
+				rmb->vlan_tci = rte_bswap16(opts2 & 0xffff);
+
+			rmb->ol_flags = rtl8125_rx_desc_error_to_pkt_flags(rxq, opts1, opts2);
+
+			/*
+			 * Store the mbuf address into the next entry of the array
+			 * of returned packets.
+			 */
+			rx_pkts[nb_rx++] = rmb;
+
+			stats->rx_bytes += pkt_len;
+			stats->rx_packets++;
+		}
+	}
+
+	rxq->rx_tail = tail;
+
+	nb_hold = (uint16_t)(nb_hold + rxq->nb_rx_hold);
+	if (nb_hold > rxq->rx_free_thresh) {
+		rte_wmb();
+
+		/* Clear RDU */
+		RTL_W32(hw, ISR0_8125, (RxOK | RxErr | RxDescUnavail));
+
+		nb_hold = 0;
+	}
+
+	rxq->nb_rx_hold = nb_hold;
+
+	return nb_rx;
+}
+
+/* PMD receive function for scattered pkts */
+uint16_t
+rtl8125_recv_scattered_pkts(void *rx_queue, struct rte_mbuf **rx_pkts,
+                            uint16_t nb_pkts)
+{
+	struct rtl8125_rx_queue *rxq = (struct rtl8125_rx_queue *)rx_queue;
+	struct rte_eth_dev *dev = &rte_eth_devices[rxq->port_id];
+	struct rtl8125_hw *hw = rxq->hw;
+	struct rtl8125_rx_desc *rxd;
+	struct rtl8125_rx_desc *hw_ring;
+	struct rtl8125_rx_entry *rxe;
+	struct rtl8125_rx_entry *sw_ring = rxq->sw_ring;
+	struct rte_mbuf *first_seg;
+	struct rte_mbuf *last_seg;
+	struct rte_mbuf *new_mb;
+	struct rte_mbuf *rmb;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_sw_stats *stats = &adapter->sw_stats;
+	uint16_t nb_rx = 0;
+	uint16_t nb_hold = 0;
+	uint16_t data_len = 0;
+	uint16_t tail = rxq->rx_tail;
+	const uint16_t nb_rx_desc = rxq->nb_rx_desc;
+	uint32_t opts1;
+	uint32_t opts2;
+	uint64_t dma_addr;
+
+	hw_ring = rxq->hw_ring;
+
+	/*
+	 * Retrieve RX context of current packet, if any.
+	 */
+	first_seg = rxq->pkt_first_seg;
+	last_seg = rxq->pkt_last_seg;
+
+	RTE_ASSERT(RTL_R8(hw, ChipCmd) & CmdRxEnb);
+
+	while (nb_rx < nb_pkts) {
+next_desc:
+		rxd = &hw_ring[tail];
+
+		opts1 = rte_le_to_cpu_32(rxd->opts1);
+		if (opts1 & DescOwn)
+			break;
+
+		/*
+		 * This barrier is needed to keep us from reading
+		 * any other fields out of the Rx descriptor until
+		 * we know the status of DescOwn
+		 */
+		rte_rmb();
+
+		if (unlikely(opts1 & RxRES)) {
+			stats->rx_errors++;
+			rtl8125_mark_to_asic(rxd, hw->rx_buf_sz);
+			nb_hold++;
+			tail = (tail + 1) % nb_rx_desc;
+		} else {
+
+			opts2 = rte_le_to_cpu_32(rxd->opts2);
+
+			new_mb = rte_mbuf_raw_alloc(rxq->mb_pool);
+			if (new_mb == NULL) {
+				PMD_RX_LOG(DEBUG, "RX mbuf alloc failed port_id=%u "
+				           "queue_id=%u",
+				           (uint32_t)rxq->port_id, (uint32_t)rxq->queue_id);
+				dev->data->rx_mbuf_alloc_failed++;
+				break;
+			}
+
+			nb_hold++;
+			rxe = &sw_ring[tail];
+
+			rmb = rxe->mbuf;
+
+			/* Prefetch next mbufs */
+			tail = (tail + 1) % nb_rx_desc;
+			rte_prefetch0(sw_ring[tail].mbuf);
+
+			/*
+			 * When next RX descriptor is on a cache-line boundary,
+			 * prefetch the next 4 RX descriptors and the next 8 pointers
+			 * to mbufs.
+			 */
+			if ((tail & 0x3) == 0) {
+				rte_prefetch0(&sw_ring[tail]);
+				rte_prefetch0(&hw_ring[tail]);
+			}
+
+			/* Refill the RX desc */
+			rxe->mbuf = new_mb;
+			dma_addr = rte_cpu_to_le_64(rte_mbuf_data_iova_default(new_mb));
+
+			/* Setup RX descriptor */
+			rxd->addr = dma_addr;
+			rxd->opts2 = 0;
+			rte_wmb();
+			rtl8125_mark_to_asic(rxd, hw->rx_buf_sz);
+
+			data_len = opts1 & 0x00003fff;
+			rmb->data_len = data_len;
+			rmb->data_off = RTE_PKTMBUF_HEADROOM;
+
+			/*
+			 * If this is the first buffer of the received packet,
+			 * set the pointer to the first mbuf of the packet and
+			 * initialize its context.
+			 * Otherwise, update the total length and the number of segments
+			 * of the current scattered packet, and update the pointer to
+			 * the last mbuf of the current packet.
+			 */
+			if (first_seg == NULL) {
+				first_seg = rmb;
+				first_seg->pkt_len = data_len;
+				first_seg->nb_segs = 1;
+			} else {
+				first_seg->pkt_len += data_len;
+				first_seg->nb_segs++;
+				last_seg->next = rmb;
+			}
+
+			/*
+			 * If this is not the last buffer of the received packet,
+			 * update the pointer to the last mbuf of the current scattered
+			 * packet and continue to parse the RX ring.
+			 */
+			if (!(opts1 & LastFrag)) {
+				last_seg = rmb;
+				goto next_desc;
+			}
+
+			/*
+			 * This is the last buffer of the received packet.
+			 */
+			rmb->next = NULL;
+
+			first_seg->pkt_len -= RTE_ETHER_CRC_LEN;
+			if (data_len <= RTE_ETHER_CRC_LEN) {
+				rte_pktmbuf_free_seg(rmb);
+				first_seg->nb_segs--;
+				last_seg->data_len = last_seg->data_len - (RTE_ETHER_CRC_LEN - data_len);
+				last_seg->next = NULL;
+			} else
+				rmb->data_len = data_len - RTE_ETHER_CRC_LEN;
+
+			first_seg->port = rxq->port_id;
+
+			if (opts2 & RxVlanTag)
+				first_seg->vlan_tci = rte_bswap16(opts2 & 0xffff);
+
+			first_seg->ol_flags = rtl8125_rx_desc_error_to_pkt_flags(rxq, opts1, opts2);
+
+			rte_prefetch1((char *)first_seg->buf_addr + first_seg->data_off);
+
+			/*
+			 * Store the mbuf address into the next entry of the array
+			 * of returned packets.
+			 */
+			rx_pkts[nb_rx++] = first_seg;
+
+			stats->rx_bytes += first_seg->pkt_len;
+			stats->rx_packets++;
+
+			/*
+			 * Setup receipt context for a new packet.
+			 */
+			first_seg = NULL;
+		}
+	}
+
+	/*
+	 * Record index of the next RX descriptor to probe.
+	 */
+	rxq->rx_tail = tail;
+
+	/*
+	 * Save receive context.
+	 */
+	rxq->pkt_first_seg = first_seg;
+	rxq->pkt_last_seg = last_seg;
+
+	nb_hold = (uint16_t)(nb_hold + rxq->nb_rx_hold);
+	if (nb_hold > rxq->rx_free_thresh) {
+		rte_wmb();
+
+		/* Clear RDU */
+		RTL_W32(hw, ISR0_8125, (RxOK | RxErr | RxDescUnavail));
+
+		nb_hold = 0;
+	}
+
+	rxq->nb_rx_hold = nb_hold;
+
+	return nb_rx;
+}
+
+/* ---------------------------------Tx---------------------------------- */
+
+static void
+rtl8125_tx_queue_release_mbufs(struct rtl8125_tx_queue *txq)
+{
+	int i;
+
+	PMD_INIT_FUNC_TRACE();
+
+	if (txq != NULL) {
+		if (txq->sw_ring != NULL) {
+			for (i = 0; i < txq->nb_tx_desc; i++) {
+				if (txq->sw_ring[i].mbuf != NULL) {
+					rte_pktmbuf_free_seg(txq->sw_ring[i].mbuf);
+					txq->sw_ring[i].mbuf = NULL;
+				}
+			}
+		}
+	}
+}
+
+void
+rtl8125_tx_queue_release(struct rte_eth_dev *dev, uint16_t tx_queue_id)
+{
+	struct rtl8125_tx_queue *txq = dev->data->tx_queues[tx_queue_id];
+	PMD_INIT_FUNC_TRACE();
+
+	if (txq != NULL) {
+		rtl8125_tx_queue_release_mbufs(txq);
+		rte_free(txq->sw_ring);
+		rte_free(txq);
+	}
+}
+
+void
+rtl8125_txq_info_get(struct rte_eth_dev *dev, uint16_t queue_id,
+                     struct rte_eth_txq_info *qinfo)
+{
+	struct rtl8125_tx_queue *txq;
+
+	txq = dev->data->tx_queues[queue_id];
+
+	qinfo->nb_desc = txq->nb_tx_desc;
+}
+
+static void
+rtl8125_reset_tx_queue(struct rtl8125_tx_queue *txq)
+{
+	static const struct rtl8125_tx_desc zero_txd = {0};
+	int i;
+
+	for (i = 0; i < txq->nb_tx_desc; i++)
+		txq->hw_ring[i] = zero_txd;
+
+	txq->hw_ring[txq->nb_tx_desc - 1].opts1 = rte_cpu_to_le_32(RingEnd);
+
+	txq->tx_tail = 0;
+	txq->tx_head = 0;
+	txq->tx_free = txq->nb_tx_desc - 1;
+}
+
+uint64_t
+rtl8125_get_tx_port_offloads(void)
+{
+	uint64_t tx_offload_capa;
+
+	tx_offload_capa = RTE_ETH_TX_OFFLOAD_VLAN_INSERT |
+	                  RTE_ETH_TX_OFFLOAD_IPV4_CKSUM  |
+	                  RTE_ETH_TX_OFFLOAD_UDP_CKSUM   |
+	                  RTE_ETH_TX_OFFLOAD_TCP_CKSUM   |
+	                  RTE_ETH_TX_OFFLOAD_TCP_TSO     |
+	                  RTE_ETH_TX_OFFLOAD_MULTI_SEGS;
+
+	return tx_offload_capa;
+}
+
+int
+rtl8125_tx_queue_setup(struct rte_eth_dev *dev, uint16_t queue_idx,
+                       uint16_t nb_tx_desc, unsigned int socket_id,
+                       const struct rte_eth_txconf *tx_conf)
+{
+	struct rtl8125_tx_queue *txq;
+	const struct rte_memzone *mz;
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	u32 size;
+
+	PMD_INIT_FUNC_TRACE();
+
+	if (nb_tx_desc < R8125_MIN_TX_DESC || nb_tx_desc > R8125_MAX_TX_DESC) {
+		PMD_INIT_LOG(ERR, "r8125: Number of Tx descriptors must be "
+		             "less than or equal to %d "
+		             "greater than or equal to %d\n", R8125_MAX_TX_DESC,
+		             R8125_MIN_TX_DESC);
+		return -EINVAL;
+	}
+
+	/*
+	 * If this queue existed already, free the associated memory. The
+	 * queue cannot be reused in case we need to allocate memory on
+	 * different socket than was previously used.
+	 */
+	if (dev->data->tx_queues[queue_idx] != NULL) {
+		rtl8125_tx_queue_release(dev, queue_idx);
+		dev->data->tx_queues[queue_idx] = NULL;
+	}
+
+	txq = rte_zmalloc_socket("r8125 TX queue",
+	                         sizeof(struct rtl8125_tx_queue),
+	                         RTE_CACHE_LINE_SIZE, socket_id);
+
+	if (txq == NULL) {
+		PMD_INIT_LOG(ERR, "Cannot allocate Tx queue structure");
+		return -ENOMEM;
+	}
+
+	/* Setup queue */
+	txq->nb_tx_desc = nb_tx_desc;
+	txq->port_id = dev->data->port_id;
+	txq->queue_id = queue_idx;
+	txq->tx_free_thresh = tx_conf->tx_free_thresh;
+
+	/* Allocate memory for the software ring */
+	txq->sw_ring = rte_zmalloc_socket("r8125 sw tx ring",
+	                                  nb_tx_desc * sizeof(struct rtl8125_tx_entry),
+	                                  RTE_CACHE_LINE_SIZE, socket_id);
+
+	if (txq->sw_ring == NULL) {
+		PMD_INIT_LOG(ERR,
+		             "Port %d: Cannot allocate software ring for queue %d",
+		             txq->port_id, txq->queue_id);
+		rte_free(txq);
+		return -ENOMEM;
+	}
+
+	/*
+	 * Allocate TX ring hardware descriptors. A memzone large enough to
+	 * handle the maximum ring size is allocated in order to allow for
+	 * resizing in later calls to the queue setup function.
+	 */
+	size = sizeof(struct rtl8125_tx_desc) * (nb_tx_desc + 1);
+	mz = rte_eth_dma_zone_reserve(dev, "tx_ring", queue_idx, size,
+	                              R8125_RING_ALIGN, socket_id);
+	if (mz == NULL) {
+		PMD_INIT_LOG(ERR,
+		             "Port %d: Cannot allocate hardware ring for queue %d",
+		             txq->port_id, txq->queue_id);
+		rtl8125_tx_queue_release(dev, txq->queue_id);
+		return -ENOMEM;
+	}
+
+	txq->hw = hw;
+	txq->hw_ring = mz->addr;
+	txq->hw_ring_phys_addr = mz->iova;
+
+	rtl8125_reset_tx_queue(txq);
+
+	/* EnableTxNoClose */
+	hw->NextHwDesCloPtr0 = 0;
+	hw->BeginHwDesCloPtr0 = 0;
+
+	dev->data->tx_queues[queue_idx] = txq;
+
+	return 0;
+}
+
+int
+rtl8125_tx_init(struct rte_eth_dev *dev)
+{
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_hw *hw = &adapter->hw;
+	struct rtl8125_tx_queue *txq;
+
+	txq = dev->data->tx_queues[0];
+
+	RTL_W32(hw, TxDescStartAddrLow,
+	        ((u64) txq->hw_ring_phys_addr & DMA_BIT_MASK(32)));
+	RTL_W32(hw, TxDescStartAddrHigh, ((u64) txq->hw_ring_phys_addr >> 32));
+
+	rtl8125_enable_cfg9346_write(hw);
+
+	/* Set TDFNR: TX Desc Fetch NumbeR */
+	switch (hw->mcfg) {
+	case CFG_METHOD_2 ... CFG_METHOD_11:
+		RTL_W8(hw, TDFNR, 0x10);
+		break;
+	}
+
+	rtl8125_disable_cfg9346_write(hw);
+
+	RTL_W8(hw, ChipCmd, RTL_R8(hw, ChipCmd) | CmdTxEnb);
+
+	dev->data->tx_queue_state[0] = RTE_ETH_QUEUE_STATE_STARTED;
+
+	return 0;
+}
+
+static inline uint32_t
+rtl8125_tx_vlan_tag(struct rte_mbuf *tx_pkt, uint64_t ol_flags)
+{
+	return (ol_flags & RTE_MBUF_F_TX_VLAN) ?
+	       (TxVlanTag | rte_bswap16(tx_pkt->vlan_tci)) :
+	       0;
+}
+
+static inline int
+rtl8125_tso_setup(struct rte_mbuf *tx_pkt, uint64_t ol_flags, u32 *opts)
+{
+	uint32_t mss;
+	uint64_t l4_offset;
+
+	/* Check if TCP segmentation required for this packet */
+	if (ol_flags & RTE_MBUF_F_TX_TCP_SEG) {
+		mss = tx_pkt->tso_segsz;
+		l4_offset = tx_pkt->l2_len + tx_pkt->l3_len;
+		if (l4_offset <= GTTCPHO_MAX) {
+			/* Implies IP cksum in IPv4 */
+			if (ol_flags & RTE_MBUF_F_TX_IP_CKSUM) {
+				opts[0] |= GiantSendv4;
+				opts[0] |= l4_offset << GTTCPHO_SHIFT;
+				opts[1] |= RTE_MIN(mss, MSS_MAX) << 18;
+			} else {
+				opts[0] |= GiantSendv6;
+				opts[0] |= l4_offset << GTTCPHO_SHIFT;
+				opts[1] |= RTE_MIN(mss, MSS_MAX) << 18;
+			}
+
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+static inline void
+rtl8125_setup_csum_offload(struct rtl8125_hw *hw __rte_unused,
+                           struct rte_mbuf *tx_pkt, uint64_t ol_flags, uint32_t *opts)
+{
+	uint32_t csum_cmd = 0;
+	uint64_t l4_offset;
+
+	if (ol_flags & RTE_MBUF_F_TX_IP_CKSUM)
+		csum_cmd |= TxIPCS_C;
+
+	switch (ol_flags & RTE_MBUF_F_TX_L4_MASK) {
+	case RTE_MBUF_F_TX_UDP_CKSUM:
+		csum_cmd |= TxUDPCS_C;
+		break;
+	case RTE_MBUF_F_TX_TCP_CKSUM:
+		csum_cmd |= TxTCPCS_C;
+		break;
+	}
+
+	if (csum_cmd != 0) {
+		if (ol_flags & RTE_MBUF_F_TX_IPV6) {
+			l4_offset = tx_pkt->l2_len + tx_pkt->l3_len;
+			csum_cmd |= TxIPV6F_C;
+			csum_cmd |= l4_offset << TCPHO_SHIFT;
+		} else
+			csum_cmd |= TxIPCS_C;
+		opts[1] |= csum_cmd;
+	}
+}
+
+static uint32_t
+rtl8125_get_patch_pad_len(struct rte_mbuf *tx_pkt)
+{
+	uint16_t dest_port = 0;
+	uint32_t pad_len = 0;
+	int udp_hdr_len = 8;
+	int trans_data_len, l4_offset;
+
+	if (!(tx_pkt->l4_len && (tx_pkt->data_len < 175)))
+		goto no_padding;
+
+	l4_offset = tx_pkt->l2_len + tx_pkt->l3_len;
+	trans_data_len = tx_pkt->data_len - l4_offset;
+
+	if (trans_data_len > 3 && trans_data_len < MIN_PATCH_LENGTH) {
+		rte_memcpy(&dest_port,
+		           rte_pktmbuf_mtod(tx_pkt, struct rte_ether_hdr *) + l4_offset + 2, 2);
+		dest_port = ntohs(dest_port);
+		if (dest_port == 0x13f || dest_port == 0x140) {
+			pad_len = MIN_PATCH_LENGTH - trans_data_len;
+			goto out;
+		}
+	}
+
+	if (trans_data_len < udp_hdr_len)
+		pad_len = udp_hdr_len - trans_data_len;
+
+out:
+	if ((tx_pkt->data_len + pad_len) < ETH_ZLEN)
+		pad_len = ETH_ZLEN - tx_pkt->data_len;
+
+	return pad_len;
+
+no_padding:
+
+	return 0;
+}
+
+static void
+rtl8125_ptp_patch(struct rte_mbuf *tx_pkt)
+{
+	uint32_t pad_len;
+	char *padding;
+
+	if (tx_pkt->packet_type & RTE_PTYPE_L4_UDP) {
+		pad_len = rtl8125_get_patch_pad_len(tx_pkt);
+		if (pad_len > 0) {
+			padding = rte_pktmbuf_append(tx_pkt, pad_len);
+			if (unlikely(padding == NULL))
+				PMD_DRV_LOG(ERR, "not enough mbuf trailing space\n");
+			memset(padding, 0, pad_len);
+		}
+	}
+}
+
+static inline void
+rtl8125_xmit_pkt(struct rtl8125_hw *hw, struct rtl8125_tx_queue *txq,
+                 struct rte_mbuf *tx_pkt)
+{
+
+	struct rte_mbuf *m_seg;
+	struct rte_eth_dev *dev = &rte_eth_devices[txq->port_id];
+	struct rtl8125_adapter *adapter = RTL8125_DEV_PRIVATE(dev);
+	struct rtl8125_sw_stats *stats = &adapter->sw_stats;
+	struct rtl8125_tx_desc *txd;
+	struct rtl8125_tx_entry *txe = NULL;
+	uint16_t desc_count = 0;
+	const uint16_t nb_tx_desc = txq->nb_tx_desc;
+	uint16_t tail;
+	u32 len;
+	u32 opts[2] = {0};
+	u32 opts1;
+	u32 opts2;
+	int large_send;
+	uint64_t buf_dma_addr;
+	uint64_t ol_flags;
+	uint64_t tx_ol_flags;
+
+	/* Like cur_tx */
+	tail = (uint16_t)(txq->tx_tail % nb_tx_desc);
+
+	/* If hardware offload required */
+	ol_flags = tx_pkt->ol_flags;
+	tx_ol_flags = ol_flags & RTL_TX_OFFLOAD_MASK;
+
+	opts[0] = DescOwn;
+	opts[1] = rtl8125_tx_vlan_tag(tx_pkt, tx_ol_flags);
+
+	large_send = rtl8125_tso_setup(tx_pkt, tx_ol_flags, opts);
+
+	/* No TSO */
+	if (large_send == 0) {
+		rtl8125_setup_csum_offload(hw, tx_pkt, tx_ol_flags, opts);
+
+		switch (hw->mcfg) {
+		case CFG_METHOD_2 ... CFG_METHOD_7:
+			rtl8125_ptp_patch(tx_pkt);
+			break;
+		}
+	}
+
+	for (m_seg = tx_pkt; m_seg; m_seg = m_seg->next) {
+
+		opts1 = opts[0];
+		opts2 = opts[1];
+
+		len = m_seg->data_len;
+
+		if (len == 0)
+			break;
+
+		txd = &txq->hw_ring[tail];
+
+		buf_dma_addr = rte_mbuf_data_iova(m_seg);
+		txd->addr = rte_cpu_to_le_64(buf_dma_addr);
+
+		opts1 |= len;
+		if (m_seg == tx_pkt)
+			opts1 |= FirstFrag;
+		if (!m_seg->next)
+			opts1 |= LastFrag;
+		if (tail == nb_tx_desc - 1)
+			opts1 |= RingEnd;
+
+		/* Store mbuf for freeing later */
+		txe = &txq->sw_ring[tail];
+
+		if (txe->mbuf)
+			rte_pktmbuf_free_seg(txe->mbuf);
+
+		txe->mbuf = m_seg;
+
+		txd->opts2 = rte_cpu_to_le_32(opts2);
+		rte_wmb();
+		txd->opts1 = rte_cpu_to_le_32(opts1);
+
+		tail = (tail + 1) % nb_tx_desc;
+
+		desc_count++;
+
+		stats->tx_bytes += len;
+	}
+
+	txq->tx_tail += desc_count;
+	txq->tx_free -= desc_count;
+
+	stats->tx_packets++;
+}
+
+static inline u32
+rtl8125_fast_mod_mask(const u32 input, const u32 mask)
+{
+	return input > mask ? input & mask : input;
+}
+
+static u32
+rtl8125_get_hw_clo_ptr(struct rtl8125_hw *hw)
+{
+	switch (hw->HwSuppTxNoCloseVer) {
+	case 3:
+		return RTL_R16(hw, hw->hw_clo_ptr_reg);
+	case 6:
+		return RTL_R32(hw, hw->hw_clo_ptr_reg);
+	default:
+		return 0;
+	}
+}
+
+static u32
+rtl8125_get_opts1(struct rtl8125_tx_desc *txd)
+{
+	rte_smp_rmb();
+
+	return rte_le_to_cpu_32(txd->opts1);
+}
+
+static void
+rtl8125_tx_clean(struct rtl8125_hw *hw, struct rtl8125_tx_queue *txq)
+{
+	struct rtl8125_tx_entry *sw_ring = txq->sw_ring;
+	struct rtl8125_tx_entry *txe;
+	struct rtl8125_tx_desc *txd;
+	const uint8_t enable_tx_no_close = hw->EnableTxNoClose;
+	const uint16_t nb_tx_desc = txq->nb_tx_desc;
+	uint16_t head = txq->tx_head;
+	uint16_t desc_freed = 0;
+	uint32_t tx_left;
+	uint32_t tx_desc_closed, next_hw_desc_clo_ptr0;
+
+	if (txq == NULL)
+		return;
+
+	if (enable_tx_no_close) {
+		next_hw_desc_clo_ptr0 = rtl8125_get_hw_clo_ptr(hw);
+		hw->NextHwDesCloPtr0 = next_hw_desc_clo_ptr0;
+		tx_desc_closed = rtl8125_fast_mod_mask(next_hw_desc_clo_ptr0 -
+		                                       hw->BeginHwDesCloPtr0, hw->MaxTxDescPtrMask);
+		tx_left = RTE_MIN(((READ_ONCE(txq->tx_tail) % nb_tx_desc) - head),
+		                  tx_desc_closed);
+		hw->BeginHwDesCloPtr0 += tx_left;
+	} else
+		tx_left = (READ_ONCE(txq->tx_tail) % nb_tx_desc) - head;
+
+	while (tx_left > 0) {
+		txd = &txq->hw_ring[head];
+
+		if (!enable_tx_no_close && (rtl8125_get_opts1(txd) & DescOwn))
+			break;
+
+		txe = &sw_ring[head];
+		if (txe->mbuf) {
+			rte_pktmbuf_free_seg(txe->mbuf);
+			txe->mbuf = NULL;
+		}
+
+		head = (head + 1) % nb_tx_desc;
+		desc_freed++;
+		tx_left--;
+	}
+	txq->tx_free += desc_freed;
+	txq->tx_head = head;
+}
+
+int
+rtl8125_tx_done_cleanup(void *tx_queue, uint32_t free_cnt)
+{
+	struct rtl8125_tx_queue *txq = tx_queue;
+	struct rtl8125_hw *hw = txq->hw;
+	struct rtl8125_tx_entry *sw_ring = txq->sw_ring;
+	struct rtl8125_tx_entry *txe;
+	struct rtl8125_tx_desc *txd;
+	const uint8_t enable_tx_no_close = hw->EnableTxNoClose;
+	const uint16_t nb_tx_desc = txq->nb_tx_desc;
+	uint16_t head = txq->tx_head;
+	uint16_t desc_freed = 0;
+	uint32_t tx_left;
+	uint32_t status;
+	uint32_t count = 0;
+	uint32_t tx_desc_closed, next_hw_desc_clo_ptr0;
+
+	if (txq == NULL)
+		return -ENODEV;
+
+	if (enable_tx_no_close) {
+		next_hw_desc_clo_ptr0 = rtl8125_get_hw_clo_ptr(hw);
+		hw->NextHwDesCloPtr0 = next_hw_desc_clo_ptr0;
+		tx_desc_closed = rtl8125_fast_mod_mask(next_hw_desc_clo_ptr0 -
+		                                       hw->BeginHwDesCloPtr0, hw->MaxTxDescPtrMask);
+		tx_left = RTE_MIN(((READ_ONCE(txq->tx_tail) % nb_tx_desc) - head),
+		                  tx_desc_closed);
+		hw->BeginHwDesCloPtr0 += tx_left;
+	} else
+		tx_left = (READ_ONCE(txq->tx_tail) % nb_tx_desc) - head;
+
+	while (tx_left > 0) {
+		txd = &txq->hw_ring[head];
+
+		status = rtl8125_get_opts1(txd);
+
+		if (!enable_tx_no_close && (status & DescOwn))
+			break;
+
+		txe = &sw_ring[head];
+		if (txe->mbuf) {
+			rte_pktmbuf_free_seg(txe->mbuf);
+			txe->mbuf = NULL;
+		}
+
+		head = (head + 1) % nb_tx_desc;
+
+		desc_freed++;
+		tx_left--;
+
+		if (status & LastFrag) {
+			count++;
+			if (count == free_cnt)
+				break;
+		}
+
+	}
+
+	txq->tx_free += desc_freed;
+	txq->tx_head = head;
+
+	return count;
+}
+
+/* PMD transmit function */
+uint16_t
+rtl8125_xmit_pkts(void *tx_queue, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
+{
+	struct rtl8125_tx_queue *txq = tx_queue;
+	struct rtl8125_hw *hw = txq->hw;
+	struct rte_mbuf *tx_pkt;
+	uint16_t nb_tx;
+	u8 enable_tx_no_close = hw->EnableTxNoClose;
+
+	RTE_ASSERT(RTL_R8(hw, ChipCmd) & CmdTxEnb);
+
+	PMD_TX_LOG(DEBUG,
+	           "port %d txq %d pkts: %d tx_free=%d tx_tail=%d tx_head=%d",
+	           txq->port_id, txq->queue_id, nb_pkts, txq->tx_free,
+	           txq->tx_tail, txq->tx_head);
+
+	for (nb_tx = 0; nb_tx < nb_pkts; nb_tx++) {
+
+		tx_pkt = *tx_pkts++;
+
+		if (txq->tx_free < tx_pkt->nb_segs)
+			break;
+
+		/* Check mbuf is valid */
+		if ((tx_pkt->nb_segs == 0) ||
+		    (tx_pkt->pkt_len == 0) ||
+		    ((tx_pkt->nb_segs > 1) && (tx_pkt->next == NULL)))
+			break;
+
+		rtl8125_xmit_pkt(hw, txq, tx_pkt);
+	}
+
+	rte_wmb();
+
+	if (nb_tx > 0) {
+		if (enable_tx_no_close)
+			if (hw->HwSuppTxNoCloseVer > 3)
+				RTL_W32(hw, hw->sw_tail_ptr_reg, txq->tx_tail);
+			else
+				RTL_W16(hw, hw->sw_tail_ptr_reg, txq->tx_tail);
+		else
+			RTL_W16(hw, TPPOLL_8125, BIT_0);
+	}
+
+	PMD_TX_LOG(DEBUG, "rtl8125_xmit_pkts %d transmitted", nb_tx);
+
+	rtl8125_tx_clean(hw, txq);
+
+	return nb_tx;
+}
+
+int
+rtl8125_stop_queues(struct rte_eth_dev *dev)
+{
+	struct rtl8125_tx_queue *txq;
+	struct rtl8125_rx_queue *rxq;
+
+	PMD_INIT_FUNC_TRACE();
+
+	txq = dev->data->tx_queues[0];
+
+	rtl8125_tx_queue_release_mbufs(txq);
+	rtl8125_reset_tx_queue(txq);
+	dev->data->tx_queue_state[0] = RTE_ETH_QUEUE_STATE_STOPPED;
+
+	rxq = dev->data->rx_queues[0];
+
+	rtl8125_rx_queue_release_mbufs(rxq);
+	rtl8125_reset_rx_queue(rxq);
+	dev->data->rx_queue_state[0] = RTE_ETH_QUEUE_STATE_STOPPED;
+
+	return 0;
+}
+
+void
+rtl8125_free_queues(struct rte_eth_dev *dev)
+{
+	PMD_INIT_FUNC_TRACE();
+
+	rtl8125_eth_dma_zone_free(dev, "rx_ring", 0);
+	rtl8125_rx_queue_release(dev, 0);
+	dev->data->rx_queues[0] = 0;
+	dev->data->nb_rx_queues = 0;
+
+	rtl8125_eth_dma_zone_free(dev, "tx_ring", 0);
+	rtl8125_tx_queue_release(dev, 0);
+	dev->data->tx_queues[0] = 0;
+	dev->data->nb_tx_queues = 0;
+}
