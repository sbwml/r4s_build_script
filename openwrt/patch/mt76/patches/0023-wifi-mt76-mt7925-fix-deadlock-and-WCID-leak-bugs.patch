From e4c4a356794090e0a5b2dec0a5b8b40c80e60d84 Mon Sep 17 00:00:00 2001
From: Zac <zac@zacbowling.com>
Date: Mon, 19 Jan 2026 15:00:33 -0800
Subject: [PATCH 23/24] wifi: mt76: mt7925: fix deadlock and WCID leak bugs

Fix two bugs identified by code review:

1. Potential deadlock in ROC path:
   cancel_work_sync() was called inside mt7925_set_roc() and
   mt7925_set_mlo_roc() while the mutex was already held by the
   caller (e.g., mt7925_remain_on_channel). If roc_work was waiting
   for the mutex, this would deadlock. Move cancel_work_sync() to
   callers, before they acquire the mutex.

2. WCID resource leak in mt7925_mac_link_sta_add:
   After WCID allocation and registration (rcu_assign_pointer),
   multiple error paths returned without cleaning up the WCID index.
   This could exhaust the WCID table over time. Add proper error
   cleanup path that clears the wcid pointer and frees the index.

Signed-off-by: Zac Bowling <zac@zacbowling.com>
---
 mt7925/main.c | 59 +++++++++++++++++++++++++++++----------------------
 1 file changed, 34 insertions(+), 25 deletions(-)

--- a/mt7925/main.c
+++ b/mt7925/main.c
@@ -630,20 +630,12 @@ static int mt7925_set_roc(struct mt792x_
 	 * If abort_async was called but roc_work never ran (timer was cancelled
 	 * before firing), the abort flag would be stale and incorrectly abort
 	 * this new ROC session.
+	 *
+	 * Note: cancel_work_sync must be called by our callers BEFORE they
+	 * acquire the mutex, to prevent deadlock. See mt7925_remain_on_channel.
 	 */
 	clear_bit(MT76_STATE_ROC_ABORT, &phy->mt76->state);
 
-	/* Cancel any pending roc_work from a previous async-aborted ROC.
-	 * This prevents a race where stale work could abort our new ROC:
-	 * 1. Previous ROC's roc_work clears ROC flag with test_and_clear
-	 * 2. Work blocks waiting for mutex
-	 * 3. abort_async called, sets abort flag
-	 * 4. New ROC starts here, clears abort flag, sets ROC flag
-	 * 5. Stale work gets mutex, calls mcu_abort_roc with NEW token
-	 * Safe to call here since we don't hold the mutex yet.
-	 */
-	cancel_work_sync(&phy->roc_work);
-
 	if (test_and_set_bit(MT76_STATE_ROC, &phy->mt76->state))
 		return -EBUSY;
 
@@ -692,13 +684,11 @@ static int mt7925_set_mlo_roc(struct mt7
 		}
 	}
 
-	/* Clear any stale abort flag from previous ROC abort_async calls */
-	clear_bit(MT76_STATE_ROC_ABORT, &phy->mt76->state);
-
-	/* Cancel any pending roc_work from a previous async-aborted ROC.
-	 * See comment in mt7925_set_roc for the race condition this prevents.
+	/* Clear any stale abort flag from previous ROC abort_async calls.
+	 * Note: cancel_work_sync must be called by our callers BEFORE they
+	 * acquire the mutex, to prevent deadlock.
 	 */
-	cancel_work_sync(&phy->roc_work);
+	clear_bit(MT76_STATE_ROC_ABORT, &phy->mt76->state);
 
 	if (WARN_ON_ONCE(test_and_set_bit(MT76_STATE_ROC, &phy->mt76->state)))
 		return -EBUSY;
@@ -734,6 +724,11 @@ static int mt7925_remain_on_channel(stru
 	struct mt792x_phy *phy = mt792x_hw_phy(hw);
 	int err;
 
+	/* Cancel any pending ROC work BEFORE acquiring mutex to prevent
+	 * deadlock. The work may be waiting for mutex we're about to take.
+	 */
+	cancel_work_sync(&phy->roc_work);
+
 	mt792x_mutex_acquire(phy->dev);
 	err = mt7925_set_roc(phy, &mvif->bss_conf,
 			     chan, duration, MT7925_ROC_REQ_ROC);
@@ -1068,14 +1063,16 @@ static int mt7925_mac_link_sta_add(struc
 
 	ret = mt76_connac_pm_wake(&dev->mphy, &dev->pm);
 	if (ret)
-		return ret;
+		goto err_wcid;
 
 	mt7925_mac_wtbl_update(dev, idx,
 			       MT_WTBL_UPDATE_ADM_COUNT_CLEAR);
 
 	link_conf = mt792x_vif_to_bss_conf(vif, link_id);
-	if (!link_conf)
-		return -EINVAL;
+	if (!link_conf) {
+		ret = -EINVAL;
+		goto err_wcid;
+	}
 
 	/* should update bss info before STA add */
 	if (vif->type == NL80211_IFTYPE_STATION && !link_sta->sta->tdls) {
@@ -1087,7 +1084,7 @@ static int mt7925_mac_link_sta_add(struc
 			ret = mt7925_mcu_add_bss_info(&dev->phy, mconf->mt76.ctx,
 						      link_conf, link_sta, false);
 		if (ret)
-			return ret;
+			goto err_wcid;
 	}
 
 	if (ieee80211_vif_is_mld(vif) &&
@@ -1095,28 +1092,33 @@ static int mt7925_mac_link_sta_add(struc
 		ret = mt7925_mcu_sta_update(dev, link_sta, vif, true,
 					    MT76_STA_INFO_STATE_NONE);
 		if (ret)
-			return ret;
+			goto err_wcid;
 	} else if (ieee80211_vif_is_mld(vif) &&
 		   link_sta != mlink->pri_link) {
 		ret = mt7925_mcu_sta_update(dev, mlink->pri_link, vif,
 					    true, MT76_STA_INFO_STATE_ASSOC);
 		if (ret)
-			return ret;
+			goto err_wcid;
 
 		ret = mt7925_mcu_sta_update(dev, link_sta, vif, true,
 					    MT76_STA_INFO_STATE_ASSOC);
 		if (ret)
-			return ret;
+			goto err_wcid;
 	} else {
 		ret = mt7925_mcu_sta_update(dev, link_sta, vif, true,
 					    MT76_STA_INFO_STATE_NONE);
 		if (ret)
-			return ret;
+			goto err_wcid;
 	}
 
 	mt76_connac_power_save_sched(&dev->mphy, &dev->pm);
 
 	return 0;
+
+err_wcid:
+	rcu_assign_pointer(dev->mt76.wcid[idx], NULL);
+	mt76_wcid_mask_clear(dev->mt76.wcid_mask, idx);
+	return ret;
 }
 
 static int
@@ -2096,6 +2098,8 @@ static void mt7925_mgd_prepare_tx(struct
 	u16 duration = info->duration ? info->duration :
 		       jiffies_to_msecs(HZ);
 
+	cancel_work_sync(&mvif->phy->roc_work);
+
 	mt792x_mutex_acquire(dev);
 	mt7925_set_roc(mvif->phy, &mvif->bss_conf,
 		       mvif->bss_conf.mt76.ctx->def.chan, duration,
@@ -2244,6 +2248,11 @@ mt7925_change_vif_links(struct ieee80211
 	if (old_links == new_links)
 		return 0;
 
+	/* Cancel any pending ROC work before acquiring mutex to prevent
+	 * deadlock if mt7925_set_mlo_roc is called below.
+	 */
+	cancel_work_sync(&phy->roc_work);
+
 	mt792x_mutex_acquire(dev);
 
 	for_each_set_bit(link_id, &rem, IEEE80211_MLD_MAX_NUM_LINKS) {
